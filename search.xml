<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>270</title>
    <url>/2025/270/</url>
    <content><![CDATA[<p>270天。</p>
<span id="more"></span>
<p>2024.10.12 ~ 2025.7.9</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Dumby的sb日常</category>
      </categories>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title>40配列键盘说是</title>
    <url>/2025/40%E9%85%8D%E5%88%97%E9%94%AE%E7%9B%98%E8%AF%B4%E6%98%AF/</url>
    <content><![CDATA[<p>我发誓我真的只买一台客制化键盘😭😭😭。。</p>
<span id="more"></span>
<p>最近记笔记的时候发现手写笔记实在是慢，考虑到我平时基本用的都是电子书，搭配MinerU的话用键盘敲字记笔记效率应该会高得多。<br>原来那个平板的妙控键盘手感还行其实，但是就是想买副键盘🤓，又想要平时放书包里比较便携，于是找到了TU40，选了个plunck40配列的（主要不想装卫星轴🤓）。</p>
<p>买了个白色外壳的，然后还买了五十个无刻白键帽以及水蜜桃轴（记笔记用键盘肯定得静音啊）</p>
<p><img 
  src="零件图.jpg" 
  alt="到手时的零件" 
  title="到手时的零件"
></p>
<p>接着就是装配了。</p>
<p><img 
  src="装配图.jpg" 
  alt="装配图" 
  title="装配"
></p>
<p>最后装好点亮长这样：</p>
<p><img 
  src="点亮图.jpg" 
  alt="点亮图" 
  title="点亮图"
></p>
<p>水蜜桃轴手感还能接受，轴确实静音，但是空腔声有点大。</p>
<p>键帽也就还行的样子。</p>
<p>套件塑料外壳稍微有点拉了，质感不太行。直列40配列，还需要适应一下，不过打字速度没有慢很多，主要是zxcv这行字母老是会打错，其他都还行。</p>
<p>便携性的话肯定不用说了，可以和我原来这幅用了三四年的黑爵ak35i对比一下。</p>
<p><img 
  src="对比图.jpg" 
  alt="对比图" 
  title="对比图"
></p>
<p>总之呢是不错不错，这是入手的第一台客制化键盘，以后应该不会再入了，主要是因为本来只是想换个小点的颜值高点的键盘（价格也稍微低点）。本来想买那个EPOMAKER的TH40的，不过稍微有点贵了😭。</p>
<p>以后记笔记就用这个🥳🥳。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Dumby的sb日常</category>
      </categories>
      <tags>
        <tag>日常</tag>
        <tag>键盘</tag>
      </tags>
  </entry>
  <entry>
    <title>A-Star学习笔记</title>
    <url>/2021/A-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>介绍A星算法的定义和应用（内附代码实现）。</p>
<span id="more"></span>
<h2 id="A-Star-是啥？？-A-Star-用来干啥？？"><a href="#A-Star-是啥？？-A-Star-用来干啥？？" class="headerlink" title="A-Star 是啥？？ A-Star 用来干啥？？"></a>A-Star 是啥？？ A-Star 用来干啥？？</h2><p>首先，<strong>A-Star 算法只能用在数据规模很大的搜索题中</strong>，这时直接用 BFS 会超时，而利用 <strong>启发函数（估价函数）</strong> 优化后的 BFS ——A-Star 算法就能处理这种问题。<br>A-Star 算法通过一个 <strong>“启发函数（估价函数）”</strong> 来使到达终点需要遍历的状态大大减少，以达到提高运行效率的作用。</p>
<p>就比如：当普通的 BFS 需要遍历 $10^{8}$、$10^{9}$ 甚至 $10^{20}$ 个状态才能到达终点时，通过 A-Star 的启发函数 则只需要遍历极少的状态就能达到终点。</p>
<p><strong>注意：</strong> 使用 A-Star 时需要判断是否有解，当<strong>无解</strong>时（或者是<strong>数据规模较小</strong>时） A-Star 的效率可能会比朴素的 BFS 还低。</p>
<h2 id="A-Star-代码框架"><a href="#A-Star-代码框架" class="headerlink" title="A-Star 代码框架"></a>A-Star 代码框架</h2><p>首先，我们要把朴素的 BFS 中的<strong>队列</strong>换成<strong>优先队列</strong>。<br>伪代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> ( ! q.<span class="built_in">size</span>() ) </span><br><span class="line">&#123;</span><br><span class="line">	t = 优先队列（小根堆）队头 ;</span><br><span class="line">	<span class="keyword">if</span> ( t == 终点 ) <span class="keyword">break</span> ;</span><br><span class="line">	<span class="keyword">for</span> ( 枚举 t 的所有邻边 )</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> ( 子节点可取 ) </span><br><span class="line">		&#123;</span><br><span class="line">			邻边入队；</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么这个优先队列中存啥呢？<br>首先，肯定要把该节点到起点的<strong>真实距离</strong>存下来；<br>此次，要把 真实距离+该节点到终点的<strong>估计距离</strong> 的总和存下来，并作为<strong>优先队列的排序关键字</strong>。<br>这个总和的含义就是 <strong>起点到终点的总的估计距离</strong> 。<br>每次取出优先队列的队头出来即每次取一个 估计距离最小的点 来扩展。</p>
<h2 id="关于估价函数"><a href="#关于估价函数" class="headerlink" title="关于估价函数"></a>关于估价函数</h2><p>估价函数是 A-Star 算法的核心部分。<br>首先，要知道 <strong>估价函数是针对每个题目具体情况设计的</strong> ，有许多种方法可以算出估值，常用的有 Manhattan 等。</p>
<p>设当前点为 <strong>state</strong> 。<br>设当前点到起点的<strong>真实距离</strong>为<strong>d[state]</strong>；<br>设当前点到终点的<strong>估计距离</strong>为 <strong>f[state]</strong>；<br>设当前点到终点的<strong>真实距离</strong>为 <strong>g[state]</strong>；<br>那么我们设计的估计函数必须满足如下性质：</p>
<ol>
<li>对于任意的 <strong>state</strong> ，都必须满足 <strong>f[state] ≤ g[state]</strong>。</li>
<li>如果满足该条件，则当终点第一次出队时一定是<strong>最小值</strong>。</li>
</ol>
<p>下面给出证明：</p>
<p>我们先证明第 1 点：</p>
<p>可用极限法证明：当估计距离为无限大时（此时估值绝对大于真值），该节点会被压在堆底无法取出；同样的，当最优解的估值被估计成无限大时，最优解的节点也会被压在堆底，导致非最优解上的节点被取出拓展，直到取出了终点产生错误答案。<br>所以，对于任意的 <strong>state</strong> ，都必须满足 <strong>f[state] ≤ g[state]</strong>。</p>
<p>我们再利用反证法证明第 2 点：</p>
<p><em><del>反正他就是这样，我也说不了什么</del></em><br>我们设终点第一次出队时<strong>不是最小值</strong>。<br>也就是说此时终点的 d[state] 严格大于 d[最优解] 。<br>此时队列中肯定存在最优解路径上的某一个点，设该点为 u 。<br>那么最优解的长度就等于 <strong>d[u]+g[u]</strong> 。<br>由于我们的 <strong>f[u]</strong> 是小于 <strong>g[u]</strong> 的，可以得出 <strong>最优解的长度 = d[最优解] = d[u]+g[u] ≥ d[u]+f[u]</strong> 。<br>又因为 d[state] 大于 d[最优解] ，所以 d[state] 大于 g[u]+f[u] 。<br>这也就意味着 <strong>小根堆中还存在一个比队头还小的元素</strong> ，与小根堆的定义矛盾。<br>所以，如果满足该条件，则当终点第一次出队时一定是<strong>最小值</strong>。</p>
<p>综上：对于任意的 <strong>state</strong> ，都必须满足 <strong>f[state] ≤ g[state]</strong>；如果满足，则当终点第一次出队时一定是<strong>最小值</strong>。</p>
<p>证毕。</p>
<p><strong>tips：</strong> 估值越接近真值，A-Star 的效率越高。</p>
<p><strong>注意： 只有在终点第一次被取出时能保证是最小值，其他节点不一定是最小值。</strong><br>因为我们的估计函数是针对终点设计的，估值也是针对终点计算出来的，小根堆的排序关键字也是起点到终点的总估值，所以只能保证终点第一次被取出时是最小值。</p>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="八数码"><a href="#八数码" class="headerlink" title="八数码"></a>八数码</h3><p><a href="https://www.acwing.com/problem/content/181/">ACWing题面</a> 和 <a href="https://www.luogu.com.cn/problem/P1379">洛谷题面</a></p>
<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一行八个数字和一个 “ x ” （x 表示空格）表示 3 * 3 的一个矩阵。<br>请问将该矩阵恢复到原状需要如何操作（需要几步）。<br>原状： 1 2 3 4 5 6 7 8 x</p>
<h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p>首先判定可解性：计算初态与终态的逆序对个数，如果两者奇偶性相同，则有解，否则无解。<br>又因为终态已经确定，逆序对个数为 0 ，所以初态的逆序对个数一定要为偶数。<br><strong>注意：使用 A-Star 算法前都应判断一下可解性，因为当无解时用 A-Star 效率会非常低。</strong></p>
<p><del>题目蛮简单的</del>，直接在代码中解释吧。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIS pair<span class="string">&lt;int,string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(string s)</span> </span></span><br><span class="line"><span class="function"></span>&#123;   <span class="comment">//估值函数</span></span><br><span class="line">    <span class="comment">//此处设计的估值为 当前状态各个数字到终态的对应数字处的曼哈顿距离的总和</span></span><br><span class="line">    <span class="comment">//即当前状态的 1 到终态的 1 的曼哈顿距离 加上 当前状态的 2 到终态的 2 的曼哈顿距离 加上......</span></span><br><span class="line">	<span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (s[i] != <span class="string">&#x27;x&#x27;</span>) </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> t = s[i] - <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">			ans += <span class="built_in">abs</span>(i / <span class="number">3</span> - t / <span class="number">3</span>) + <span class="built_in">abs</span>(i % <span class="number">3</span> - t % <span class="number">3</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;  <span class="comment">//返回估值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">unordered_map &lt; string, <span class="type">int</span> &gt; d;   <span class="comment">//用来记录到达某个状态所需的步数</span></span><br><span class="line">unordered_map &lt; string, pair&lt;<span class="type">char</span>, string&gt; &gt; pre;   <span class="comment">//用来记录到达某状态的前驱状态，三个维度分别表示：当前状态、从前驱状态转移到当前状态所移动的方向、前驱状态</span></span><br><span class="line">priority_queue &lt; PIS, vector &lt;PIS&gt;, greater&lt;PIS&gt; &gt; heap;   <span class="comment">//小根堆：first存储起点到终点的总估计值，second存储当前状态</span></span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">bfs</span><span class="params">(string st)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string en = <span class="string">&quot;12345678x&quot;</span>;   <span class="comment">//定义终态</span></span><br><span class="line">	<span class="type">char</span> op[] = <span class="string">&quot;urdl&quot;</span>;   <span class="comment">//定义方向</span></span><br><span class="line">	d[st] = <span class="number">0</span>;   <span class="comment">//将起点到起点的距离设为 0 。</span></span><br><span class="line">	heap.<span class="built_in">push</span>(&#123;<span class="built_in">f</span>(st), st&#125;);   <span class="comment">//将初态入队</span></span><br><span class="line">	<span class="type">int</span> fx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, fy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">	<span class="keyword">while</span> (heap.<span class="built_in">size</span>()) </span><br><span class="line">	&#123;  <span class="comment">//堆未空</span></span><br><span class="line">		PIS t = heap.<span class="built_in">top</span>();  <span class="comment">//取出堆顶</span></span><br><span class="line">		heap.<span class="built_in">pop</span>();</span><br><span class="line">		string state = t.second;</span><br><span class="line">		<span class="keyword">if</span> (state == en)<span class="keyword">break</span>;   <span class="comment">//如果终点出队，则结束循环</span></span><br><span class="line">		<span class="type">int</span> x, y;  <span class="comment">//找出空格x的位置</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (state[i] == <span class="string">&#x27;x&#x27;</span>) </span><br><span class="line">			&#123;</span><br><span class="line">				x = i / <span class="number">3</span>;</span><br><span class="line">				y = i % <span class="number">3</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		string s = state;  <span class="comment">//将前驱状态保存，方便还原</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> a = x + fx[i], b = y + fy[i];</span><br><span class="line">			<span class="keyword">if</span> (a &lt; <span class="number">0</span> || a &gt; <span class="number">2</span> || b &lt; <span class="number">0</span> || b &gt; <span class="number">2</span>) <span class="keyword">continue</span>;  <span class="comment">//判断移动位置是否在矩阵内</span></span><br><span class="line">			state = s;  <span class="comment">//还原状态</span></span><br><span class="line">			<span class="built_in">swap</span>(state[x * <span class="number">3</span> + y], state[a * <span class="number">3</span> + b]);   <span class="comment">//移动空格</span></span><br><span class="line">			<span class="keyword">if</span> (!d.<span class="built_in">count</span>(state) || d[state] &gt; d[s] + <span class="number">1</span>) </span><br><span class="line">			&#123;  <span class="comment">//如果当前状态未出现过 或者 当前状态的步数可以更新</span></span><br><span class="line">				d[state] = d[s] + <span class="number">1</span>;  <span class="comment">//更新步数</span></span><br><span class="line">				pre[state] = &#123;op[i], s&#125;;   <span class="comment">//储存前驱</span></span><br><span class="line">				heap.<span class="built_in">push</span>(&#123;d[state] + <span class="built_in">f</span>(state), state&#125;);  <span class="comment">//新状态入队</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	string ans;</span><br><span class="line">	<span class="keyword">while</span> (en != st) </span><br><span class="line">	&#123;  <span class="comment">//求出移动方案</span></span><br><span class="line">		ans += pre[en].first;</span><br><span class="line">		en = pre[en].second;  <span class="comment">//从终态往回求移动方案直到终态等于初态</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">reverse</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());  <span class="comment">//由于是从终态开始的，所以方案是倒着的，需要翻转一下。</span></span><br><span class="line">	<span class="keyword">return</span> ans;  <span class="comment">//返回方案</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string st, seq;</span><br><span class="line">	string c;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; i++) </span><br><span class="line">	&#123;</span><br><span class="line">		cin &gt;&gt; c;   <span class="comment">//小技巧：让你输入字符时用字符串代替，可以自动滤去空格和回车</span></span><br><span class="line">		st += c[<span class="number">0</span>];  <span class="comment">//记录开始时的矩阵</span></span><br><span class="line">		<span class="keyword">if</span> (c[<span class="number">0</span>] != <span class="string">&#x27;x&#x27;</span>)seq += c[<span class="number">0</span>];   <span class="comment">//记录下所有的数字用来计算逆序对</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//计算逆序对对数</span></span><br><span class="line">	<span class="type">int</span> cn = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; <span class="number">8</span>; j++)</span><br><span class="line">			<span class="keyword">if</span> (seq[i] &gt; seq[j])cn++;  <span class="comment">//如果前面的数字大于后面的数字，则将个数加一。</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (cn &amp; <span class="number">1</span>)<span class="built_in">printf</span>(<span class="string">&quot;unsolvable&quot;</span>);  <span class="comment">//如果逆序对个数为奇数，则无解。</span></span><br><span class="line">	<span class="keyword">else</span> cout &lt;&lt; <span class="built_in">bfs</span>(st);  <span class="comment">//否则进行 BFS</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来还有一种题型。</p>
<h3 id="第-K-短路"><a href="#第-K-短路" class="headerlink" title="第 K 短路"></a>第 K 短路</h3><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><p>给一张有向图，给出起点S、终点T、K，求出从起点到终点的第 K 短路（路径允许重复经过点或边）。<br>注意：每条最短路中至少要包含一条边。</p>
<h4 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h4><p>首先肯定是想到打暴力。<br>把 S 到 T 的每一条路径长都算出来，再找出第 K 短的路。<br>但由于数据庞大，暴力只能骗到一点分。<br>而数据庞大时我们可以用 A-Star 来做。</p>
<p>先考虑估价函数怎么打。<br>因为估值要小于等于真值，同时又要尽可能接近真值，那么我们可以把 <strong>当前点到终点的最短路</strong> 作为当前点到终点的估值。<br>而计算这个估值只需要 在反向图上跑一遍 dijkstra 就好了。</p>
<p>估价函数设计出来后怎么求第 K 短路？<br><del>由数学归纳法易证</del>，当终点被第 K 次从队中取出时对应的路径就是第 K 短路。</p>
<p>所以，代码就很好写了。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PII pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIII pair<span class="string">&lt;int,PII&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>, M = <span class="number">200020</span>;</span><br><span class="line"><span class="type">int</span> n, m, cn, h[M], rh[M], nxt[M], to[M], w[M], d[N], v[N], S, T, K;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addh</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> </span></span><br><span class="line"><span class="function"></span>&#123;   <span class="comment">//存正向图</span></span><br><span class="line">	nxt[++cn] = h[a];</span><br><span class="line">	to[cn] = b;</span><br><span class="line">	w[cn] = c;</span><br><span class="line">	h[a] = cn;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addrh</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> </span></span><br><span class="line"><span class="function"></span>&#123;   <span class="comment">//存反向图</span></span><br><span class="line">	nxt[++cn] = rh[a];</span><br><span class="line">	to[cn] = b;</span><br><span class="line">	w[cn] = c;</span><br><span class="line">	rh[a] = cn;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijk</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;    <span class="comment">//dijkstra，同时也是估价函数</span></span><br><span class="line">	priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt; &gt; q;   <span class="comment">//小根堆，first存到终点真实距离，second存节点号</span></span><br><span class="line">	q.<span class="built_in">push</span>(&#123;<span class="number">0</span>, T&#125;);   <span class="comment">//将终点压入队中，距离为 0 </span></span><br><span class="line">	<span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> d);   <span class="comment">//将到终点的距离初始化为正无穷</span></span><br><span class="line">	d[T] = <span class="number">0</span>;  <span class="comment">//终点到终点的距离为 0</span></span><br><span class="line">	<span class="keyword">while</span> (q.<span class="built_in">size</span>()) </span><br><span class="line">	&#123;  <span class="comment">//堆不空</span></span><br><span class="line">		PII t = q.<span class="built_in">top</span>();   <span class="comment">//取出堆顶</span></span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="type">int</span> x = t.second;</span><br><span class="line">		<span class="keyword">if</span> (v[x])<span class="keyword">continue</span>;   <span class="comment">//防止重复遍历</span></span><br><span class="line">		v[x] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = rh[x]; i; i = nxt[i]) </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> j = to[i];</span><br><span class="line">			<span class="keyword">if</span> (d[j] &gt; d[x] + w[i]) </span><br><span class="line">			&#123;   <span class="comment">//如果子节点到终点的距离可以更新</span></span><br><span class="line">				d[j] = d[x] + w[i];   <span class="comment">//更新距离</span></span><br><span class="line">				q.<span class="built_in">push</span>(&#123;d[j], j&#125;);   <span class="comment">//将子节点入队</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">astar</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;   <span class="comment">// A*</span></span><br><span class="line">	priority_queue&lt;PIII, vector&lt;PIII&gt;, greater&lt;PIII&gt; &gt; q;  <span class="comment">//小根堆，三维分别存 经过当前点的从起点到终点的路径的估计距离、起点到当前点的真实距离、节点号</span></span><br><span class="line">	<span class="built_in">memset</span>(v, <span class="number">0</span>, <span class="keyword">sizeof</span> v);    <span class="comment">// v 数组用来记录节点出队几次</span></span><br><span class="line">	q.<span class="built_in">push</span>(&#123;d[S], &#123;<span class="number">0</span>, S&#125;&#125;);   <span class="comment">//将起点入队</span></span><br><span class="line">	<span class="keyword">while</span> (q.<span class="built_in">size</span>()) </span><br><span class="line">	&#123;</span><br><span class="line">		PIII x = q.<span class="built_in">top</span>();   <span class="comment">//取出堆顶</span></span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="type">int</span> t = x.second.second, dist = x.second.first;</span><br><span class="line">		<span class="comment">//t 为节点号，dist 为起点到当前点的真实距离</span></span><br><span class="line">		v[t]++;   <span class="comment">// t 节点的出队次数加一</span></span><br><span class="line">		<span class="keyword">if</span> (v[T] == K) <span class="keyword">return</span> dist;   <span class="comment">//如果终点已经出队 K 次，则停止循环</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = h[t]; i; i = nxt[i]) </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> j = to[i];</span><br><span class="line">			<span class="keyword">if</span> (v[j] &lt; K) q.<span class="built_in">push</span>(&#123;dist + w[i] + d[j], &#123;dist + w[i], j&#125;&#125;);</span><br><span class="line">			<span class="comment">//如果子节点的出队次数不到 K 次，则将该节点入队</span></span><br><span class="line">			<span class="comment">//不到 K 次才入队是因为 </span></span><br><span class="line">			<span class="comment">//对于任意正整数 i 和任意节点 x ，当 x 被第 i 次取出时，对应的就是起点 S 到该节点的第 K 短路</span></span><br><span class="line">			<span class="comment">//而由于 估值 为 该节点到终点的最短路 </span></span><br><span class="line">			<span class="comment">//所以 经过该节点的 连接起点 S 和终点 T 的路径（长度等于 该点估值 加上 起点到该节点的真实距离）只能更长，不能更短</span></span><br><span class="line">			<span class="comment">//所以当 一个点出队次数大于 K 次后，经过该点的路径就不可能是第 K 短路了，也就没必要再入队了。</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);   <span class="comment">//输入点数和边数</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> a, b, c;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">		<span class="built_in">addh</span>(a, b, c);    <span class="comment">//存入正向图</span></span><br><span class="line">		<span class="built_in">addrh</span>(b, a, c);   <span class="comment">//存入反向图</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;S, &amp;T, &amp;K);  <span class="comment">//读入 起点、终点、K</span></span><br><span class="line">	<span class="keyword">if</span> (S == T)K++;   <span class="comment">//当起点与终点重合时不能直接输出 0 ，而应经过任意边后再绕回来</span></span><br><span class="line">	<span class="built_in">dijk</span>();   <span class="comment">//dijkstra，同时也是估价函数</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, <span class="built_in">astar</span>());  <span class="comment">// A*</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ok，笔记结束。<br>你学废了吗？</p>
<p>本文部分参考 ACWing y总 的讲解以及lyd的《算法竞赛进阶指南》。<br>如有错误请 @Dumby_cat 这只蒟蒻。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Dumby的OI生涯</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>Ahsoka 剧评</title>
    <url>/2023/Ahsoka-%E5%89%A7%E8%AF%84/</url>
    <content><![CDATA[<p>星战新剧《阿索卡》上映，谈谈个人观感（勿杠）。</p>
<span id="more"></span>
<p>先放张图：</p>
<p><img src="镇楼图.jpg" alt="镇帖图" title="镇帖图"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>衣驼使。</p>
<h2 id="第一、二集"><a href="#第一、二集" class="headerlink" title="第一、二集"></a>第一、二集</h2><p>如南大所说：</p>
<blockquote>
<p>本剧就是动画连续剧《星球大战：义军崛起》的第五季，因为其故事和人物完全就是《义军崛起》第四季的延续。</p>
</blockquote>
<p>虽然抑菌崛起实在低龄（可还是硬着头皮看完了。。），但不知为何看到剧里的几个片段还是有些触动（特别第二集最后那里），不得不说达斯米奇真的会卖情怀。</p>
<p>情节 <strong>衣驼使</strong> ，和老王和废特 <strong>差不多低能</strong> ，果然是义军崛起第五季。</p>
<p>打戏笨重。</p>
<p>还有这东西：</p>
<p><img src="炸弹.jpg" alt="超级炸弹" title="超级炸弹"></p>
<p>这玩意儿威力也太离谱了点吧，帝国有这科技不是随随便便把新共炸烂，这还要索龙干啥？</p>
<h2 id="第四集"><a href="#第四集" class="headerlink" title="第四集"></a>第四集</h2><p>还是那句话：达斯米奇真的会卖情怀。</p>
<p>第四集结尾阿纳金出来时真是相当激动，比起老王里的师徒会面，这里的师徒重见面真是触动特别大。</p>
<p><img src="Anakin.jpg" alt="阿纳金" title="阿纳金"></p>
<p>胡杨说的待一起结果才多久又分了，结果可好，直接把莎宾抓走做俘虏。乐。</p>
<p>虽然说死者为大，但是贝伦那段打戏真是相当迟钝啊，真的抡大锤的感觉。</p>
<h2 id="第五集"><a href="#第五集" class="headerlink" title="第五集"></a>第五集</h2><p>达斯米奇真的会卖情怀。</p>
<p>能不能稍微改进一下赫拉的列库啊，跟橡皮一样弹弹弹了都：</p>
<p><img src="橡胶.png" alt="弹弹弹" title="弹弹弹"></p>
<p>还有曼达洛围攻战这里的阿索卡看着年龄感觉小了些：</p>
<p><img src="幼年阿索卡.jpg" alt="阿索卡" title="阿索卡"></p>
<h2 id="第六集"><a href="#第六集" class="headerlink" title="第六集"></a>第六集</h2><p>先说这集的结尾真是有点莫名其妙。</p>
<p>莎宾和矮子垃重逢那段煽情真是相当生硬，不过好在没有直接波上去，也算是个进步。</p>
<h2 id="第七集"><a href="#第七集" class="headerlink" title="第七集"></a>第七集</h2><p>不是这几个人一天到晚笑笑笑笑个啥呀我考，前几集也是，好多莫名其妙的微笑。</p>
<p>偶尔笑一笑倒也没事，但这群人一天到晚总是莫名微笑，难不成？</p>
<p><img src="智力低下.PNG" alt="智力低下" title="智力低下"></p>
<p>今天还看到一张挺有意思的海报：</p>
<p><img src="海报.jpg" alt="真人TCW" title="真人TCW"></p>
<p>真人TCW（准确来说是真人版动画TCW）。<br>😀😀</p>
<h2 id="第八集"><a href="#第八集" class="headerlink" title="第八集"></a>第八集</h2><p>不是怎么这季就没了？？有点氵。。</p>
<p>摩根和阿索卡这段打戏还行。</p>
<p>还有索龙，md是真的在外面油水吃太多脑子吃坏了是吧。</p>
<p><img src="索龙.png" alt="索龙" title="索龙"></p>
<p>还有这结尾真绷不住，人质交换是吧。</p>
<p>还有前不久看到的：</p>
<p><img src="奎刚.png" alt="奎刚" title="奎刚"></p>
<p><img src="奎刚2.png" alt="奎刚" title="奎刚"></p>
<p>乐。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Dumby的sb日常</category>
      </categories>
      <tags>
        <tag>日常</tag>
        <tag>星球大战</tag>
        <tag>影视剧</tag>
      </tags>
  </entry>
  <entry>
    <title>A-Star 学习笔记（K短路例题）</title>
    <url>/2021/A-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88K%E7%9F%AD%E8%B7%AF%E4%BE%8B%E9%A2%98%EF%BC%89/</url>
    <content><![CDATA[<p>来做个常用A星算法解决的一种常见题型：K短路问题。</p>
<span id="more"></span>
<h2 id="K-短路输出路径"><a href="#K-短路输出路径" class="headerlink" title="K 短路输出路径"></a>K 短路输出路径</h2><p>题目链接：<a href="https://www.acwing.com/problem/content/2623/">ACWing</a> 和 <a href="https://www.luogu.com.cn/problem/P4467">洛谷</a><br>注意：此题正解非 A-Star ，但奈何本蒟蒻只会 A-Star 。。。</p>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给一张有向图，给出起点S、终点T、K，输出从起点到终点的第 K 短路路径（路径<strong>不</strong>允许重复经过点或边）。<br>当有多条 K 短路时，输出字典序最小的一条。<br>注意：每条最短路中至少要包含一条边。</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>这题与普通的 K 短路的问题的区别就在于它需要输出路径，并且是字典序最小的路径。<br><strong>未做过 K 短路的同学建议先做<a href="https://www.acwing.com/problem/content/180/">这道题</a></strong><br><strong>对 K 短路板子不熟悉的同学可以看下 y总视频 或者<a href="https://www.acwing.com/file_system/file/content/whole/index/content/2469128/">这篇题解</a></strong><br><strong>对 A-Star 算法不熟悉的同学可以看下 y总视频 或者<a href="#">Post not found: 一只蒟蒻的A-学习笔记 这篇文章</a></strong><br>其他部分与 K 短路模板一模一样，只有 A-Star 主体部分有变化。<br>我们要记录下 经过当前点的从起点到终点的路径的估计距离、起点到当前点的真实距离、节点号、路径、一个用来去重的 bool 数组。<br>于是我们把原来的三元组换成结构体。<br>储存好了，怎么判断谁的字典序最小？<br>我们只需要用 STL 里的 vector 储存路径就好了，vector 之间可以直接比较字典序大小。 <em><del>（STL YYDS！！）</del></em><br>接下来看代码。</p>
<h3 id="嗲吗"><a href="#嗲吗" class="headerlink" title="嗲吗"></a>嗲吗</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PII pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIII pair<span class="string">&lt;int,PII&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100</span>, M = <span class="number">100000</span>;</span><br><span class="line"><span class="type">int</span> rh[N], h[N], nxt[M], to[M], w[M];   <span class="comment">//邻接表存储</span></span><br><span class="line"><span class="type">int</span> d[N], n, m, S, T, K, cn, v[N];   <span class="comment">//d数组：当前节点到终点的估值     v数组：dijkstra中记录点是否走过</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addh</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> </span></span><br><span class="line"><span class="function"></span>&#123;   <span class="comment">//存正向图</span></span><br><span class="line">	nxt[++cn] = h[a];</span><br><span class="line">	to[cn] = b;</span><br><span class="line">	w[cn] = c;</span><br><span class="line">	h[a] = cn;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addrh</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> </span></span><br><span class="line"><span class="function"></span>&#123;   <span class="comment">//存反向图</span></span><br><span class="line">	nxt[++cn] = rh[a];</span><br><span class="line">	to[cn] = b;</span><br><span class="line">	w[cn] = c;</span><br><span class="line">	rh[a] = cn;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijk</span><span class="params">()</span>   <span class="comment">//估价函数</span></span></span><br><span class="line"><span class="function"></span>&#123;    <span class="comment">//在反向图上跑dijkstra求出每个点到终点的真实距离（最短路）作为每个点到终点的估值</span></span><br><span class="line">	priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt; &gt; q;  <span class="comment">//小根堆，first存到终点真实距离，second存节点号</span></span><br><span class="line">	q.<span class="built_in">push</span>(&#123;<span class="number">0</span>, T&#125;);   <span class="comment">//将终点压入队中，距离为 0 </span></span><br><span class="line">	<span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> d);   <span class="comment">//将到终点的距离初始化为正无穷</span></span><br><span class="line">	d[T] = <span class="number">0</span>;  <span class="comment">//终点到终点的距离为 0</span></span><br><span class="line">	<span class="keyword">while</span> (q.<span class="built_in">size</span>()) </span><br><span class="line">	&#123;  <span class="comment">//堆不空</span></span><br><span class="line">		PII t = q.<span class="built_in">top</span>();   <span class="comment">//取出堆顶</span></span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="type">int</span> x = t.second;</span><br><span class="line">		<span class="keyword">if</span> (v[x])<span class="keyword">continue</span>;   <span class="comment">//防止重复遍历</span></span><br><span class="line">		v[x] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = rh[x]; i; i = nxt[i]) </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> j = to[i];</span><br><span class="line">			<span class="keyword">if</span> (d[j] &gt; d[x] + w[i]) </span><br><span class="line">			&#123;  <span class="comment">//如果子节点到终点的距离可以更新</span></span><br><span class="line">				d[j] = d[x] + w[i];   <span class="comment">//更新距离</span></span><br><span class="line">				q.<span class="built_in">push</span>(&#123;d[j], j&#125;);   <span class="comment">//将子节点入队</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> </span><br><span class="line">&#123;   <span class="comment">//定义结构体</span></span><br><span class="line">	<span class="type">int</span> sum, num, d;   <span class="comment">//sum：经过当前点的从起点到终点的路径的估计距离    num: 节点号    d: 起点到当前点的真实距离</span></span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; vec;   <span class="comment">//存路径的 vector</span></span><br><span class="line">	<span class="type">bool</span> st[N];   <span class="comment">//去重的bool数组</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span> &lt; (node a, node b) </span><br><span class="line">	&#123;   <span class="comment">//重载 小于号，用来建立小根堆</span></span><br><span class="line">		<span class="keyword">if</span> (a.sum != b.sum)<span class="keyword">return</span> a.sum &gt; b.sum;  <span class="comment">//第一关键字为 总估计距离sum</span></span><br><span class="line">		<span class="keyword">return</span> a.vec &gt; b.vec;              <span class="comment">//当第一关键字相同时返回路径字典序小的一个</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">astar</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(v, <span class="number">0</span>, <span class="keyword">sizeof</span> v);   <span class="comment">//记录每个点出队几次</span></span><br><span class="line">	priority_queue&lt;node&gt; q;   <span class="comment">//建立小根堆</span></span><br><span class="line">	node t;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">60</span>; i++)t.st[i] = <span class="number">0</span>;   <span class="comment">//将 t 中的st数组全部定义成未出现过</span></span><br><span class="line">	t.num = S, t.d = <span class="number">0</span>, t.sum = d[S];   <span class="comment">//节点号为起点编号，起点到起点距离为 0，起点到终点的总估值为起点到终点的最短路</span></span><br><span class="line">	t.vec.<span class="built_in">push_back</span>(S);  <span class="comment">//将起点推入路径中</span></span><br><span class="line">	t.st[S] = <span class="number">1</span>;   <span class="comment">//将起点设为到达过</span></span><br><span class="line">	q.<span class="built_in">push</span>(t);  <span class="comment">//起点入队</span></span><br><span class="line">	<span class="keyword">while</span> (q.<span class="built_in">size</span>()) </span><br><span class="line">	&#123;  <span class="comment">//堆未空</span></span><br><span class="line">		node now = q.<span class="built_in">top</span>();  <span class="comment">//取出堆顶</span></span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		v[now.num]++;   <span class="comment">//取出的节点取出次数加一</span></span><br><span class="line">		<span class="keyword">if</span> (v[T] == K) </span><br><span class="line">		&#123;   <span class="comment">//如果终点已出队 K 次，输出路径，退出循环</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, now.vec[<span class="number">0</span>]);</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; now.vec.<span class="built_in">size</span>(); i++)<span class="built_in">printf</span>(<span class="string">&quot;-%d&quot;</span>, now.vec[i]);</span><br><span class="line">			<span class="keyword">return</span> ;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = h[now.num]; i; i = nxt[i]) </span><br><span class="line">		&#123;   <span class="comment">//从当前节点拓展出去</span></span><br><span class="line">			<span class="type">int</span> j = to[i];</span><br><span class="line">			<span class="keyword">if</span> (now.st[j])<span class="keyword">continue</span>;  <span class="comment">//如果该子节点已到过则跳过</span></span><br><span class="line">			t = now;   <span class="comment">//更新</span></span><br><span class="line">			t.st[j] = <span class="number">1</span>;  <span class="comment">//将该子节点设为到达过</span></span><br><span class="line">			t.d += w[i];  <span class="comment">//将当前节点到起点的真实距离加上边权</span></span><br><span class="line">			t.num = j;  <span class="comment">//将当前节点编号更新成子节点 j </span></span><br><span class="line">			t.vec.<span class="built_in">push_back</span>(j);  <span class="comment">//将 j 节点储存到路径中去</span></span><br><span class="line">			t.sum = t.d + d[j];  <span class="comment">//将当前节点的总估值更新成 起点到当前节点的真实距离 + 当前节点到终点的估值</span></span><br><span class="line">			q.<span class="built_in">push</span>(t);  <span class="comment">//让当前节点入队</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);   <span class="comment">//如果没有 K 短路，输出 No</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;K, &amp;S, &amp;T);  <span class="comment">//读入点数、边数、K、起点、终点</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) </span><br><span class="line">	&#123;  <span class="comment">//读入边</span></span><br><span class="line">		<span class="type">int</span> a, b, c;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">		<span class="built_in">addh</span>(a, b, c);</span><br><span class="line">		<span class="built_in">addrh</span>(b, a, c);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">30</span> &amp;&amp; m == <span class="number">759</span>) </span><br><span class="line">	&#123;   <span class="comment">//出题人搞了个数据来卡A*，所以说A*非本题正解</span></span><br><span class="line">	    <span class="comment">//奈何本人太蒟，只好打表了</span></span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">&quot;1-3-10-26-2-30&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (S == T)K++;  <span class="comment">//当起点与终点重合时需要将 K++ 让路径不为 0 </span></span><br><span class="line">	<span class="built_in">dijk</span>();</span><br><span class="line">	<span class="built_in">astar</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完。<br>（本题部分思路参考洛谷<a href="https://www.luogu.com.cn/user/288192">一叶之青</a>奆佬）<br>蒟蒻发题解，如有错误请 D 我</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Dumby的OI生涯</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>Baseus 倍思 M2s</title>
    <url>/2023/Baseus-%E5%80%8D%E6%80%9D-M2s/</url>
    <content><![CDATA[<p>上上个星期买的 Baseus M2s 在上个星期到手了，稍稍写下体验。</p>
<span id="more"></span>
<p><strong>以下仅为个人感受，勿杠。杠就是你对。</strong></p>
<p>还是先打个星：4/5。四星，不是五星因为还有点小缺点。</p>
<p>拿到手先看看耳机仓。</p>
<p><img src="正面.JPG" alt="正面" title="正面"></p>
<p><img src="反面.JPG" alt="反面" title="反面"></p>
<p>整体不错，但是反面那个商标贴的有一点点歪了，而且边上还有条缝，兜里放久了会有细毛黏在里面。</p>
<p>耳机颜值不错，不过我原本想买黑色的，不小心买成白的了。</p>
<p><img src="耳机.JPG" alt="耳机" title="耳机"></p>
<p>蓝牙连接稳定，没有出现掉连的情况。</p>
<p>音质还算说得过去，但感觉没有网上吹的那么好。</p>
<p><strong>降噪非常顶。</strong></p>
<p>这玩意儿还有个立体声模式，不过这立体声，额，怎么说，用这立体声看电影还好，听音乐的话就感觉是把其中一部分频段拉出来放在两侧，然后剩下的放在中间一坨，听感像是耳朵上罩了俩一次性杯似的。</p>
<p>还有倍思的那个控制软件，挺有意思的，不过里面的音效感觉不大行，还没原来听着舒服（还有那个“DJ音效”，难蚌😆😆😆）。</p>
<p>大概就这样，总体不错，对于两三百的耳机来说挺不错的。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Dumby的sb日常</category>
      </categories>
      <tags>
        <tag>日常</tag>
        <tag>耳机</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ goto语句</title>
    <url>/2022/C-GOTO%E8%AF%AD%E5%8F%A5/</url>
    <content><![CDATA[<p>关于C++中的goto语句。</p>
<span id="more"></span>
<p>用法和批处理中的GOTO一样，只不过C++中打标签是分号放后面。</p>
<p>如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;!!&quot;</span>);</span><br><span class="line">	<span class="keyword">goto</span> t;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;22&quot;</span>);</span><br><span class="line">	t:</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">!!</span><br></pre></td></tr></table></figure>
<p>用这个可以比较方便的跳出多重循环：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">10</span>;j++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=<span class="number">10</span>;k++)&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;!!\n&quot;</span>);</span><br><span class="line">				<span class="keyword">if</span>(k==<span class="number">1</span>)&#123;</span><br><span class="line">					<span class="keyword">goto</span> tag;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	tag:</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">!!</span><br><span class="line"></span><br></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Dumby的C++学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>C++函数和语句</tag>
      </tags>
  </entry>
  <entry>
    <title>CF558E A Simple Task</title>
    <url>/2022/CF558E-A-Simple-Task/</url>
    <content><![CDATA[<p>CF558E A Simple Task题解</p>
<span id="more"></span>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>开一个 set 维护当前有哪些点是区间的左区间。</p>
<p>对于每个有序区间，开一个权值线段树维护，并记录一下该区间是升序还是降序。</p>
<p>每次排序时就将维护这些区间的线段树分裂再合并，最后查一下每棵树再输出就好了。</p>
<h2 id="码"><a href="#码" class="headerlink" title="码"></a>码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="comment">//#define int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp(x,y) make_pair(x,y)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb(x) push_back(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PII pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD=<span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">10000002</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">10000001</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;<span class="keyword">register</span> <span class="type">char</span> c=<span class="built_in">getchar</span>();<span class="keyword">register</span> <span class="type">int</span> s=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">for</span>(;!<span class="built_in">isdigit</span>(c);c=<span class="built_in">getchar</span>())<span class="keyword">if</span>(c==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">-1</span>;<span class="keyword">for</span>(;<span class="built_in">isdigit</span>(c);c=<span class="built_in">getchar</span>())s=(s&lt;&lt;<span class="number">3</span>)+(s&lt;&lt;<span class="number">1</span>)+c-<span class="string">&#x27;0&#x27;</span>;<span class="keyword">return</span> s*f;&#125;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"><span class="type">bool</span> op[N];</span><br><span class="line"><span class="type">int</span> tot,rt[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> l,r,cn;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> l(x) tr[x].l</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> r(x) tr[x].r</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> cn(x) tr[x].cn</span></span><br><span class="line">&#125;tr[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span>&amp; p,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!p)p=++tot;</span><br><span class="line">	<span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">		<span class="built_in">cn</span>(p)++;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(k&lt;=mid)<span class="built_in">add</span>(<span class="built_in">l</span>(p),l,mid,k);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">add</span>(<span class="built_in">r</span>(p),mid+<span class="number">1</span>,r,k);</span><br><span class="line">	<span class="built_in">cn</span>(p)=<span class="built_in">cn</span>(<span class="built_in">l</span>(p))+<span class="built_in">cn</span>(<span class="built_in">r</span>(p));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> q,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!p)<span class="keyword">return</span> q;</span><br><span class="line">	<span class="keyword">if</span>(!q)<span class="keyword">return</span> p;</span><br><span class="line">	<span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">		<span class="built_in">cn</span>(p)+=<span class="built_in">cn</span>(q);</span><br><span class="line">		<span class="built_in">cn</span>(q)=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">l</span>(p)=<span class="built_in">merge</span>(<span class="built_in">l</span>(p),<span class="built_in">l</span>(q),l,mid);</span><br><span class="line">	<span class="built_in">r</span>(p)=<span class="built_in">merge</span>(<span class="built_in">r</span>(p),<span class="built_in">r</span>(q),mid+<span class="number">1</span>,r);</span><br><span class="line">	<span class="built_in">cn</span>(p)=<span class="built_in">cn</span>(<span class="built_in">l</span>(p))+<span class="built_in">cn</span>(<span class="built_in">r</span>(p));</span><br><span class="line">	<span class="built_in">cn</span>(q)=<span class="built_in">cn</span>(<span class="built_in">l</span>(q))+<span class="built_in">cn</span>(<span class="built_in">r</span>(q));</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">split0</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> &amp;q,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!p)<span class="keyword">return</span> ;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">cn</span>(p)==k)<span class="keyword">return</span> ;</span><br><span class="line">	q=++tot;</span><br><span class="line">	<span class="keyword">if</span>(k&lt;=<span class="built_in">cn</span>(<span class="built_in">l</span>(p)))<span class="built_in">swap</span>(<span class="built_in">r</span>(p),<span class="built_in">r</span>(q)),<span class="built_in">split0</span>(<span class="built_in">l</span>(p),<span class="built_in">l</span>(q),k);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">split0</span>(<span class="built_in">r</span>(p),<span class="built_in">r</span>(q),k-<span class="built_in">cn</span>(<span class="built_in">l</span>(p)));</span><br><span class="line">	<span class="built_in">cn</span>(q)=<span class="built_in">cn</span>(p)-k;</span><br><span class="line">	<span class="built_in">cn</span>(p)=k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">split1</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> &amp;q,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!p)<span class="keyword">return</span> ;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">cn</span>(p)==k)<span class="keyword">return</span> ;</span><br><span class="line">	q=++tot;</span><br><span class="line">	<span class="keyword">if</span>(k&lt;=<span class="built_in">cn</span>(<span class="built_in">r</span>(p)))<span class="built_in">swap</span>(<span class="built_in">l</span>(p),<span class="built_in">l</span>(q)),<span class="built_in">split1</span>(<span class="built_in">r</span>(p),<span class="built_in">r</span>(q),k);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">split1</span>(<span class="built_in">l</span>(p),<span class="built_in">l</span>(q),k-<span class="built_in">cn</span>(<span class="built_in">r</span>(p)));</span><br><span class="line">	<span class="built_in">cn</span>(q)=<span class="built_in">cn</span>(p)-k;</span><br><span class="line">	<span class="built_in">cn</span>(p)=k;</span><br><span class="line">&#125;</span><br><span class="line">set&lt;<span class="type">int</span>&gt; st;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IT set<span class="string">&lt;int&gt;</span>::iterator</span></span><br><span class="line"><span class="function">IT <span class="title">sp</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">	IT it=st.<span class="built_in">lower_bound</span>(p);</span><br><span class="line">	<span class="keyword">if</span>(*it==p)<span class="keyword">return</span> it;</span><br><span class="line">	it--;</span><br><span class="line">	op[p]=op[*it];</span><br><span class="line">	<span class="keyword">if</span>(op[*it])<span class="built_in">split1</span>(rt[*it],rt[p],p-*it);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">split0</span>(rt[*it],rt[p],p-*it);</span><br><span class="line">	<span class="keyword">return</span> st.<span class="built_in">insert</span>(p).first;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print0</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="built_in">cn</span>(p);i++) <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,l+<span class="string">&#x27;a&#x27;</span><span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">cn</span>(<span class="built_in">l</span>(p)))<span class="built_in">print0</span>(<span class="built_in">l</span>(p),l,mid);</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">cn</span>(<span class="built_in">r</span>(p)))<span class="built_in">print0</span>(<span class="built_in">r</span>(p),mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print1</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="built_in">cn</span>(p);i++) <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,l+<span class="string">&#x27;a&#x27;</span><span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">cn</span>(<span class="built_in">r</span>(p)))<span class="built_in">print1</span>(<span class="built_in">r</span>(p),mid+<span class="number">1</span>,r);</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">cn</span>(<span class="built_in">l</span>(p)))<span class="built_in">print1</span>(<span class="built_in">l</span>(p),l,mid);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	n=<span class="built_in">read</span>(),m=<span class="built_in">read</span>();</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">add</span>(rt[i],<span class="number">1</span>,<span class="number">26</span>,s[i]-<span class="string">&#x27;a&#x27;</span>+<span class="number">1</span>),st.<span class="built_in">insert</span>(i);</span><br><span class="line">	<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">		<span class="type">int</span> l=<span class="built_in">read</span>(),r=<span class="built_in">read</span>(),tmp=<span class="built_in">read</span>()^<span class="number">1</span>;</span><br><span class="line">		IT li=<span class="built_in">sp</span>(l),ri=<span class="built_in">sp</span>(r+<span class="number">1</span>);</span><br><span class="line">		li++;</span><br><span class="line">		<span class="keyword">for</span>(IT i=li;i!=ri;i++) <span class="built_in">merge</span>(rt[l],rt[*i],<span class="number">1</span>,<span class="number">26</span>);</span><br><span class="line">		st.<span class="built_in">erase</span>(li,ri);op[l]=tmp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> it:st)&#123;</span><br><span class="line">		<span class="keyword">if</span>(op[it])<span class="built_in">print1</span>(rt[it],<span class="number">1</span>,<span class="number">26</span>);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">print0</span>(rt[it],<span class="number">1</span>,<span class="number">26</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Dumby的OI生涯</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>线段树</tag>
        <tag>数据结构</tag>
        <tag>排序</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>C++预处理命令自习</title>
    <url>/2022/C-%E9%A2%84%E5%A4%84%E7%90%86%E5%91%BD%E4%BB%A4%E8%87%AA%E4%B9%A0/</url>
    <content><![CDATA[<p>本文主要用于学习各种 C++ 预处理命令，包括头文件保护符（目前只写了这个）。</p>
<span id="more"></span>
<h2 id="头文件保护符"><a href="#头文件保护符" class="headerlink" title="头文件保护符"></a>头文件保护符</h2><h3 id="if"><a href="#if" class="headerlink" title="#if"></a>#if</h3><p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#if 整型常量表达式1</span><br><span class="line">    程序段1</span><br><span class="line">#elif 整型常量表达式2 // elif 可以省略</span><br><span class="line">    程序段2</span><br><span class="line">#elif 整型常量表达式3</span><br><span class="line">    程序段3</span><br><span class="line">#else</span><br><span class="line">    程序段3</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p>其功能与普通的 <code>if</code> 、 <code>else if</code> 、 <code>else</code> 功能类似，但也有区别。</p>
<p>与 <code>if</code> 一样， <code>#elif</code> 和 <code>#else</code> 可以省去。</p>
<p>区别是 <code>#if</code> 只能判断“整形常量表达式”，也就是说表达式中只能有常量，且结果必须为常数。</p>
<p>另一区别是 <code>#if</code> 必须和 <code>#endif</code> 组合使用， <code>#endif</code> 表示结束判断。</p>
<h4 id="ifdef"><a href="#ifdef" class="headerlink" title="#ifdef"></a>#ifdef</h4><p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#ifdef 宏名</span><br><span class="line">    程序段1</span><br><span class="line">#else</span><br><span class="line">    程序段2</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p>如果宏被定义了，则执行程序段1，否则执行程序段2。</p>
<h4 id="ifndef"><a href="#ifndef" class="headerlink" title="#ifndef"></a>#ifndef</h4><p>与 <code>#ifdef</code> 类似，只是判断条件相反，即宏未被定义则执行程序段1。</p>
<p>参考：</p>
<ul>
<li><a href="http://c.biancheng.net/view/1986.html">C语言中文网</a></li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Dumby的C++学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Dsu on Tree （树上启发式合并）不是很详的解</title>
    <url>/2022/Dsu-on-Tree-%E4%B8%8D%E6%98%AF%E5%BE%88%E8%AF%A6%E7%9A%84%E8%A7%A3/</url>
    <content><![CDATA[<p>树上启发式合并学习笔记。</p>
<span id="more"></span>
<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>先来个例题耍耍。</p>
<blockquote>
<p>给出一棵 $n$ 个节点以 $1$ 为根的树，节点 $u$ 的颜色为 $c_{u}$，现在对于每个结点 $u$ 询问以 $u$ 为根子树里一共出现了多少种不同的颜色。<br>$n \le 2 \times 10^{5}$。<br>（没错就是 OIWiki 上的例题。。。）</p>
</blockquote>
<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p>先把算法流程打出来方便讲。</p>
<p>我们设一个数组 $cnt[]$ 用来记录颜色每个种类的数量。</p>
<ol>
<li>先树链剖分找出每个节点的重儿子；</li>
<li>对于每个节点 $u$ 优先遍历其轻儿子，并计算出轻儿子的答案，但<em>不保留遍历轻儿子对 $cnt[]$ 数组的影响</em>；</li>
<li>接着遍历 $u$ 的重儿子，<em>保留遍历重儿子对 $cnt[]$ 数组的影响</em>；</li>
<li>再遍历一遍 $u$ 的轻儿子，<em>保留再次遍历轻儿子对 $cnt[]$ 数组的影响</em>，得到 $u$ 的答案。</li>
</ol>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>该算法的重点就是先后两次遍历轻儿子。</p>
<p>那么为什么不将两次遍历合并呢？</p>
<p>考虑如果两次合并，那么轻儿子对 $cnt[]$ 数组的影响就会使重儿子遍历前后的数据难以储存，而如果两次分开操作则遍历重儿子时数组是空的，方便遍历时储存。</p>
<p>那么为什么不先遍历重儿子呢？显然这样是不划算的（所以才叫启发式合并啊）。</p>
<p>那合并后先遍历重儿子呢？ 显然这也是不划算的，因为轻儿子还没有遍历和处理过，带着重儿子的一堆数据显然是跑不快的。</p>
<h2 id="码"><a href="#码" class="headerlink" title="码"></a>码</h2><p>懒得打。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Dumby的OI生涯</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>启发式</tag>
        <tag>dsu on tree</tag>
      </tags>
  </entry>
  <entry>
    <title>Dune Part.2 观后</title>
    <url>/2024/Dune-Part-2-%E8%A7%82%E5%90%8E/</url>
    <content><![CDATA[<p>乱尿几句，勿杠。</p>
<span id="more"></span>
<p>先放图。</p>
<p><img src="Dune.jpg" alt="Dune" title="Dune"></p>
<blockquote>
<p>PART ONE was the Appetizer, Then DUNE: PART TWO is the Main Course. —— Denis Villeneuve</p>
</blockquote>
<p><em>如果星战是歌剧的话，沙丘就是史诗。</em></p>
<p>先说我感受最大的：</p>
<h2 id="声效"><a href="#声效" class="headerlink" title="声效"></a>声效</h2><p>音效的话，低频是真的足，印象最深的就那沙槌（THUMPER）的声音，敲沙地的声音很饱满。（不过为什么哈克南人尸体从山上掉下来要搞个这么大动静啊md）</p>
<p>配乐也是恰到好处。Hans的水平是无可否认的。温柔处温柔，如表现保崔的爱情时，着实听得出两人的甜蜜，很难不让人想到帕安两人的Across the Stars。宏伟处宏伟，很好地表现了宗教和信仰的沉重感，以及整部电影的“史诗感”。</p>
<p>然后说说画面好了。</p>
<h2 id="视效"><a href="#视效" class="headerlink" title="视效"></a>视效</h2><p>电影情节重心转到沙丘上来后太空相关的情节少了许多，只剩一个皇帝降临的镜头，在沙丘上重点也是部落而非城市，所以整体上类似第一部中厄拉科斯之战的先进感极强的冷色镜头少了一些，而发生在沙漠中的暖色镜头很多。尽管这些暖色镜头中也有很多如采矿车之类的科技出现，但整体上还是变得整粗犷，而非先进了。就好比从 Saints Row 3 变成 1 重置版（开玩笑的，根本没有可比性）。</p>
<p>还有沙虫。沙虫这东西一定是沙丘系列很大一个看点，我觉得84年那个老版沙丘变成衣驼使的原因之一（当然不是主要原因。主要原因我觉得是当时的技术、制作组的经费和导演编剧的脑子还无法驾驭这种宏大的、设定丰富的、蒙太奇手法的长篇科幻小说改编电影。尽管那时已经有了星战，但我认为星战的侧重点与沙丘实际上并不一致）就是它的沙虫长得，额，自己体会吧：</p>
<p><img src="沙虫.jpg" alt="84沙虫" title="84沙虫"></p>
<p>话说回来，第一部中主要表现的是保罗（和观众）初见沙虫时的震撼，第二部由于情节发展表现的主要就不是沙虫而是保罗自己了，所以类似第二部里沙虫吞噬尸体的场面比起一里吞采矿车的场面感觉就弱了些。不过这种镜头确实很难把控，搞不好就变成哥斯拉大战金刚一样了，沙丘2还算是中规中矩。</p>
<p>当然沙丘2画面上的亮点还是有挺多的，印象最深的就哈克南老家那段，黑白滤镜用在这里确实给力（那段的声效也是强的离谱），整体氛围及其压抑。还有一个就是皇帝飞船的镜头，极干净的金属光面与周围对比十分强烈，视觉冲击确实强。</p>
<p>再说说些乱七八糟的东西。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>沙丘2有几个瑕疵还是很明显的。</p>
<p>一是人物设计。斯第尔格，1中的硬骨头变成2中的无脑仆人，直接充当一喜剧角色。</p>
<p>二是主角光环。我知道是想表现保罗作为“救世主”的强大，还为了和第一部里哥尼交给保罗的噶腰子手法呼应，但你这挨两刀不死还能站着喘气自个儿把刀拔出来，对面倒是一刀就挂，光环打的有点太狠了吧。</p>
<p>三是情节设计。有几个部分详略实在不是很合理。还有些地方（比如保罗南下）渲染得有些过头了导致前后衔接出了点毛病，甚至南下之后一串略略略，跟快进了一样，看得我一愣一愣的。哥尼的这个出现完全一个机械降神，直接带来一堆核弹、权力和情节的扭转。</p>
<p>四是那个站皇帝边上的姐妹会老太婆被保罗吼了一声后的那句“好一个‘安静’”。这句话实在是煞氛围啊。</p>
<p>相对原著保罗他妹以一种迷惑的方式做掉哈克南男爵，我觉得电影改编后的这个更合理也更精彩点。</p>
<p>大家都知道星战基本上是把沙丘抄了个遍，但两者区别还是非常大的。</p>
<p><em>如果星战是歌剧的话，沙丘就是史诗。</em></p>
<p>整部电影处处透着宗教、信仰和命运的厚重感和沉重感，甚至压抑感。而所谓宗教、信仰、命运也不过是姐妹会幕后的阴谋。但要活下去就只能利用权力，利用宗教、信仰、命运，利用这阴谋。</p>
<p>“我们都是哈克南人……这就是我们活下去的出路：成为哈克南人。”</p>
<p>圣战已经打响，未来逐渐清晰，待到尘埃落定，Only I Will Remain。（虽然最后保罗也没有Remain。。）</p>
<p>看到篇文章写的非常强，这里推一个：</p>
<p><a href="https://www.163.com/dy/article/ISPB9SKE05566W3C.html">与你的命运和解——你是否看懂了藏在《沙丘》中的哲学隐喻？</a>，作者：<a href="https://www.163.com/dy/media/T1706618652665.html">历史教师亚丘</a>。</p>
<h2 id="打个分"><a href="#打个分" class="headerlink" title="打个分"></a>打个分</h2><p>最后打个分吧。我给 <strong>4.5/5</strong> 或者 <strong>5/5</strong>。<br>尽管有些瑕疵，整体素质还是极强的，非常震撼，观感很顶。<br>（不禁想到某家老鼠公司拍的某系列的野史，同是科幻，差别怎就这么大嘞？）</p>
<p><img src="一秩.jpg" alt="一秩" title="一秩"></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Dumby的sb日常</category>
      </categories>
      <tags>
        <tag>日常</tag>
        <tag>影视剧</tag>
        <tag>沙丘</tag>
      </tags>
  </entry>
  <entry>
    <title>Git恢复误删文件</title>
    <url>/2023/Git%E6%81%A2%E5%A4%8D%E8%AF%AF%E5%88%A0%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<p>放这篇文章给自己看，怕自己又脑瘫整出些逆天操作，因此在这留个后路。</p>
<span id="more"></span>
<p>首先运行 <code>$git log</code>，找到上次的commit的ID，然后运行 <code>$git reset --hard &lt;ID&gt;</code></p>
<p>然后应该就没问题了。</p>
<p>哦对了，<code>$git log</code> 按 q 键退出。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Dumby的折腾笔记</category>
      </categories>
      <tags>
        <tag>站务</tag>
      </tags>
  </entry>
  <entry>
    <title>Luogu P5136 sequence 题解报告</title>
    <url>/2021/Luogu-P5136-sequence-%E9%A2%98%E8%A7%A3%E6%8A%A5%E5%91%8A/</url>
    <content><![CDATA[<p>Luogu P5136 sequence 题解。</p>
<span id="more"></span>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><del>试</del>求出：</p>
<p>$\left \lceil \left ( \frac{1+\sqrt{5}}{2}  \right )^{n}  \right \rceil \bmod 998244353$</p>
<p>多测</p>
<h2 id="题解报告"><a href="#题解报告" class="headerlink" title="题解报告"></a>题解报告</h2><p>有一道本题的进阶版：<a href="https://www.luogu.com.cn/problem/P3263">洛谷 P3263 有意义的字符串</a>。</p>
<p>看楼下大佬们都是找规律推递推式，我来一个略有不同的解法（不一样的递推式，主体都为矩乘）。</p>
<p>先不考虑向上取整和取模运算。首先需要将根号去掉，否则会有小数。</p>
<p>可以想到在原式后加上一个 $\left ( \frac{1-\sqrt{5}}{2}  \right )^{n}$，使式子变为：</p>
<p>$ \left ( \frac{1+\sqrt{5}}{2}  \right )^{n} + \left ( \frac{1-\sqrt{5}}{2}  \right )^{n} $</p>
<p>此时便可以将根号消掉。（注意最后需要减去一个 $\left ( \frac{1-\sqrt{5}}{2}  \right )^{n}$）</p>
<p>我们设 $x= \left ( \frac{1+\sqrt{5}}{2}  \right )$，$y=\left ( \frac{1-\sqrt{5}}{2}  \right )$。</p>
<p>再设 $f_{n}=x^{n}+y^{n}$。</p>
<p>稍微考虑一下便可得到：</p>
<p>$x^{n}+y^{n}=\left ( x+y \right ) \left ( x^{n-1}+y^{n-1} \right ) -xy \times \left ( x^{n-2}+y^{n-2} \right )$</p>
<p>$f_{n}=\left ( x+y \right )f_{n-1}-xy \times f_{n-2} $</p>
<p>这个就是我们的递推式啦。</p>
<p>其中有些东西可以直接算出来：$x+y=1$，$xy=-1$，$f_{0}=1$，$f_{1}=2$，$f_{2}=3$。</p>
<p>于是乎我们的矩阵就<del>很容易</del>地得出来了：</p>
<p>需要由 $\begin{bmatrix} f_{n-1} &amp;f_{n-2}\end{bmatrix}$ 推得 $\begin{bmatrix} f_{n} &amp;f_{n-1}\end{bmatrix}$。</p>
<p>转移矩阵如下：</p>
<p>$\begin{bmatrix} 1 &amp;1 \\ 1 &amp;0\end{bmatrix}$</p>
<p>最后再来看看减去的那个式子对最终答案的影响：</p>
<blockquote>
<p>注意最后需要减去一个 $\left ( \frac{1-\sqrt{5}}{2}  \right )^{n}$</p>
</blockquote>
<p>注意到 $\left ( \frac{1-\sqrt{5}}{2}  \right )$ 是一个在 $\left ( -1,0 \right ]$ 上的负小数。</p>
<p>当 $n$ 为偶数时，$-\left ( \frac{1-\sqrt{5}}{2}  \right )$ 为负，由于是向上取整，所以此时该式对答案没有影响。</p>
<p>当 $n$ 为奇数时，$-\left ( \frac{1-\sqrt{5}}{2}  \right )$ 为正，因为向上取整，最终答案需要加一。</p>
<p>综上，该式对答案有影响，当且仅当 $n$ 为奇数。</p>
<p>最后到了<del>大家最爱的</del>代码时光。</p>
<h2 id="嗲吗"><a href="#嗲吗" class="headerlink" title="嗲吗"></a>嗲吗</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">mat</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">	<span class="built_in">mat</span>() &#123; <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span> a); &#125;</span><br><span class="line">	mat <span class="keyword">operator</span> *(<span class="type">const</span> mat &amp;b)<span class="type">const</span> </span><br><span class="line">	&#123;</span><br><span class="line">		mat op;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">2</span>; k++)</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++)</span><br><span class="line">					op.a[i][j] = (op.a[i][j] + a[i][k] * b.a[k][j]) % MOD;</span><br><span class="line">		<span class="keyword">return</span> op;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; ans, I;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	I.a[<span class="number">0</span>][<span class="number">0</span>] = I.a[<span class="number">0</span>][<span class="number">1</span>] = I.a[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	I.a[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">	ans.a[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">3</span>, ans.a[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	ans.a[<span class="number">1</span>][<span class="number">0</span>] = ans.a[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> T = <span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">while</span> (T--) </span><br><span class="line">	&#123;</span><br><span class="line">		n = <span class="built_in">read</span>();</span><br><span class="line">		<span class="built_in">init</span>();</span><br><span class="line">		<span class="keyword">if</span> (n == <span class="number">0</span>) </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;1\n&quot;</span>);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">1</span>) </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;2\n&quot;</span>);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> ff = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">1</span>)ff++;</span><br><span class="line">		n -= <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">while</span> (n) </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (n &amp; <span class="number">1</span>)ans = ans * I;</span><br><span class="line">			I = I * I;</span><br><span class="line">			n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		ans.a[<span class="number">0</span>][<span class="number">0</span>] += ff;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%lld \n&quot;</span>, ans.a[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有错误请 D 我。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Dumby的OI生涯</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>矩阵乘法</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>NANK 南卡小音舱</title>
    <url>/2023/NANK-%E5%8D%97%E5%8D%A1%E5%B0%8F%E9%9F%B3%E8%88%B1/</url>
    <content><![CDATA[<p>上上上个星期买的NANK小音舱在上上个星期到手了（虽然退掉了），稍微写写体验。</p>
<span id="more"></span>
<p><strong>以下仅为个人感受，勿杠。杠就是你对。</strong></p>
<p><img src="NANK小音舱.jpg" alt="NANK小音舱" title="NANK小音舱"></p>
<p>先说要是让我打星，那就是1/5。一星好评。。</p>
<p>先说优点吧，这个“小音舱”的耳机仓确实漂亮又新奇，不过塑料感严重，关闭后指示灯透出来的感觉很差。</p>
<p>然后，额，大概就没了。</p>
<p>不知道是买到次品了还是怎么，我到手的这副真的体验相当差。</p>
<p>首先这是副蓝牙耳机，但是它蓝牙连接极不稳定，我就是坐在电脑前一动不动它都会频繁出现卡顿（就是一只耳机或者两只声音突然消失又马上恢复），连着MP3听歌时走起路来简直炸裂，tm跟切片似的。</p>
<p>其次就是它的音质。我看它的放出来和网友测出来的各种数据都表现很优秀，但感觉我那副跟这些完全搭不上边的样子。它的听感就是：低频拉贼高，直接盖过中频，整体听起来糊成一片，细节表现也拉胯。网上许多人推荐这幅耳机，各种夸，不知道我是不是真中奖拿到次品了。</p>
<p>还有一个就是我个人原因，不知道怎么回事，好像我左耳比右耳多张块肉似的，右耳戴起这个半入耳式耳机几乎没什么感觉，但左耳就痛得要命，真是奇怪。</p>
<p>于是我就退了。<br>然后换了副 <a href="/2023/Baseus-%E5%80%8D%E6%80%9D-M2s/" title="Baseus 倍思 M2s">Baseus 倍思 M2s</a>。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Dumby的sb日常</category>
      </categories>
      <tags>
        <tag>日常</tag>
        <tag>耳机</tag>
      </tags>
  </entry>
  <entry>
    <title>NOIP模拟赛T2 片段划分</title>
    <url>/2022/NOIP%E6%A8%A1%E6%8B%9F%E8%B5%9BT2-%E7%89%87%E6%AE%B5%E5%88%92%E5%88%86/</url>
    <content><![CDATA[<p>也是教练叫我们写的题解。</p>
<span id="more"></span>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>记录一下每个数前面第一个比它大的和比它小的数的位置，然后从后往前跳。</p>
<p>先把比它大的找到，然后让比它小的在范围内向前跳，跳得越前越好。</p>
<p>每次跳完答案加一。</p>
<h2 id="嗲吗"><a href="#嗲吗" class="headerlink" title="嗲吗"></a>嗲吗</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define ll long long</span></span><br><span class="line"><span class="comment">// #define int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp(x,y) make_pair(x,y)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb(x) push_back(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PII pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD=<span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">300002</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;<span class="keyword">register</span> <span class="type">char</span> c=<span class="built_in">getchar</span>();<span class="keyword">register</span> <span class="type">int</span> s=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">for</span>(;!<span class="built_in">isdigit</span>(c);c=<span class="built_in">getchar</span>())<span class="keyword">if</span>(c==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">-1</span>;<span class="keyword">for</span>(;<span class="built_in">isdigit</span>(c);c=<span class="built_in">getchar</span>())s=(s&lt;&lt;<span class="number">3</span>)+(s&lt;&lt;<span class="number">1</span>)+c-<span class="string">&#x27;0&#x27;</span>;<span class="keyword">return</span> s*f;&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> cnt1,cnt2;</span><br><span class="line"><span class="type">int</span> st1[N],st2[N];</span><br><span class="line"><span class="type">int</span> l[N],r[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	n=<span class="built_in">read</span>();</span><br><span class="line">	st2[<span class="number">0</span>]=<span class="number">-1</span>;st1[<span class="number">0</span>]=<span class="number">-2</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		a[i]=<span class="built_in">read</span>();</span><br><span class="line">		<span class="keyword">while</span>(cnt1&amp;&amp;a[st1[cnt1]]&gt;a[i])cnt1--;</span><br><span class="line">		<span class="keyword">while</span>(cnt2&amp;&amp;a[st2[cnt2]]&lt;=a[i])cnt2--;</span><br><span class="line">		l[i]=st1[cnt1];</span><br><span class="line">		r[i]=st2[cnt2];</span><br><span class="line">		st1[++cnt1]=st2[++cnt2]=i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> ll,rr=n;</span><br><span class="line">	<span class="keyword">while</span>(rr&gt;<span class="number">0</span>)&#123;</span><br><span class="line">		ll=rr;</span><br><span class="line">		<span class="keyword">while</span>(r[rr]&lt;=l[ll])ll=l[ll];</span><br><span class="line">		ans++;</span><br><span class="line">		rr=ll<span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Dumby的OI生涯</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>数据结构</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>NOIP模拟赛 7.6 T2 击杀 题解</title>
    <url>/2022/NOIP%E6%A8%A1%E6%8B%9F%E8%B5%9B-7-6-T2-%E5%87%BB%E6%9D%80-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<p>教练叫我们写的题解。</p>
<span id="more"></span>
<h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p>武士藤藤准备击杀地图上的幽灵。</p>
<p>地图为 $n \times m$（行，列）的整点网格图，坐标从左向右从下到上从 $0$ 编号。</p>
<p>开始藤藤可以从地图的任意的左侧进入，最后藤藤将从地图的右侧离开。</p>
<p>藤藤地图上的行进有一些奇妙的性质：</p>
<p>1．藤藤每单位时间会向右移动一单位长度，以尽快从地图上离开。<br>2．当一只幽灵与藤藤坐标重合，藤藤就会将其击杀。</p>
<p>在纵向，每单位时间藤藤可以快速移动[-delta,+delta]单位长度。</p>
<p>藤藤的移动速度极快，可以认为移动时不与任何幽灵坐标重合。</p>
<p>每只幽灵都有一定的能力值，第i行j列幽灵的能力值记为 $A_{i j}$。</p>
<p>藤藤希望其击杀的幽灵能力值之和最大。</p>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>比较简单的 DP，考虑到地图的数据范围较大但幽灵数少，可用幽灵来做决策。</p>
<h2 id="嗲吗"><a href="#嗲吗" class="headerlink" title="嗲吗"></a>嗲吗</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="comment">// #define int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp(x,y) make_pair(x,y)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb(x) push_back(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PII pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD=<span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">10002</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">10000001</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;<span class="keyword">register</span> <span class="type">char</span> c=<span class="built_in">getchar</span>();<span class="keyword">register</span> <span class="type">int</span> s=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">for</span>(;!<span class="built_in">isdigit</span>(c);c=<span class="built_in">getchar</span>())<span class="keyword">if</span>(c==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">-1</span>;<span class="keyword">for</span>(;<span class="built_in">isdigit</span>(c);c=<span class="built_in">getchar</span>())s=(s&lt;&lt;<span class="number">3</span>)+(s&lt;&lt;<span class="number">1</span>)+c-<span class="string">&#x27;0&#x27;</span>;<span class="keyword">return</span> s*f;&#125;</span><br><span class="line"><span class="type">int</span> n,m,delta,num;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> x,y,d;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> node xx)<span class="type">const</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> x&lt;xx.x;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;p[N];</span><br><span class="line"><span class="type">int</span> f[N],ans;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	n=<span class="built_in">read</span>(),m=<span class="built_in">read</span>(),delta=<span class="built_in">read</span>(),num=<span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=num;i++) p[i].y=<span class="built_in">read</span>(),p[i].x=<span class="built_in">read</span>(),p[i].d=<span class="built_in">read</span>();</span><br><span class="line">	<span class="built_in">sort</span>(p+<span class="number">1</span>,p+num+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=num;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;i;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">abs</span>(p[i].y-p[j].y)&lt;=delta*(p[i].x-p[j].x))&#123;</span><br><span class="line">				f[i]=<span class="built_in">max</span>(f[i],f[j]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		f[i]+=p[i].d;</span><br><span class="line">		ans=<span class="built_in">max</span>(ans,f[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Dumby的OI生涯</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ2274题解报告</title>
    <url>/2021/POJ2274%E9%A2%98%E8%A7%A3%E6%8A%A5%E5%91%8A/</url>
    <content><![CDATA[<p>POJ2274 The Race题解。</p>
<span id="more"></span>
<p><a href="http://poj.org/problem?id=2274">题目链接</a></p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给一堆车超出起点的距离 x 和车速度 v ，速度不变，求出飞行过程中的超车总数（对1000000取模）并输出超车与被超车的车的编号（如有同时则编号小的先输出）。</p>
<h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>一行一个整数 n （0 &lt; n &lt;= 250000）表示车数。</p>
<p>接下来 n 行，每行两个整数 x （0 &lt;= x &lt;= 1000000）和 v（0 &lt; v &lt; 100），表示车超出起点的距离和车速（保证编号 1 到 n 的车的 x 值单调递增）。</p>
<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>第一行一个整数，表示超车次数对1000000取模的值。</p>
<p>后面 min(10000，超车次数) 行（即如果超车次数不足10000次，则全输出，否则输出前10000个）每行两个整数 a 和 b，表示超车的车的编号以及被超车的车的编号（即 a 车超过了 b 车）。如果有多个超车事件同时发生，先输出离起跑线近的那个（即排名小的）。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>第一个问题一看就是逆序对问题，可以用树状数组求。</p>
<p>第二个问题稍微麻烦些。</p>
<p>我们令离起跑线近的排名小。</p>
<p>我们将所有车按照其 x 值排序，如图：</p>
<p><img src="https://img-blog.csdnimg.cn/3f9dc9693f714c6187b47554ddbb27e2.jpg" alt="请添加图片描述"></p>
<p>我们发现，只有排名相邻的两辆车才会最先发生超车事件。</p>
<p>超车事件发生的条件比较容易推出来：</p>
<p>设被超车的车的编号是 X ，排名是 NUMX 。</p>
<p>那么只要当 排名为 NUMX-1 的车（上图中靠左的车辆）的速度 大于 X 的速度 就会发生超车。</p>
<p><img src="https://img-blog.csdnimg.cn/3ab57d5b48b145dfa5a0738686fc789e.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0R1bWJ5X2NhdA==,size_16,color_FFFFFF,t_70" alt="请添加图片描述"></p>
<p>如上图，最先发生超车的一定是 1-2，2-3，或 3-4。</p>
<p>假设此时只有 2-3 发生超车事件，超车交换位置后排名如下：</p>
<p><img src="https://img-blog.csdnimg.cn/ec436cd4fce248b5b3003888e39a12ec.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0R1bWJ5X2NhdA==,size_16,color_FFFFFF,t_70" alt="请添加图片描述"></p>
<p>交换后又产生两组可能发生超车： 1-3 和 2-4 。所以接下来需要考虑这两个。</p>
<p>然后我们想：需要找最先超车的（即超车时间最小的），又要在中途加入操作对象，可以想到用堆来实现。</p>
<p>堆（小根堆）中存一个三元组（int，int，double），表示前一辆车（超车的车）的编号，后一辆车（被超车的车）的编号 以及 两车发生超车的时间（（x1-x2）/（v2-v1））。</p>
<p>堆中排序的关键字就是超车时间和排名（注意时间相同时要按排名输出）</p>
<p>每次取出堆顶，输出。</p>
<p>然后判断交换位置后新产生的两组是否能发生超车，能则入堆。</p>
<p>接下来见代码。</p>
<h2 id="嗲吗"><a href="#嗲吗" class="headerlink" title="嗲吗"></a>嗲吗</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PII pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1111500</span>, MOD = <span class="number">1e6</span>, P = <span class="number">131</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;<span class="type">char</span> c=<span class="built_in">getchar</span>();<span class="type">int</span> s=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">for</span>(;!<span class="built_in">isdigit</span>(c);c=<span class="built_in">getchar</span>())<span class="keyword">if</span>(c==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">-1</span>;<span class="keyword">for</span>(;<span class="built_in">isdigit</span>(c);c=<span class="built_in">getchar</span>())s=s*<span class="number">10</span>+c<span class="number">-48</span>;<span class="keyword">return</span> s*f;&#125;</span><br><span class="line"><span class="type">int</span> n, tr[N], x[N], v[N], num[N], id[N];</span><br><span class="line"><span class="comment">//tr数组是树状数组</span></span><br><span class="line"><span class="comment">//x[i]表示排名为 i 的车离超过起点的距离</span></span><br><span class="line"><span class="comment">//v[i]表示排名为 i 的车的速度</span></span><br><span class="line"><span class="comment">//num[i]表示编号为 i 的车的排名</span></span><br><span class="line"><span class="comment">//id[i]表示排名为 i 的车的编号</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> </span><br><span class="line">&#123;<span class="comment">//堆中的三元组</span></span><br><span class="line">	<span class="type">int</span> x, y;</span><br><span class="line">	<span class="type">double</span> t;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> node &amp;b)<span class="type">const</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> t &gt; b.t || (t == b.t &amp;&amp; num[x] &gt; num[b.x]);</span><br><span class="line">	&#125;<span class="comment">//重载运算符，让堆变成小根堆（按照时间和排名排序）</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;node&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接下来两个树状数组操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x)</span> </span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//添加</span></span><br><span class="line">	<span class="keyword">for</span> (; x &lt;= <span class="number">100</span>; x += x &amp; -x)tr[x]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> x)</span> </span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//查询</span></span><br><span class="line">	<span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (; x; x -= x &amp; -x)ans = (ans + tr[x]) % MOD;<span class="comment">//记得取模</span></span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	</span><br><span class="line">	n = <span class="built_in">read</span>();</span><br><span class="line">	<span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//ans用来记超车次数</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">	&#123;</span><br><span class="line">		x[i] = <span class="built_in">read</span>(), v[i] = <span class="built_in">read</span>();</span><br><span class="line">		</span><br><span class="line">		num[i] = id[i] = i;</span><br><span class="line">		<span class="comment">//初始化</span></span><br><span class="line">		ans = (ans + <span class="built_in">ask</span>(<span class="number">100</span>) - <span class="built_in">ask</span>(v[i])) % MOD;</span><br><span class="line">		<span class="built_in">add</span>(v[i]);</span><br><span class="line">		<span class="comment">//树状数组操作</span></span><br><span class="line">		<span class="keyword">if</span> (i ^ <span class="number">1</span> &amp;&amp; v[i - <span class="number">1</span>] &gt; v[i])</span><br><span class="line">		<span class="comment">//如果 i!=1 并且排名比他小一的车速度比他快</span></span><br><span class="line">			q.<span class="built_in">push</span>((node) &#123; </span><br><span class="line">				i - <span class="number">1</span>, <span class="comment">//前一辆车</span></span><br><span class="line">				i, <span class="comment">//后一辆车</span></span><br><span class="line">				(<span class="type">double</span>)(x[i] - x[i - <span class="number">1</span>]) / (v[i - <span class="number">1</span>] - v[i]) <span class="comment">//超车时间 </span></span><br><span class="line">			&#125;);<span class="comment">//入堆</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld \n&quot;</span>, ans);</span><br><span class="line">	<span class="comment">//输出超车次数</span></span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> t = <span class="number">1</span>; <span class="comment">//t用来记录个数，保证输出不超过10000个</span></span><br><span class="line">	<span class="keyword">while</span> (t &lt;= <span class="number">10000</span> &amp;&amp; q.<span class="built_in">size</span>()) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> X = q.<span class="built_in">top</span>().x, Y = q.<span class="built_in">top</span>().y;</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="comment">//X是前一辆车的编号，Y是后一辆车的编号</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (num[X] + <span class="number">1</span> != num[Y])<span class="keyword">continue</span>;</span><br><span class="line">		<span class="comment">//如果两辆车的排名不相邻（不是最先发生超车）则跳过。</span></span><br><span class="line">		</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%lld %lld\n&quot;</span>, X, Y); <span class="comment">//输出</span></span><br><span class="line">		t++;</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">swap</span>(id[num[X]], id[num[Y]]);</span><br><span class="line">		<span class="built_in">swap</span>(v[num[X]], v[num[Y]]);</span><br><span class="line">		<span class="built_in">swap</span>(x[num[X]], x[num[Y]]);</span><br><span class="line">		<span class="built_in">swap</span>(num[X], num[Y]);</span><br><span class="line">		<span class="comment">//交换 X 车与 Y 车的位置</span></span><br><span class="line">		<span class="comment">//交换后 X 车在前，Y 车在后（原本 Y 前 X 后）</span></span><br><span class="line">		<span class="keyword">if</span> (num[X] &lt; n &amp;&amp; v[num[X]] &gt; v[num[X] + <span class="number">1</span>] &amp;&amp;</span><br><span class="line">		        num[id[num[X]]] + <span class="number">1</span> == num[id[num[X] + <span class="number">1</span>]])</span><br><span class="line">		        <span class="comment">//如果交换后 X 的排名不是 n （X 前还有车）</span></span><br><span class="line">		        <span class="comment">//并且 X 车速大于 X 前面那辆</span></span><br><span class="line">		        <span class="comment">//并且两辆车的排名相邻</span></span><br><span class="line">		        <span class="comment">//最后一句可能有点绕，多读几遍，手动模拟一下就好了</span></span><br><span class="line">			q.<span class="built_in">push</span>((node) &#123;</span><br><span class="line">				id[num[X]], <span class="comment">//前一辆车编号</span></span><br><span class="line">				id[num[X] + <span class="number">1</span>], <span class="comment">//后一辆车编号</span></span><br><span class="line">				(<span class="type">double</span>)(x[num[X] + <span class="number">1</span>] - x[num[X]]) / (v[num[X]] - v[num[X] + <span class="number">1</span>]) <span class="comment">//时间</span></span><br><span class="line">			&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (num[Y] &gt; <span class="number">1</span> &amp;&amp; v[num[Y] - <span class="number">1</span>] &gt; v[num[Y]] &amp;&amp;</span><br><span class="line">		        num[id[num[Y] - <span class="number">1</span>]] + <span class="number">1</span> == num[id[num[Y]]])</span><br><span class="line">		        <span class="comment">//如果交换后 Y 的排名不是 1 （Y 后还有车）</span></span><br><span class="line">		        <span class="comment">//并且 Y 车速小于 Y 后面那辆</span></span><br><span class="line">		        <span class="comment">//并且两辆车的排名相邻</span></span><br><span class="line">			q.<span class="built_in">push</span>((node) &#123;</span><br><span class="line">				id[num[Y] - <span class="number">1</span>], <span class="comment">//前一辆车</span></span><br><span class="line">				id[num[Y]], <span class="comment">//后一辆车</span></span><br><span class="line">				(<span class="type">double</span>)(x[num[Y]] - x[num[Y] - <span class="number">1</span>]) / (v[num[Y] - <span class="number">1</span>] - v[num[Y]]) <span class="comment">//时间</span></span><br><span class="line">			&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有错误请 D 我</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Dumby的OI生涯</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>数据结构</tag>
        <tag>堆</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title>Roguelike学习笔记一：LibTCod</title>
    <url>/2022/Roguelike%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80%EF%BC%9ALibTCod/</url>
    <content><![CDATA[<p>学习一下传统Roguelike游戏制作引擎 LibTCod。</p>
<span id="more"></span>
<p>折腾了好久好久，怎么都跑不起来libtcod，真tm太曹丹了。。</p>
<p>直到我看到这个叫做<a href="https://github.com/HexDecimal/tcod-cpp-engine-2022">TCod Cpp Engine</a>的项目（最近官方出了个<a href="https://github.com/HexDecimal/libtcod-vcpkg-template">模板</a>，配置过程与下面类似，两者都可使用），最后跟着介绍的步骤终于跑起来了。</p>
<p><img src="第一次成功运行.png" alt="终于跑起来啦！！！" title="终于跑起来啦！！！"></p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>先要有一些基本工具：VsCode、Cmake，对了，最好再载一下VS（这里用VS2022），因为后面vcpkg使用时要求有VS实例。</p>
<p>然后把<a href="https://github.com/HexDecimal/tcod-cpp-engine-2022">这个库</a><strong>克隆</strong>到本地（注意是克隆不是直接复制，用git克隆后面可以免去很多乱七八糟的步骤）。</p>
<p>这里我将库直接克隆到D盘下。（项目主目录为 <code>D:\tcod-cpp-engine-2022</code>）</p>
<p>开始初始化<code>LibTCod</code>和<code>Vcpkg</code>两个子模块。<br>子模块是什么具体看<a href="https://git-scm.com/book/en/v2/Git-Tools-Submodules">官方文档</a>，这里不多说。<br>我们注意到克隆下来的文件夹中有两个空的文件夹：<code>libtcod</code>和<code>vcpkg</code>，这两个就是两个子模块的文件夹。<br>接下来在项目的文件夹下（<code>D:\tcod-cpp-engine-2022</code>）运行命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git submodule update --init --recursive</span><br></pre></td></tr></table></figure>
<p>然后就完成了子模块的初始化。<br>这里如果有什么报错之类的通常都是网络不行，多试几次就行了。<br>注意子模块一定要正确初始化，刚那两个文件夹有一个空的都会导致编译失败。</p>
<p>接下来打开VsCode，点击打开文件夹，打开项目的主目录（<code>D:\tcod-cpp-engine-2022</code>）。</p>
<p>如果你没有下载扩展的话会让你载一些，把VsCode推荐的扩展全都载下来就好了，其中最重要的是这几个：C/C++相关扩展、CMake工具。</p>
<p>VsCode还会提示你选择Kit，这里Win10的话最好选amd64，如果没提示的话可以到底部找到Kit选项打开并选择。</p>
<p><img src="Kit.png" alt="选择Kit" title="选择Kit"></p>
<p>最后按 <code>F5</code>，VsCode会自动进行编译。</p>
<p>这样应该就行了，他会跳出一个该项目原作者的一个示例，能运行就说明配置成功。</p>
<p>参考：</p>
<ul>
<li><a href="https://github.com/HexDecimal/tcod-cpp-engine-2022">@HexDecimal 大佬的项目 Libtcod C++ engine 2022</a></li>
<li><a href="https://github.com/HexDecimal/libtcod-vcpkg-template">LibTCod 官方模板</a></li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Dumby的RoguelikeDev笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>roguelike</tag>
        <tag>libtcod</tag>
      </tags>
  </entry>
  <entry>
    <title>SPOJ2916 GSS5-Can you answer these queries V</title>
    <url>/2022/SPOJ2916-GSS5-Can-you-answer-these-queries-V/</url>
    <content><![CDATA[<p>坑题 SPOJ2916 GSS5-Can you answer these queries V 题解。</p>
<span id="more"></span>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>题目很坑，题中的子段是不能为空的。</p>
<p>其余就是一个比较裸的线段树维护区间最大值，在左右区间是否重合、包含上讨论一下就好了（虽然我调了快一晚上）。</p>
<h2 id="码"><a href="#码" class="headerlink" title="码"></a>码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp(x,y) make_pair(x,y)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb(x) push_back(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PII pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD=<span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1000002</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">10000001</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;<span class="keyword">register</span> <span class="type">char</span> c=<span class="built_in">getchar</span>();<span class="keyword">register</span> <span class="type">int</span> s=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">for</span>(;!<span class="built_in">isdigit</span>(c);c=<span class="built_in">getchar</span>())<span class="keyword">if</span>(c==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">-1</span>;<span class="keyword">for</span>(;<span class="built_in">isdigit</span>(c);c=<span class="built_in">getchar</span>())s=(s&lt;&lt;<span class="number">3</span>)+(s&lt;&lt;<span class="number">1</span>)+c-<span class="string">&#x27;0&#x27;</span>;<span class="keyword">return</span> s*f;&#125;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> l,r,s,mm,ml,mr;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> l(x) tr[x].l</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> r(x) tr[x].r</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> s(x) tr[x].s</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> mm(x) tr[x].mm</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> ml(x) tr[x].ml</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> mr(x) tr[x].mr</span></span><br><span class="line">&#125;tr[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_up</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">	<span class="built_in">mm</span>(p)=<span class="built_in">max</span>(<span class="built_in">mm</span>(p*<span class="number">2</span>),<span class="built_in">max</span>(<span class="built_in">mm</span>(p*<span class="number">2</span>+<span class="number">1</span>),<span class="built_in">mr</span>(p*<span class="number">2</span>)+<span class="built_in">ml</span>(p*<span class="number">2</span>+<span class="number">1</span>)));</span><br><span class="line">	<span class="built_in">ml</span>(p)=<span class="built_in">max</span>(<span class="built_in">ml</span>(p*<span class="number">2</span>),<span class="built_in">s</span>(p*<span class="number">2</span>)+<span class="built_in">ml</span>(p*<span class="number">2</span>+<span class="number">1</span>));</span><br><span class="line">	<span class="built_in">mr</span>(p)=<span class="built_in">max</span>(<span class="built_in">mr</span>(p*<span class="number">2</span>+<span class="number">1</span>),<span class="built_in">s</span>(p*<span class="number">2</span>+<span class="number">1</span>)+<span class="built_in">mr</span>(p*<span class="number">2</span>));</span><br><span class="line">	<span class="built_in">s</span>(p)=<span class="built_in">s</span>(p*<span class="number">2</span>)+<span class="built_in">s</span>(p*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="built_in">l</span>(p)=l,<span class="built_in">r</span>(p)=r;</span><br><span class="line">	<span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">		<span class="built_in">s</span>(p)=<span class="built_in">mm</span>(p)=<span class="built_in">ml</span>(p)=<span class="built_in">mr</span>(p)=a[l];</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">build</span>(p*<span class="number">2</span>,l,mid);</span><br><span class="line">	<span class="built_in">build</span>(p*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">	<span class="built_in">push_up</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> k,<span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">l</span>(p)==<span class="built_in">r</span>(p))&#123;</span><br><span class="line">		<span class="built_in">s</span>(p)=<span class="built_in">mm</span>(p)=<span class="built_in">ml</span>(p)=<span class="built_in">mr</span>(p)=d;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mid=(<span class="built_in">l</span>(p)+<span class="built_in">r</span>(p))&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(k&lt;=mid)<span class="built_in">change</span>(p*<span class="number">2</span>,k,d);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">change</span>(p*<span class="number">2</span>+<span class="number">1</span>,k,d);</span><br><span class="line">	<span class="built_in">push_up</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">node <span class="title">ask</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l&gt;r)<span class="keyword">return</span> &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">if</span>(l&lt;=<span class="built_in">l</span>(p)&amp;&amp;<span class="built_in">r</span>(p)&lt;=r) <span class="keyword">return</span> tr[p];</span><br><span class="line">	<span class="type">int</span> mid=(<span class="built_in">l</span>(p)+<span class="built_in">r</span>(p))&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(l&gt;mid) <span class="keyword">return</span> <span class="built_in">ask</span>(p*<span class="number">2</span>+<span class="number">1</span>,l,r);</span><br><span class="line">	<span class="keyword">if</span>(r&lt;=mid)<span class="keyword">return</span> <span class="built_in">ask</span>(p*<span class="number">2</span>,l,r);</span><br><span class="line">	node ls=<span class="built_in">ask</span>(p*<span class="number">2</span>,l,mid),rs=<span class="built_in">ask</span>(p*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r),ans;</span><br><span class="line">	ans.s=ls.s+rs.s;</span><br><span class="line">	ans.ml=<span class="built_in">max</span>(ls.ml,ls.s+rs.ml);</span><br><span class="line">	ans.mr=<span class="built_in">max</span>(rs.s+ls.mr,rs.mr);</span><br><span class="line">	ans.mm=<span class="built_in">max</span>(ls.mr+rs.ml,<span class="built_in">max</span>(ls.mm,rs.mm));</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> T=<span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">while</span>(T--)&#123;</span><br><span class="line">		n=<span class="built_in">read</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)a[i]=<span class="built_in">read</span>();</span><br><span class="line">		m=<span class="built_in">read</span>();</span><br><span class="line">		<span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">		<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">			<span class="type">int</span> l1=<span class="built_in">read</span>(),r1=<span class="built_in">read</span>(),l2=<span class="built_in">read</span>(),r2=<span class="built_in">read</span>();</span><br><span class="line">			<span class="keyword">if</span>(l1&gt;r1)<span class="built_in">swap</span>(l1,r1);</span><br><span class="line">			<span class="keyword">if</span>(l2&gt;r2)<span class="built_in">swap</span>(l2,r2);</span><br><span class="line">			<span class="keyword">if</span>(l1&gt;l2)<span class="built_in">swap</span>(l1,l2),<span class="built_in">swap</span>(r1,r2);</span><br><span class="line">			<span class="keyword">if</span>(r1&lt;l2)&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">ask</span>(<span class="number">1</span>,l1,r1).mr+<span class="built_in">ask</span>(<span class="number">1</span>,r1+<span class="number">1</span>,l2<span class="number">-1</span>).s+<span class="built_in">ask</span>(<span class="number">1</span>,l2,r2).ml);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(r2&gt;r1)&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">max</span>(<span class="built_in">ask</span>(<span class="number">1</span>,l2,r1).mm,<span class="built_in">max</span>(<span class="built_in">ask</span>(<span class="number">1</span>,l1,l2<span class="number">-1</span>).mr+<span class="built_in">ask</span>(<span class="number">1</span>,l2,r2).ml,<span class="built_in">ask</span>(<span class="number">1</span>,l1,r1).mr+<span class="built_in">ask</span>(<span class="number">1</span>,r1+<span class="number">1</span>,r2).ml))); </span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">max</span>(<span class="built_in">ask</span>(<span class="number">1</span>,l1,l2<span class="number">-1</span>).mr+<span class="built_in">ask</span>(<span class="number">1</span>,l2,r2).ml,<span class="built_in">ask</span>(<span class="number">1</span>,l2,r2).mm)); </span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Dumby的OI生涯</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>线段树</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Serum合成器Filter模块自习</title>
    <url>/2023/Serum%E5%90%88%E6%88%90%E5%99%A8Filter%E6%A8%A1%E5%9D%97%E8%87%AA%E4%B9%A0/</url>
    <content><![CDATA[<p>本帖用于自习Serum的滤波器模块。</p>
<span id="more"></span>
<p>滤波器顾名思义就是用来滤波的，简单地理解下可以看成这样一幅图：</p>
<p><img src="滤波器功能的简单理解.png" alt="滤波器功能的简单理解" title="滤波器功能的简单理解"></p>
<p>上方的波形的横轴参数相当是频率，纵轴参数相当于是相应频率的声音的通过度，越高通过的越多，而越低则滤掉的越多。上图中的右边部分很低，说明滤波器将高频段的声音过滤掉了，所以经过这个滤波器的声音会感觉闷闷的。</p>
<p>最基本的滤波器应该是这三种：高通、低通、带通。</p>
<h3 id="低通滤波器（Low）"><a href="#低通滤波器（Low）" class="headerlink" title="低通滤波器（Low）"></a>低通滤波器（Low）</h3><p>意思就是只通过低频率，将高频率的声音过滤掉。</p>
<p>上面的那张图就是低通的滤波器。</p>
<h3 id="高通滤波器（High）"><a href="#高通滤波器（High）" class="headerlink" title="高通滤波器（High）"></a>高通滤波器（High）</h3><p>同理，如图：</p>
<p><img src="高通.png" alt="高通" title="高通"></p>
<h3 id="带通滤波器（Band）"><a href="#带通滤波器（Band）" class="headerlink" title="带通滤波器（Band）"></a>带通滤波器（Band）</h3><p>只通过一段连续频率的滤波器叫带通滤波器，如图：</p>
<p><img src="带通.png" alt="带通" title="带通"></p>
<p>此外还有峰值增益（Peak）、陷波（Notch）等。</p>
<p>接下来看下Serum自带的Filter：</p>
<p><img src="FILTER.png" alt="FILTER" title="FILTER"></p>
<h2 id="ABNS"><a href="#ABNS" class="headerlink" title="ABNS"></a>ABNS</h2><p>那四个按钮表示 OSC A/B/Noice/Sub 是否进行滤波。</p>
<h2 id="KeyTrack"><a href="#KeyTrack" class="headerlink" title="KeyTrack"></a>KeyTrack</h2><p>音符追踪。</p>
<p>点亮以后滤波器的属性（Cutoff）会随输入音符的变化而变化，有时能让滤波效果更适应音符。</p>
<h2 id="CUTOFF"><a href="#CUTOFF" class="headerlink" title="CUTOFF"></a>CUTOFF</h2><p>Cutoff：截止频率。</p>
<p>用来修改允许通过的频段。</p>
<h2 id="RES"><a href="#RES" class="headerlink" title="RES"></a>RES</h2><p>Resonance：谐振、共鸣。</p>
<p>会把Cutoff周围的频段突出。</p>
<h2 id="PAN"><a href="#PAN" class="headerlink" title="PAN"></a>PAN</h2><p>Pan（Stereo）：声相。</p>
<h2 id="DRIVE"><a href="#DRIVE" class="headerlink" title="DRIVE"></a>DRIVE</h2><p>Drive：过载。</p>
<p>使输入滤波器的增益加强，太强可能会失真。</p>
<h2 id="FAT"><a href="#FAT" class="headerlink" title="FAT"></a>FAT</h2><p>这个按钮会随选用的滤波类型变化，有时显示“FAT”，有时“FREQ”（Frequency），有时直接“-”。</p>
<h2 id="MIX"><a href="#MIX" class="headerlink" title="MIX"></a>MIX</h2><p>修改通过滤波器的声音的比例。</p>
<p>点他一下会变成 LEVEL。</p>
<h2 id="MENU"><a href="#MENU" class="headerlink" title="MENU"></a>MENU</h2><p>目录里默认有四大类：Normal（普通）、Multi（复合）、Flanges（法兰）、Misc（杂项，里面有很多有意思的滤波类型）。</p>
<h2 id="波表"><a href="#波表" class="headerlink" title="波表"></a>波表</h2><p>点击滤波器的图案可以切换到Phases，即通过滤波器后的波形。</p>
<h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>这是个结尾。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Dumby的折腾笔记</category>
      </categories>
      <tags>
        <tag>合成器</tag>
      </tags>
  </entry>
  <entry>
    <title>Serum合成器OSC模块Warp选项讲解</title>
    <url>/2023/Serum%E5%90%88%E6%88%90%E5%99%A8OSC%E6%A8%A1%E5%9D%97Warp%E9%80%89%E9%A1%B9%E8%AE%B2%E8%A7%A3/</url>
    <content><![CDATA[<p>本帖用于介绍 Serum 的振荡器模块中的 Warp 选项。</p>
<span id="more"></span>
<p>之前讲到 WT POS 选项边上有个 Warp 选项，就是这个：</p>
<p><img src="位置.png" alt="位置" title="位置"></p>
<p>Warp：弯曲、变形。</p>
<p>这个选项的功能对着波形图边调边看很容易就明白了。</p>
<p>官方给出的解释是：</p>
<p><img src="功能解释.png" alt="功能解释" title="功能解释"></p>
<p>即基于当前的Warp选择调整当前的波形。</p>
<p>我们拿正弦波来举例子（波形选择目录里选择Analog\Basic Shapes，调整WT POS 可以得到几个基础波形）。</p>
<p><img src="正弦波.png" alt="正弦波" title="正弦波"></p>
<h2 id="Warp-Menu-总览"><a href="#Warp-Menu-总览" class="headerlink" title="Warp Menu 总览"></a>Warp Menu 总览</h2><p>点击默认的OFF，打开一个目录（即Warp Menu），如图：</p>
<p><img src="目录.png" alt="Warp Menu" title="Warp Menu"></p>
<p>每一个选项都有很有意思的功能，下面一个一个看。</p>
<h2 id="SYNC"><a href="#SYNC" class="headerlink" title="SYNC"></a>SYNC</h2><p>SYNC：同步（？）。</p>
<p>调一下旋钮就知道这东西干嘛用的了。</p>
<p><img src="调整SYNC.gif" alt="调整SYNC" title="调整SYNC"></p>
<p>应该不会注意不到波形的变化吧。</p>
<p>很显然，SYNC调的越高，波的周期越小，频率越大，单位时间内出现的同样的波形越多，音调越高。</p>
<p>但要注意，如果用的是正弦波这种连续变化的波形，在调到这种位置的时候：</p>
<p><img src="调SYNC.jpg" alt="调SYNC" title="调SYNC"></p>
<p>由于右边的波形被截掉了，相当于有一个突变（和锯齿波的那种类似），声音就会夹杂着类似锯齿波的声音，比较刺耳。</p>
<p>但如果用锯齿波来调的话，因为本身就是这种声音，所以除了音调变化听不大出来其他的变化。</p>
<h3 id="SYNC-WINDOW"><a href="#SYNC-WINDOW" class="headerlink" title="SYNC WINDOW"></a>SYNC WINDOW</h3><p>如果不想有刚才的“突变”的问题，可以选择 SYNC WINDOW 这个选项。</p>
<p>这个选项分两种： SYNC 1/2 WIN. 和 SYNC WINDOW。</p>
<p>这个东西就相当于在波形的两侧加上淡入淡出，使声音变得更平滑，不会使连续变化的波形出现突变的情况。</p>
<p>当然如果你用锯齿波的话，当 Warp 的数值低的时候，锯齿波会被柔和成类似正弦波的东西。</p>
<p>SYNC 1/2 WIN. 相当于是淡入淡出更快的 SYNC WINDOW。</p>
<p>SYNC WINDOW：</p>
<p><img src="SYNC_WINDOW.jpg" alt="SYNC_WINDOW" title="SYNC_WINDOW"></p>
<p><img src="SYNC_WINDOW.gif" alt="SYNC_WINDOW" title="SYNC_WINDOW"></p>
<p>SYNC 1/2 WIN.：</p>
<p><img src="SYNC_1-2_WIN.jpg" alt="SYNC_1/2_WIN." title="SYNC_1/2_WIN."></p>
<p><img src="SYNC_1-2_WIN.gif" alt="SYNC_1/2_WIN." title="SYNC_1/2_WIN."></p>
<h2 id="BEND"><a href="#BEND" class="headerlink" title="BEND"></a>BEND</h2><p>BEND：弯曲。</p>
<h3 id="BEND-1"><a href="#BEND-1" class="headerlink" title="BEND +"></a>BEND +</h3><p>将波形向内弯曲，效果如下：</p>
<p><img src="BENDp.gif" alt="BEND+" title="BEND+"></p>
<h3 id="BEND-2"><a href="#BEND-2" class="headerlink" title="BEND -"></a>BEND -</h3><p>将波形向外弯曲，效果如下：</p>
<p><img src="BEND-.gif" alt="BEND-" title="BEND-"></p>
<h3 id="BEND-3"><a href="#BEND-3" class="headerlink" title="BEND +/-"></a>BEND +/-</h3><p>数值为负时向内弯曲，为正时向外弯曲，效果如下：</p>
<p><img src="BENDp-.gif" alt="BEND+/-" title="BEND+/-"></p>
<h2 id="PWM"><a href="#PWM" class="headerlink" title="PWM"></a>PWM</h2><p>PWM：脉冲宽度调制（Pulse Width Modulation）。</p>
<p>相当于将波形宽度（即“脉冲宽度”）变窄，效果如下：</p>
<p><img src="正弦PWM.gif" alt="正弦波PWM" title="正弦波PWM"></p>
<p><img src="方波PWM.gif" alt="方波PWM" title="方波PWM"></p>
<h2 id="ASYM"><a href="#ASYM" class="headerlink" title="ASYM"></a>ASYM</h2><p>ASYM：非对称（即非对称弯曲）。</p>
<p>ASYM 的作用大概就是将波形左右两边分别压缩或拉伸。</p>
<h3 id="ASYM-1"><a href="#ASYM-1" class="headerlink" title="ASYM +"></a>ASYM +</h3><p>将波形左半边压缩，右半边拉伸，效果如下：</p>
<p><img src="ASYMp.gif" alt="ASYM+" title="ASYM+"></p>
<h3 id="ASYM-2"><a href="#ASYM-2" class="headerlink" title="ASYM -"></a>ASYM -</h3><p>将波形左半边拉伸，右半边压缩，效果如下：</p>
<p><img src="ASYM-.gif" alt="ASYM-" title="ASYM-"></p>
<h3 id="ASYM-3"><a href="#ASYM-3" class="headerlink" title="ASYM +/-"></a>ASYM +/-</h3><p>数值为负时，将波形左半边压缩，右半边拉伸；数值为正时，将波形左半边拉伸，右半边压缩，效果如下：</p>
<p><img src="ASYMp-.gif" alt="ASYM+/-" title="ASYM+/-"></p>
<h2 id="FLIP"><a href="#FLIP" class="headerlink" title="FLIP"></a>FLIP</h2><p>FLIP：翻转。</p>
<p>将波形进行上下翻转，效果如下：</p>
<p><img src="FLIP.gif" alt="FLIP" title="FLIP"></p>
<h2 id="MIRROR"><a href="#MIRROR" class="headerlink" title="MIRROR"></a>MIRROR</h2><p>MIRROR：镜像。</p>
<p>相当于将波形先加一个 ASYM +/-，然后再左右镜像一下，效果如下：</p>
<p><img src="MIRROR.gif" alt="MIRROR" title="MIRROR"></p>
<h2 id="REMAP"><a href="#REMAP" class="headerlink" title="REMAP"></a>REMAP</h2><p>REMAP：重映射。</p>
<p>功能如其名，这个 Warp 选项旁边还有一个笔的记号，点开它是一个长得像 LFO 一样的东西，上面写着“Remap Edit”：</p>
<p><img src="REMAPEDIT.png" alt="REMAPEDIT" title="REMAPEDIT"></p>
<p>实际上这是个映射函数（我认为），它的作用大概如下。</p>
<p>为了方便说明，我们假设波形是一个函数 $g( \varphi )$，如图：</p>
<p><img src="g(phi).png" alt="g(phi)" title="g(phi)" /></p>
<p>然后这个我们设映射函数为 $f( \varphi )$，如下：</p>
<p><img src="RF.png" alt="RemapFunction" title="RemapFunction" /></p>
<p>当 REMAP 数值为 100% 时，原来的波形 $g( \varphi )$ 变成 $g( f( \varphi ) )$。也就是说，原来的相位 $ \varphi $ 被映射成 $f( \varphi )$。</p>
<p>当 REMAP 数值在 0% 到 100% 之间时，$g( \varphi )$ 会在 $g( \varphi )$ 到 $g( f( \varphi ) )$ 之间变化。</p>
<h3 id="REMAP-1"><a href="#REMAP-1" class="headerlink" title="REMAP 1"></a>REMAP 1</h3><p>普通的 REMAP，效果如下：</p>
<p><img src="REMAP1.gif" alt="REMAP1" title="REMAP1" /></p>
<h3 id="REMAP-2"><a href="#REMAP-2" class="headerlink" title="REMAP 2"></a>REMAP 2</h3><p>差不多就是 REMAP 1 + MIRROR，效果如下：</p>
<p><img src="REMAP2.gif" alt="REMAP2" title="REMAP2" /></p>
<h3 id="REMAP-3"><a href="#REMAP-3" class="headerlink" title="REMAP 3"></a>REMAP 3</h3><p>基于正弦函数的 REMAP，通过 REMAP 3 可以不用花太大功夫在 $f( \varphi )$ 上，即使你画的映射函数很粗糙，它在波形上引起的变化也会很平滑，效果如下：</p>
<p><img src="REMAP3.gif" alt="REMAP3" title="REMAP3" /></p>
<h3 id="REMAP-4"><a href="#REMAP-4" class="headerlink" title="REMAP 4"></a>REMAP 4</h3><p>和 REMAP 2 类似，但是原来的波形周期变成四分之一，效果如下：</p>
<p><img src="REMAP4.gif" alt="REMAP4" title="REMAP4" /></p>
<h2 id="QUANTIZE"><a href="#QUANTIZE" class="headerlink" title="QUANTIZE"></a>QUANTIZE</h2><p>QUANTIZE：量化。</p>
<p>就是把波形变方。</p>
<h2 id="FM-FROM-B"><a href="#FM-FROM-B" class="headerlink" title="FM(FROM B)"></a>FM(FROM B)</h2><p>以振荡器B（OSC B）的波形来频率调制该振荡器。</p>
<h2 id="AM-FROM-B"><a href="#AM-FROM-B" class="headerlink" title="AM(FROM B)"></a>AM(FROM B)</h2><p>以振荡器B（OSC B）的波形来幅度调制该振荡器。</p>
<h2 id="RM-FROM-B"><a href="#RM-FROM-B" class="headerlink" title="RM(FROM B)"></a>RM(FROM B)</h2><p>以振荡器B（OSC B）的波形来环形调制该振荡器。</p>
<h2 id="FM-NOISE"><a href="#FM-NOISE" class="headerlink" title="FM(NOISE)"></a>FM(NOISE)</h2><p>以噪声振荡器的波形来频率调制该振荡器。</p>
<h2 id="FM-SUB"><a href="#FM-SUB" class="headerlink" title="FM(SUB)"></a>FM(SUB)</h2><p>以低音振荡器的波形来频率调制该振荡器。</p>
<h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>后面部分写得不详细，因为涉及其他地方的知识，以后写到再说（反正也没人看）。</p>
<p>参考：</p>
<ul>
<li><a href="https://www.bilibili.com/read/cv793091">B站 @Mask不是马赛克 的文章</a></li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Dumby的折腾笔记</category>
      </categories>
      <tags>
        <tag>合成器</tag>
      </tags>
  </entry>
  <entry>
    <title>Serum的OSC入门</title>
    <url>/2022/Serum%E7%9A%84OSC%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>本帖用于自习Serum的振荡器模块。</p>
<span id="more"></span>
<p>还是这张图。</p>
<p><img src="serum的osc.png" alt="OSC" title="OSC"></p>
<p>一个一个看。</p>
<p><img src="波形.png" alt="波形" title="波形"></p>
<p>最上面这个自然是<strong>波形（Waveform）</strong>了（红框里的）。</p>
<p>两个红框之间的是<strong>音高（Pitch）</strong>调整。</p>
<p>OCT（Octave）：八度音高</p>
<p>SEM（Semi）：半音音高</p>
<p>FIN（fine）：微调</p>
<p>CRS（CoarsePit）：粗调</p>
<p>接下来有这些东西：</p>
<p><img src="下方.png" alt="其他参数" title="其他参数"></p>
<p>UNISON：合奏，即同时演奏的声音数量。</p>
<p>DETUNE：失谐，即同时演奏的声音之间相差的音高大小。</p>
<p>BLEND：同时演奏的声音之间相差的音量（<strong>实际上是电平</strong>，两者并不一样，但是改变电平的直观感受是改变音量）大小。</p>
<p><img src="unison.png" alt="调节的界面" title="调节的界面"></p>
<p>这几个东西右边的有这两个：PHASE、RAND。</p>
<p>PHASE：相位，之前在FFT（傅里叶分析）的那篇博客里提到过，即“用来确定一个波在循环中的位置的东西”。再说简单点，就是声音开始的位置。</p>
<p>RAND（RANDOM）：随机，就是将每个同时演奏的声音的相位随机改变一点。这样可以改变一些奇奇怪怪的问题（比如将一个锯齿波的UNISON调高后，你把RANDOM为0和最高时发出的两种声音对比一下）。</p>
<p>对于Serum合成器来说，每个波形最多有256帧（Frame）。</p>
<p>你可以单击波形显示的地方，然后它的波形的显示界面会变成这样：</p>
<p><img src="子波形.png" alt="默认波形的所有帧" title="默认波形的所有帧"></p>
<p>默认的锯齿波看这个并不明显，我们可以随便切换一个别的波形（这里拿Acid举例子），它的所有帧叠起来是这样的：</p>
<p><img src="acid子波形.png" alt="Acid的所有帧" title="Acid的所有帧"></p>
<p>而下面的WT POS，就是调整帧用的。</p>
<p>WT POS（WaveTable Position）：波形位置，即当前选中的是波形的哪一帧。</p>
<p>WT POS右边有一个默认是OFF的旋钮，它是Warp，这个之后细讲一下，这里先略过。</p>
<p>PAN：声像，即左右声道，带上耳机开个立体声调下就知道了。</p>
<p>LEVEL：电平，通常拿来当音量用，上面说了，“两者并不一样，但是改变电平的直观感受是改变音量”。</p>
<p>在波形显示的地方右上角有个笔的图案，点击后进入波形编辑界面，比较复杂，这里也先略过。</p>
<p>之后（可能）会详细讲一下Serum的振荡器中各个部分。</p>
<p>参考：</p>
<ul>
<li><a href="https://www.bilibili.com/read/cv758489">B站UP主@Mask不是马赛克的文章《电子音乐人必备合成器战法之Serum新手完全入门教学》</a></li>
<li><a href="https://www.bilibili.com/video/BV1Ys411i7hF">B站UP主@AndreChen的教学视频 《【合辑】【合成器基础教学】入门/通用/必备知识——Abletive教学视频站》</a></li>
<li><a href="https://www.bilibili.com/video/BV1op411f7Dr">B站UP主@泰迪Ted-E的教学视频 《【Xfer Records SERUM 血清合成器系列教程】》</a></li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Dumby的折腾笔记</category>
      </categories>
      <tags>
        <tag>合成器</tag>
      </tags>
  </entry>
  <entry>
    <title>Spider-Man: Across the Spider-Verse 观后</title>
    <url>/2023/Spider-Man-Across-the-Spider-Verse-%E8%A7%82%E5%90%8E/</url>
    <content><![CDATA[<p>最近二刷完《蜘蛛侠：纵横宇宙》，顺手写点有趣的东西吧。</p>
<span id="more"></span>
<p>先放张剧照镇下帖。</p>
<p><img src="Miles&Gwen.jpg" alt="镇帖图" title="镇帖图"></p>
<p>以下也有许多是口嗨，不喜勿喷。</p>
<h2 id="Spotter-man"><a href="#Spotter-man" class="headerlink" title="Spotter-man"></a>Spotter-man</h2><p>这名字我瞎起的。。</p>
<p>主要是看到这个东西：</p>
<p><img src="Spotter-man.png" alt="Spotter-man" title="Spotter-man"></p>
<p>我不知道官方有没有关于这个的介绍，反正挺有意思的，看着像 Spot 和 Spider-man 的结合体，就瞎起了个名字。</p>
<h2 id="有点像："><a href="#有点像：" class="headerlink" title="有点像："></a>有点像：</h2><h3 id="瑞克与莫蒂"><a href="#瑞克与莫蒂" class="headerlink" title="瑞克与莫蒂"></a>瑞克与莫蒂</h3><p>第一遍看的时候就觉得这两东西挺像的了：</p>
<p><img src="Lobby.jpg" alt="2099_Lobby" title="2099_Lobby"></p>
<p>和</p>
<p><img src="瑞城.png" alt="瑞城" title="瑞城"></p>
<p>（不过只是有些设定挺像的，其他的。。。毕竟后者那一集是额。。dddd）</p>
<h3 id="星球大战"><a href="#星球大战" class="headerlink" title="星球大战"></a>星球大战</h3><p><img src="ReturnOfTheJedi.jpg" alt="Return of the Jedi" title="Return of the Jedi"></p>
<p>《蜘蛛侠：平行宇宙》这两部情节设置个人感觉和《星球大战》（4-6）很有相似之处。（星战是三部曲鼻祖，不像就怪了。。）我随便说说：</p>
<p>两系列电影的第一部中，主角（Miles和Luke）在开始都是处于懵懂状态，一者是有点叛逆的高材生，一者是向往自由的农场少年（随便概括一下，可能不大准确）。</p>
<p>电影不久出现第一处转折，一个是 Miles 被 42 号蜘蛛咬了一口，另一个是 Luke 遇上 R2-D2 和 C-3PO，这个转折将主角引向一个重要人物，Miles 遇上的是 Peter，Luke 则遇上了 Obi-Wan。</p>
<p>接下来出现第二处转折，Miles 目睹了 Peter 之死，Luke 则是被帝国抄家，Owen 夫妇双亡。</p>
<p>第二个转折之后主角遇上主角团，带着主角团打团战（May 被抄家和 Luke 拯救 Leia），打团战的时候出现第三个转折：Miles 的叔叔 Aaron 中弹挂了、Luke 的导师 Obi-Wan 成为英灵。</p>
<p>两部电影都先后在这两次转折中出现与主角自己有深层联系的反派：Miles 的叔叔 Aaron 是徘徊者，Luke 的爹爹 Anakin 是 Vader。</p>
<p>第三个转折之后来一段主角的成长，最后对局 Boss 然后摧毁电影重要地点（对撞机和死星）（不过 Luke 主要是炸死星而不是和 Vader 的对局），对局 Boss 的时候都来个场外精神援助（Miles 他爹和 Obi-Wan 的英灵）。</p>
<p>然后第一部引来一个比较美满的结局。</p>
<p>第一部可以说相似性相当高，第二部也有很多相似之处。</p>
<p>比如主角在对局反派（Miguel 在这部里姑且算是个广义上的反派吧）时了解到自己的身世：Miles 是个错误的产物，Luke 是 Vader 的亲儿子。同时还发现 Gwen 和 Peter 以及 Obi-Wan 和 Yoda 早就知道真相。</p>
<p>再比如两部作品的结尾，主角团都被打散，一个是 Miles 落入 Miles 之手，一个是 Han 被 Boba 拐走。第二部的故事都在极紧张之后的短暂缓和中落下帷幕，一者是大大的 TO BE CONTINUE，另一者是千年隼的离去，给人留下悬念、不安、期待和微小的希望。</p>
<p>两系列电影的铺垫与伏笔也都做的超级好。</p>
<p>为什么 Miles 希望加入组织时 Gwen 如此紧张？为什么 Owen 始终不让 Luke 与 Obi-Wan 接触？</p>
<p>为什么 Miles 第一次与 Peter 产生感应时他的颜色从紫绿变成红蓝？为什么在洞穴中被击落 Vader 头盔中是 Luke 的脸？</p>
<p>这样的细节超级多，不多讲了。</p>
<p>整体上说的话，其实《黑客帝国》的情节也是这种布局，Neo 的成长啦，第一部结局的<em>相对</em>圆满啦，第二部设下的悬念和 TO BE CONTINUE 啦。</p>
<p>不过毕竟风格不同，相对星战与蜘蛛侠没有那么相似。</p>
<h2 id="我的评分：4-5-5"><a href="#我的评分：4-5-5" class="headerlink" title="我的评分：4.5/5"></a>我的评分：4.5/5</h2><p>应该是 Into the Spider-Verse 之后看过的最好的一部动画电影了（这系列无敌了）。</p>
<p>Daniel的配乐做的也是真厉害，自己认为比上一部还要精彩，特别是最后徘徊者 Miles 出现的那段（Across the Spider-Verse(Start a Band)），在电影院看时感觉超级棒。</p>
<p>画面就不说了，看过都知道。</p>
<p>（有机会下次去三刷。。）</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Dumby的sb日常</category>
      </categories>
      <tags>
        <tag>日常</tag>
        <tag>影视剧</tag>
        <tag>蜘蛛侠</tag>
      </tags>
  </entry>
  <entry>
    <title>UVA10288 优惠券 Coupons</title>
    <url>/2022/UVA10288-%E4%BC%98%E6%83%A0%E5%88%B8-Coupons/</url>
    <content><![CDATA[<p>UVA10288 优惠券 Coupons 题解。</p>
<span id="more"></span>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>简化题意如下：</p>
<p>每次随机取一个 $\left [ 1,n \right ]$ 的整数，问期望几次能够凑齐所有数。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>我们设 $f_{i}$ 为取出第 $i$ 个数期望需要的次数，$p_{i}$ 为取出第 $i$ 个数的概率。</p>
<p>已经取出 $i-1$ 个数，所以 $p_{i}$ 就是 $\frac{n-i+1}{n}$。</p>
<p>我们有个结论：概率为 $p$ 的事件期望 $\frac{1}{p}$ 次后发生。</p>
<p>证明：</p>
<p>设 $E\left( X \right)$ 为发生概率为 $P\left( X \right)$ 的事件 $X$ 发生期望需要的次数。</p>
<p>那么我们有：</p>
<p>$E\left(X\right)=\sum_{i=1}^{\infty } i\left(1-P\right)^{i-1}P$</p>
<p>$E\left(X\right)=P\sum_{i=1}^{\infty } i\left(1-P\right)^{i-1}$</p>
<p>令：</p>
<p>$S= \sum_{i=1}^{\infty}i\left(1-P\right)^{i-1}$</p>
<p>$\therefore S=1+2\left(1-P\right)+3\left(1-P\right)^{2}+…$</p>
<p>$\left(1-P\right)S=\left(1-P\right)+2\left(1-P\right)^{2}+…$</p>
<p>$S-\left(1-P\right)S=1+\left(1-P\right)+\left(1-P\right)^{2}+…$</p>
<p>$P \times S=\frac{1}{1-\left(1-P\right)}=\frac{1}{P}$</p>
<p>$S=\frac{1}{P^{2}}$</p>
<p>$\therefore E\left(X\right)=P\times S=P\times \frac{1}{P^{2}}=\frac{1}{P}$</p>
<p>所以，我们能得到 $f_{i}=\frac{n}{n-i+1}$。</p>
<p>所以取出所有数期望次数 $F={\textstyle \sum_{i=1}^{n}f_{i}}={\textstyle \sum_{i=1}^{n}\frac{n}{n-i+1}}={\textstyle \sum_{i=1}^{n}\frac{n}{i}}$。</p>
<p>根据这个式子计算答案就好了。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> b ? <span class="built_in">gcd</span>(b, a % b) : a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">while</span> (cin &gt;&gt; n) &#123;</span><br><span class="line">		<span class="type">int</span> son = n, mother = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">			son = son * i + n * mother;</span><br><span class="line">			mother *= i;</span><br><span class="line">			<span class="type">int</span> g = <span class="built_in">gcd</span>(son, mother);</span><br><span class="line">			son /= g;</span><br><span class="line">			mother /= g;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//输出部分</span></span><br><span class="line">		<span class="keyword">if</span> (son % mother == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, son / mother);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="type">int</span> c = <span class="built_in">log10</span>(son / mother) + <span class="number">1</span>;</span><br><span class="line">			<span class="type">int</span> c2 = <span class="built_in">log10</span>(mother) + <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= c + <span class="number">1</span>; i++)<span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, son % mother);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>, son / mother);</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= c2; i++)<span class="built_in">printf</span>(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= c + <span class="number">1</span>; i++)<span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, mother);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Dumby的OI生涯</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>DP</tag>
        <tag>概率</tag>
        <tag>期望</tag>
        <tag>线性DP</tag>
      </tags>
  </entry>
  <entry>
    <title>WELCOME TO DUMBLOG</title>
    <url>/2021/WELCOME-TO-DUMBLOG/</url>
    <content><![CDATA[<h2 id="欢迎来到-DUMBLOG"><a href="#欢迎来到-DUMBLOG" class="headerlink" title="欢迎来到 DUMBLOG !"></a>欢迎来到 DUMBLOG !</h2><p>你好你好！！！😀😀😀</p>
<p>欢迎来到 DUMBLOG——Dumby 的博客！！！</p>
<span id="more"></span>
<p>Hello There!!!😀😀😀</p>
<p>Welcome to DUMBLOG, Dumby’s blog!!!</p>
<h2 id="事项"><a href="#事项" class="headerlink" title="事项"></a>事项</h2><p>测试中（2021.6.26），敬请期待。</p>
<p>upd: 启动（2021.9.1）</p>
<p>upd: 翻新（2022.7.3）</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>站务</category>
      </categories>
      <tags>
        <tag>站务</tag>
        <tag>通知</tag>
      </tags>
  </entry>
  <entry>
    <title>csp-s初赛准备：时间复杂度</title>
    <url>/2022/csp-s%E5%88%9D%E8%B5%9B%E5%87%86%E5%A4%87%EF%BC%9A%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</url>
    <content><![CDATA[<p>初赛似乎是必考一题时间复杂度计算，现在在考前抱下佛脚。</p>
<span id="more"></span>
<h2 id="主定理"><a href="#主定理" class="headerlink" title="主定理"></a>主定理</h2><p>给定这样一个式子：</p>
<p>$T \left ( n \right ) = a T\left ( \frac{n}{b}  \right )+ n^{d}P$</p>
<p>其中 $P$ 表示一个式子，通常 $P=\log^{k}{n},k \ge 0$，如 $T \left ( n \right ) = 2 T\left ( \frac{n}{2}  \right )+ n\log{n}$ 时，则 $d=1, P=log{n}$</p>
<p>然后分三种情况：</p>
<ol>
<li>$n^{\log_{b}{a}} &gt; n^{d}$，则 $T \left ( n \right ) = n^{\log_{b}{a}}$</li>
<li>$n^{\log_{b}{a}} &lt; n^{d}$，则 $T \left ( n \right ) = n^{d}$</li>
<li>$n^{\log_{b}{a}} = n^{d}$，当 $P=\log^{k}{n}$ 时，即后面带的那个式子是 $n^{d}\log^{k}{n}$ 时，$T \left ( n \right ) = n^{d}\log^{k+1}{n}$</li>
</ol>
<p>这样初赛中绝大多数时间复杂度题应该都能过了。</p>
<h2 id="递归、递归树"><a href="#递归、递归树" class="headerlink" title="递归、递归树"></a>递归、递归树</h2><p>最好懂最无脑，考场上时间够可以用这个。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Dumby的OI生涯</category>
      </categories>
      <tags>
        <tag>初赛</tag>
        <tag>时间复杂度</tag>
        <tag>主定理</tag>
      </tags>
  </entry>
  <entry>
    <title>Иди и смотри</title>
    <url>/2023/%D0%98%D0%B4%D0%B8-%D0%B8-%D1%81%D0%BC%D0%BE%D1%82%D1%80%D0%B8/</url>
    <content><![CDATA[<p>And I saw when the Lamb opened one of the seals, and I heard, as it were the noise of thunder, one of the four beasts saying, <strong>Come and see</strong>.</p>
<span id="more"></span>
<p><img src="海报.jpg" alt="海报" title="海报"></p>
<p>And I saw, and behold a white horse: and he that sat on him had a bow; and a crown was given unto him: and he went forth conquering, and to conquer.</p>
<p><em>All these are the beginning of sorrows.</em></p>
<p><img src="一.png" alt="一" title="一"></p>
<p>And when he had opened the second seal, I heard the second beast say, <strong>Come and see</strong>.</p>
<p>And there went out another horse that was red: and power was given to him that sat thereon to take peace from the earth, and that they should kill one another: and there was given unto him a great sword.</p>
<p><em>For nation shall rise against nation, and kingdom against kingdom.</em></p>
<p><img src="二.png" alt="二" title="二"></p>
<p>And when he had opened the third seal, I heard the third beast say, <strong>Come and see</strong>. And I beheld, and lo a black horse; and he that sat on him had a pair of balances in his hand.</p>
<p>And I heard a voice in the midst of the four beasts say, A measure of wheat for a penny, and three measures of barley for a penny; and see thou hurt not the oil and the wine.</p>
<p><em>And there shall be famines.</em></p>
<p><img src="三.png" alt="三" title="三"></p>
<p>And when he had opened the fourth seal, I heard the voice of the fourth beast say, <strong>Come and see</strong>.</p>
<p>And I looked, and behold a pale horse: and his name that sat on him was Death, and Hell followed with him. And power was given unto them over the fourth part of the earth, to kill with sword, and with hunger, and with death, and with the beasts of the earth.</p>
<p><em>And famines, and pestilences.</em></p>
<p><img src="四.png" alt="四" title="四"></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Dumby的sb日常</category>
      </categories>
      <tags>
        <tag>日常</tag>
        <tag>影视剧</tag>
        <tag>战争</tag>
      </tags>
  </entry>
  <entry>
    <title>“学习互助小组”</title>
    <url>/2025/%E2%80%9C%E5%AD%A6%E4%B9%A0%E4%BA%92%E5%8A%A9%E5%B0%8F%E7%BB%84%E2%80%9D/</url>
    <content><![CDATA[<p>今日第二贴。继续吐槽。以下语言激烈，请酌情阅读。</p>
<span id="more"></span>
<p>我开牛魔的班会，班会讲啥了我靠，除了浪费时间一点用没有。</p>
<p>黄主任还是厉害，晚来这么久原来是攒了波大的😅。上来就是废话，叽里呱啦咿咿呀呀的。讲了一堆废话以后得出结论：<br>我们应该成立学习互助小组！</p>
<p>真是糖的没边了bro，这b东西初中搞，高中搞，哪次tm有用了？</p>
<p>我真搞不明白了为什么同样是上大学为什么就tm个b我p事会这么多。</p>
<p>用好友刺的话来说，这种老鼠建议直接问他发达了以后会不会去帮自己的穷亲戚。🤣</p>
<p>在蝇州养猪场，你只要库库吃然后变肥就好了。</p>
<p>在这里，你得耍着马戏、跳着舞、唱着歌、和别人绑在一起并且库库吃然后变肥。</p>
<p>算了算了，差不多得了。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Dumby的sb日常</category>
      </categories>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title>《安多 第二季》剧评</title>
    <url>/2025/%E3%80%8A%E5%AE%89%E5%A4%9A-%E7%AC%AC%E4%BA%8C%E5%AD%A3%E3%80%8B%E5%89%A7%E8%AF%84/</url>
    <content><![CDATA[<p>最近安多第二季上线，写写观感顺便说说前段时间看的剧。</p>
<span id="more"></span>
<h2 id="安多"><a href="#安多" class="headerlink" title="安多"></a>安多</h2><p>先说安多。因为是一集一集看的，就挑点有意思的写写。</p>
<h3 id="第一集"><a href="#第一集" class="headerlink" title="第一集"></a>第一集</h3><p>先是上来就是一个看着让人很难不往zzzq上面想的女反抗军（不知道算不算得上反抗军，一下词穷了），不过考虑到其背景是平凡地勤出身，也可以理解。</p>
<p>后面好几条线切换，印象最深刻的是这个：</p>
<p><img 
  src="鱼人.jpg" 
  alt="这人长得像金龙鱼" 
  title="还有鱼人？"
></p>
<p>就是说，鱼人也能进国安局了吗？</p>
<p>其他整体节奏还是偏慢的，感觉像第一季的开头那样，不过还是挺吸引人的，虽然写这个的时候我还没看第二集（倒是把爱情公寓第一季看完了🤓）。</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>额，我发现不能按照每集来写，因为一口气把剩下的全看完了。😳</p>
<p>先说结论：这是星战<strong>最高光</strong>的剧集，这部剧证明了星战的无限活力，同时也证明了迪士尼还是有活人的。</p>
<p>作为历史第一次IMDB连续五集9.5以上的剧集，安多可以说是这几年最强的美剧之一了。</p>
<p>演员演技相当不错，特别那个金龙鱼。</p>
<p>四年的跨度无缝衔接侠盗一号的开头，侠盗一号又无缝衔接新希望，我都不敢想一口气看完会有多爽。</p>
<h3 id="众生相"><a href="#众生相" class="headerlink" title="众生相"></a>众生相</h3><p>义军建立在希望之上，而希望则是承载在每一个反抗者身上。</p>
<p>主角们自然是令人印象深刻的——安多，卢森，南大——但棋盘上的每个棋子都是至关重要：克莱亚，辛达，朗尼等等。</p>
<p>自然需要有人去抛头露面，如南大般去号召人们奋起反抗；但像朗尼杨格这样在帝国间谍多年最后死于卢森手下的抗压怪也是必不可少的。</p>
<p><strong>“帝国是从黑暗中滋生的瘟疫”“反抗的战线无处不在”“我到处都有朋友”“真相的死亡就是邪恶的最终胜利”</strong></p>
<p>没有了the Chosen One，剩下的只有Everyone。</p>
<p>一边是正在崛起的义军，而另一边则是强大黑暗的帝国。</p>
<p>这部剧里并没有把义军与帝国的矛盾集中到皇帝和维达以及他们手下强大的军队上，而是放在了ISB这样结构严密的机构和金龙鱼那样高效缜密的官僚上。</p>
<p>如我三年前在<a href="/2022/11/27/《安多》不短的评/">《安多》不短的评</a>中说的，“星星之火”，放到这部剧中来说挺合适的。这部剧让星战这系列“太空歌剧”带上了更多的现实主义的味道，它才是我心目中的《义军崛起》。</p>
<h3 id="我的评分：⭐⭐⭐⭐⭐（5-5）"><a href="#我的评分：⭐⭐⭐⭐⭐（5-5）" class="headerlink" title="我的评分：⭐⭐⭐⭐⭐（5/5）"></a>我的评分：⭐⭐⭐⭐⭐（5/5）</h3><p>这是真神了。</p>
<p>下面是这段时间看的一些其他的星战的剧。</p>
<h2 id="骨干小队"><a href="#骨干小队" class="headerlink" title="骨干小队"></a>骨干小队</h2><p>对于一部儿童片来说，还算合格，从小孩的逻辑来说很多地方是讲的通顺的。但是有点太过家家了，而且我不是小登了已经🤔。</p>
<p>给分3.5/5。</p>
<h2 id="异等小队第二季"><a href="#异等小队第二季" class="headerlink" title="异等小队第二季"></a>异等小队第二季</h2><p>除了最后几集，前面真的无聊。</p>
<p>给分4/5。</p>
<h2 id="异等小队第三季"><a href="#异等小队第三季" class="headerlink" title="异等小队第三季"></a>异等小队第三季</h2><p>不错不错。回归文姐是真帅吧，贝恩是真帅吧，老头Hunter也挺帅吧。</p>
<p>给分4.5/5。</p>
<h2 id="侍者"><a href="#侍者" class="headerlink" title="侍者"></a>侍者</h2><p>真屎。（这其实是去年看的了）</p>
<p>给分1.5/5。</p>
<h2 id="黑市传说"><a href="#黑市传说" class="headerlink" title="黑市传说"></a>黑市传说</h2><p>前三集小绝地糖完了，带娃带娃带牛魔的娃。</p>
<p>后三集还行，整体观感算不上很好。</p>
<p>情节好多莫名其妙的。</p>
<p>不过文姐是真帅吧，贝恩是真帅吧。</p>
<p>看在文姐和贝恩的面子上给分3.5/5。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Dumby的sb日常</category>
      </categories>
      <tags>
        <tag>日常</tag>
        <tag>星球大战</tag>
        <tag>影视剧</tag>
      </tags>
  </entry>
  <entry>
    <title>《安多》不短的评</title>
    <url>/2022/%E3%80%8A%E5%AE%89%E5%A4%9A%E3%80%8B%E4%B8%8D%E7%9F%AD%E7%9A%84%E8%AF%84/</url>
    <content><![CDATA[<p>最近二刷完《安多》，随便说几句。</p>
<span id="more"></span>
<p>放张镇帖图先。</p>
<p><img src="Andor.jpg" alt="镇帖图" title="镇帖图"></p>
<p>反正是随便说几句就<strong>想说啥说啥</strong>了。</p>
<p><strong>以下纯属个人基于剧集的口嗨和猜测。别杠，杠就是你对</strong></p>
<h2 id="情节"><a href="#情节" class="headerlink" title="情节"></a>情节</h2><p>本剧个人认为叙事比较开阔，它不仅仅像是曼达洛人前两部那样只写主角一条线，《安多》这部剧从安多本身出发，拓展出很多义军成立前的一个个反帝的小个体小组织。</p>
<p>但他又并非是《义军崛起》那样（不过《义军崛起》基本也是主角团一条线），《安多》的格局显然要开阔很多。</p>
<p>这部剧已经有些脱离个人英雄主义的味道了，“星星之火”，放到这部剧中来说挺合适的。</p>
<p>分别看看每个人：</p>
<p>先看看安多个人。</p>
<p>安多曾是一个克纳里的小毛孩，被玛尔瓦带走后见证了许多事，包括国家底层人民的艰难的生活、小偷小摸的事情、战争以及对安多很重要的事件克莱姆之死。<br>从卢森来费里克斯摇走安多开始，安多从逃出费里克斯时的些许迷茫，不敢肯定自己、不愿加入卢森的小团体；到抢完一票后，受内米克的影响，渐渐醒悟；再到越狱后更深刻地明白帝国的黑暗；最后在费里克斯受母亲一番话（虽然是讲给全费里克斯的），坚定地成为了青年反帝战士（:P）。</p>
<p>再看看安多他娘玛尔瓦。</p>
<p>。。。（算了懒得码字了，我是懒批。。。）</p>
<p>还有内米克，以及卢森和南大。</p>
<p>。。。（😓😓😓）</p>
<p>总之，用内米克的话来形容这部剧：</p>
<blockquote>
<p>There will be times when the struggle seems impossible.<br>I know this already.<br>Alone, unsure, dwarfed by the scale of the enemy.<br>Remember this.<br><strong>Freedom is a pure idea.</strong><br>It occurs spontaneously and without instruction.<br>Random acts of insurrection are occurring constantly throughout the galaxy.<br>There are whole armies, battalions that have no idea that they’ve already enlisted in the cause.<br>Remember that the frontier of the <strong>Rebellion</strong> is everywhere.<br>And even the smallest act of insurrection pushes our lines forward.<br>And then remember this.<br>The Imperial need for control is so desperate because it is so unnatural.<br>Tyranny requires constant effort.<br>It breaks, it leaks.<br>Authority is brittle.<br>Oppression is the mask of fear.<br>Remember that.<br>And know this, the day will come when all these skirmishes and battles, these moments of defiance will have flooded the banks of the Empire’s authority and then there will be one too many.<br>One single thing will break the siege.<br><strong>Remember this. Try.</strong></p>
</blockquote>
<p>个人认为这部剧让星战这系列“太空歌剧”带上了更多的现实主义的味道，它才是我心目中的《义军崛起》。</p>
<h2 id="视觉效果"><a href="#视觉效果" class="headerlink" title="视觉效果"></a>视觉效果</h2><p>我相当外行，以下只是随口扯几句。</p>
<p>有个地方挺明显的，就是在科洛桑或者帝国设施内的色调和其他地方比如费里克斯一冷一暖对比是挺强烈的：</p>
<p>帝国：</p>
<p><img src="议会.jpg" alt="议会" title="议会"></p>
<p><img src="监狱.jpg" alt="监狱" title="监狱"></p>
<p><img src="ISB.jpg" alt="ISB" title="ISB"></p>
<p><img src="IBS.jpg" alt="IBS" title="IBS"></p>
<p>费里克斯：</p>
<p><img src="费里克斯1.jpg" alt="费里克斯" title="费里克斯"></p>
<p><img src="费里克斯2.jpg" alt="费里克斯" title="费里克斯"></p>
<p><img src="费里克斯3.jpg" alt="费里克斯" title="费里克斯"></p>
<h2 id="我的评分：⭐⭐⭐⭐⭐（5-5）"><a href="#我的评分：⭐⭐⭐⭐⭐（5-5）" class="headerlink" title="我的评分：⭐⭐⭐⭐⭐（5/5）"></a>我的评分：⭐⭐⭐⭐⭐（5/5）</h2><p>（有空去三刷。。）</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Dumby的sb日常</category>
      </categories>
      <tags>
        <tag>日常</tag>
        <tag>星球大战</tag>
        <tag>影视剧</tag>
      </tags>
  </entry>
  <entry>
    <title>一个大学生为什么能这么疲惫与无力</title>
    <url>/2025/%E4%B8%80%E4%B8%AA%E5%A4%A7%E5%AD%A6%E7%94%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%83%BD%E8%BF%99%E4%B9%88%E7%96%B2%E6%83%AB%E4%B8%8E%E6%97%A0%E5%8A%9B/</url>
    <content><![CDATA[<p>我要吐槽。</p>
<span id="more"></span>
<p>大学毕竟是走进社会前的最后一步嘛，有意无意间就会隐隐露出我是社畜的痛感。</p>
<p>开会开会，这的那的一堆破事搞不好，一堆莫名其妙的规定，一堆总是能让你糟心的小事。我寻思这去打工了也不用上早自习啊？😅</p>
<p>最近几天情绪真的很不稳定了，不过说回来也算很稳定了，稳定的烦躁焦虑和疲惫。每天都有很浓重一股无力感，无奈感和失落感缠绕着。</p>
<p>。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Dumby的sb日常</category>
      </categories>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title>《杀死一只知更鸟》短评</title>
    <url>/2023/%E3%80%8A%E6%9D%80%E6%AD%BB%E4%B8%80%E5%8F%AA%E7%9F%A5%E6%9B%B4%E9%B8%9F%E3%80%8B%E7%9F%AD%E8%AF%84/</url>
    <content><![CDATA[<p>不想多写，就写一句话好了。</p>
<p>这本书从相当天真的视角，挖掘了相当深刻的主题。值得一读。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Dumby的sb日常</category>
      </categories>
      <tags>
        <tag>日常</tag>
        <tag>书籍</tag>
      </tags>
  </entry>
  <entry>
    <title>修钢笔捏</title>
    <url>/2022/%E4%BF%AE%E9%92%A2%E7%AC%94%E6%8D%8F/</url>
    <content><![CDATA[<p>修笔捏。</p>
<span id="more"></span>
<p>这支笔不知道什么时候的，也不知道牌子，只知道拼音是 “JinYi”。</p>
<p>好多地方坏了，开个贴慢慢修。</p>
<p><img src="开搞.png" alt="开搞" title="开搞"></p>
<p><img src="笔帽部分.png" alt="从笔帽开始" title="从笔帽开始"></p>
<p>左英雄616右JinYi。</p>
<p>今天尝试修一下笔帽部分。</p>
<p>笔帽最主要就里面一个密封的东西破了个洞，想办法把它搞好。</p>
<p>发现616的密封件和JinYi很像：</p>
<p><img src="对比.png" alt="两者密封件很像" title="两者密封件很像"></p>
<p>左616右JinYi。</p>
<p><img src="装.png" alt="JinYi的笔顶也能装到616上" title="JinYi的笔顶也能装到616上"></p>
<p>发现JinYi的笔顶也能装到616上。</p>
<p>于是把616的那个装到JinYi的笔帽上，但发现太松了笔根本盖不上。。</p>
<p><img src="盖不上.png" alt="盖不上" title="盖不上"></p>
<p>想到原来的JinYi密封件上有个固定用的东西，把它装到616密封件上。</p>
<p><img src="616.png" alt="装到616上" title="装到616上"></p>
<p>然后发现塞不进JinYi的笔帽。。。</p>
<p><img src="塞不下.png" alt="塞不下" title="塞不下"></p>
<p>于是乎，仿照原来JinYi密封件的样子把616密封件削掉几块。</p>
<p><img src="削.png" alt="削掉几块" title="削掉几块"></p>
<p>然后发现：</p>
<p><img src="还是塞不下.png" alt="还是塞不下" title="还是塞不下"></p>
<p>还是塞不下。。。</p>
<p>寄。。。</p>
<p>~未完~</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Dumby的sb日常</category>
      </categories>
      <tags>
        <tag>日常</tag>
        <tag>钢笔</tag>
      </tags>
  </entry>
  <entry>
    <title>关于博客服务器被黑的事情</title>
    <url>/2022/%E5%85%B3%E4%BA%8E%E5%8D%9A%E5%AE%A2%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%A2%AB%E9%BB%91%E7%9A%84%E4%BA%8B%E6%83%85/</url>
    <content><![CDATA[<p>2022年10月4日23时54分，我收到一封邮件。这件事就从这个邮件开始。</p>
<span id="more"></span>
<p>邮件全文如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">发件人：Melanie Peitz&lt;kontakt@smartemotions.de&gt; (由 sh-642160441@eu.hosting-webspace.io 代发)</span><br><span class="line">收件人：我&lt;*****@**.com&gt;</span><br><span class="line">时  间：2022年10月04日 23:54 (星期二)</span><br><span class="line"></span><br><span class="line">---------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">Hallo Henry Tighe,</span><br><span class="line"></span><br><span class="line">dies ist eine automatische Bestätigung, dass deine Nachricht bei mir angekommen ist.</span><br><span class="line"></span><br><span class="line">Ich melde mich schnellstmöglich bei dir.</span><br><span class="line"></span><br><span class="line">Viele Grüße</span><br><span class="line">Melanie Peitz</span><br><span class="line"></span><br><span class="line">Impressum</span><br><span class="line">Dr. Melanie Peitz</span><br><span class="line">Coaching und Beratung</span><br><span class="line">Berger Weg 5a</span><br><span class="line">45549 Sprockhövel</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Telefon: 0160 60 87 661</span><br><span class="line">eMail:   kontakt@smartemotions.de</span><br><span class="line"></span><br><span class="line">Hier der Inhalt deiner Nachricht:</span><br><span class="line"></span><br><span class="line">Name</span><br><span class="line"></span><br><span class="line">    Henry Tighe</span><br><span class="line"></span><br><span class="line">Nachricht</span><br><span class="line"></span><br><span class="line">    Your Site Has Been Hacked</span><br><span class="line"></span><br><span class="line">    PLEASE FORWARD THíS EMAiL TO SOMEONE íN YOUR COMPANY WHO íS ALLOWED TO MAKE iMPORTANT DECíSiONS!</span><br><span class="line"></span><br><span class="line">    We have hacked your websíte https://dumblog.top and extracted your databases.</span><br><span class="line"></span><br><span class="line">    How did this happen?</span><br><span class="line"></span><br><span class="line">    Our team has found a vulnerabílity within your site that we were able to exploit. After fínding the vulnerabilíty we were able to get your database credentíals and extract your entire database and move the informatíon to an offshore server.</span><br><span class="line"></span><br><span class="line">    What does thís mean?</span><br><span class="line"></span><br><span class="line">    We will systematícally go through a series of steps of totally damaging your reputation. Fírst your database wíll be leaked or sold to the highest bidder whích they will use wíth whatever theír intentíons are. Next íf there are e-mails found they wíll be e-mailed that their ínformatíon has been sold or leaked and your site https://dumblog.top was at fault thusly damaging your reputatíon and havíng angry customers/assocíates with whatever angry customers/assocíates do. Lastly any línks that you have indexed in the search engínes will be de-indexed based off of blackhat techníques that we used ín the past to de-índex our targets.</span><br><span class="line"></span><br><span class="line">    How do í stop this?</span><br><span class="line"></span><br><span class="line">    We are wílling to refrain from destroyíng your site’s reputatíon for a small fee. The current fee ís $3000 in bitcoins (BTC).</span><br><span class="line"></span><br><span class="line">    Please send the bitcoin to the followíng Bítcoín address (Make sure to copy and paste):</span><br><span class="line"></span><br><span class="line">    bc1q7vyvktqpgex0pqrzktvyuyu07fcafqst8m7ch9</span><br><span class="line"></span><br><span class="line">    Once you have paid we wíll automatícally get informed that it was your payment. Please note that you have to make payment wíthin 5 days after receiving thís e-maíl or the database leak, e-mails díspatched, and de-índex of your site WiLL start!</span><br><span class="line"></span><br><span class="line">    How do í get Bítcoins?</span><br><span class="line"></span><br><span class="line">    You can easily buy bitcoíns vía several websites or even offline from a Bítcoín-ATM.</span><br><span class="line"></span><br><span class="line">    What if i don’t pay?</span><br><span class="line"></span><br><span class="line">    íf you decide not to pay, we will start the attack at the indícated date and uphold ít until you do, there’s no counter measure to thís, you will only end up wastíng more money tryíng to fínd a solutíon. We wíll completely destroy your reputation amongst google and your customers.</span><br><span class="line"></span><br><span class="line">    Thís ís not a hoax, do not reply to this email, don’t try to reason or negotíate, we wíll not read any replíes. Once you have paid we will stop what we were doing and you wíll never hear from us again!</span><br><span class="line"></span><br><span class="line">    Please note that Bitcoín ís anonymous and no one will find out that you have complied.</span><br><span class="line"></span><br><span class="line">E-Mail</span><br><span class="line"></span><br><span class="line">    *****@**.com</span><br><span class="line"></span><br><span class="line">Auswahl</span><br><span class="line"></span><br><span class="line"> 	Ich interessiere mich unverbindlich für dein Coaching-Angebot</span><br></pre></td></tr></table></figure>
<p>翻译如下（机翻）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">你好，Henry Tighe，</span><br><span class="line"></span><br><span class="line">这是一个自动确认，您的消息已经到达我的手中。</span><br><span class="line"></span><br><span class="line">我会尽快和你联系的。</span><br><span class="line"></span><br><span class="line">诚挚的问候。</span><br><span class="line">Melanie Peitz</span><br><span class="line"></span><br><span class="line">公司信息</span><br><span class="line">Melanie Peitz博士</span><br><span class="line">辅导和咨询</span><br><span class="line">Berger Weg 5a</span><br><span class="line">45549 Sprockhövel</span><br><span class="line"></span><br><span class="line">电话：01606087661</span><br><span class="line">电子邮件：kontakt@Smartemotions.de</span><br><span class="line"></span><br><span class="line">以下是您的信息内容：</span><br><span class="line"></span><br><span class="line">名字</span><br><span class="line"></span><br><span class="line">    Henry Tighe</span><br><span class="line"></span><br><span class="line">消息</span><br><span class="line"></span><br><span class="line">    您的站点已被黑客攻击。</span><br><span class="line"></span><br><span class="line">    请将这封电子邮件转发给贵公司中被允许做出重要决策的人！</span><br><span class="line"></span><br><span class="line">    我们已经入侵了你的网站 https://dumblog.top 并提取了你的数据库。</span><br><span class="line"></span><br><span class="line">    怎么会出这事？</span><br><span class="line"></span><br><span class="line">    我们的团队在您的站点中发现了一个我们能够利用的漏洞。在发现漏洞后，我们能够获得您的数据库凭据，提取整个数据库，并将信息移动到离岸服务器。</span><br><span class="line"></span><br><span class="line">    这是什么意思？</span><br><span class="line"></span><br><span class="line">    我们将系统地经历一系列完全损害您声誉的步骤。首先，你的数据库将被泄露或出售给出价最高的竞标者，他们将使用这些数据库，无论他们的意图是什么。接下来，如果发现电子邮件，他们将收到电子邮件，告知他们的信息已被出售或泄露，因此您的网站 https://dumblog.top 有过错，从而损害了您的声誉，并导致愤怒的客户/同事做出任何愤怒的客户/同事的行为。最后，您在搜索引擎中索引的任何链接都将基于我们过去用来对目标进行索引的BlackHat技术进行去索引。</span><br><span class="line"></span><br><span class="line">    我怎么才能阻止这一切？</span><br><span class="line"></span><br><span class="line">    我们愿意避免为了一小笔费用而破坏您网站的声誉。目前的费用为3,000美元比特币(BTC)。</span><br><span class="line"></span><br><span class="line">    请将比特币发送到以下比特币地址(请务必复制并粘贴)：</span><br><span class="line"></span><br><span class="line">    Bc1q7vyvktqpgex0pqrzktwyuyu07fafqst8m7ch9。</span><br><span class="line"></span><br><span class="line">    一旦您付款，我们将自动得到通知，这是您的付款。请注意，您必须在收到此电子邮件或数据库泄漏后5天内付款，发送的电子邮件和您的网站将开始去索引！</span><br><span class="line"></span><br><span class="line">    我怎样才能得到比特币？</span><br><span class="line"></span><br><span class="line">    你可以很容易地通过几个网站购买比特币，甚至可以通过比特币自动取款机离线购买。</span><br><span class="line"></span><br><span class="line">    如果我不付钱呢？</span><br><span class="line"></span><br><span class="line">    如果你决定不付款，我们将在指定的日期开始攻击，并支持它，直到你这样做，没有任何反措施，你最终只会浪费更多的钱试图找到解决方案。我们将彻底摧毁你在谷歌和你的客户中的声誉。</span><br><span class="line"></span><br><span class="line">    这不是恶作剧，不要回复这封邮件，不要试图推理或谈判，我们不会读任何回复。一旦你付了钱，我们将停止我们正在做的事情，你将永远不会再听到我们的消息！</span><br><span class="line"></span><br><span class="line">    请注意，比特币是匿名的，没有人会发现你遵守了规定。</span><br><span class="line"></span><br><span class="line">邮箱</span><br><span class="line"></span><br><span class="line">    *****@**.com</span><br><span class="line"></span><br><span class="line">选择</span><br><span class="line"></span><br><span class="line">    我对你提供的无义务指导很感兴趣</span><br></pre></td></tr></table></figure>
<p>看上去很有来头，可是一个静态博客怎么会有数据库捏？</p>
<p>如果黑到服务器上，那就雨我无瓜了，反正是 Vercel 的服务器。</p>
<p>🤓</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>站务</category>
      </categories>
      <tags>
        <tag>站务</tag>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>利用拓扑排序求 DAG 最短路</title>
    <url>/2022/%E5%88%A9%E7%94%A8%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E6%B1%82-DAG-%E6%9C%80%E7%9F%AD%E8%B7%AF/</url>
    <content><![CDATA[<p>本文介绍如何用拓扑排序来求 DAG 最短路（内附代码实现）。</p>
<span id="more"></span>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>给定一张带负权边的有向无环图（DAG），$N$ 个点，$M$ 条边，求源点到各点的最短路。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>因为有负权边，无法用 dijkstra 直接求最短路。</p>
<p>用 SPFA 又容易被出题人卡成<strong>傻子</strong>。</p>
<p>考虑到是 <strong>DAG</strong>，可以使用<strong>拓扑排序</strong>在 $O\left( N+M \right)$ 时间范围内求出最短路。</p>
<p>步骤如下：</p>
<p>设源点为 $s$，点到源点的最短路用数组 $d[]$ 来储存，建一个队列 $q[]$ 给拓扑排序用，再建一个数组 $deg[]$ 用来存储每个点的入度。</p>
<p>初始化：将除了 $d[s]$ 以外的所有 $d[]$ 赋值为 $+\infty$，$d[s]$ 赋值为 $0$，队列 $q[]$ 为空，提前处理出每个点的 $deg$。</p>
<p>一、找出<strong>所有入度为 $0$ 的节点</strong>加入队列 $q[]$。</p>
<p>二、取出队首节点，设队首节点为 $p$，该点指向的点为 $j$，两点间的边的边权为 $w$。</p>
<p>三、将 $deg[j]$ 减一（删边），并用 $d[p]+w$ 来更新 $d[j]$。若 $deg[j]$ 被减为零，则让 $j$ 入队。</p>
<p>重复二到三，直到所有点的 $deg[]$ 都变成 $0$，即所有点都被访问过（此时队空）。</p>
<p>过程中所有的点和边都只被扫描了一次，时间复杂度为 $O\left( N+M \right)$。</p>
<p>其实仔细看整个过程会发现<strong>这就是在拓扑排序模板上加了一小点东西，也是在 SPFA 模板上加了一小点东西</strong>。</p>
<h2 id="喜闻乐见，代码时间"><a href="#喜闻乐见，代码时间" class="headerlink" title="喜闻乐见，代码时间"></a>喜闻乐见，代码时间</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">114514</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,m,s;</span><br><span class="line"><span class="type">int</span> h[N],nxt[N],to[N],w[N],cn;</span><br><span class="line"><span class="type">int</span> d[N];</span><br><span class="line"><span class="type">int</span> deg[N];</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="comment">//变量名与前面一一对应</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">	to[++cn]=b;</span><br><span class="line">	w[cn]=c;</span><br><span class="line">	nxt[cn]=h[a];</span><br><span class="line">	h[a]=cn;</span><br><span class="line">	deg[b]++;<span class="comment">//在加边时顺便将 deg[] 处理出来</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">topsort</span><span class="params">(<span class="type">int</span> s)</span></span>&#123;<span class="comment">//拓扑排序，长得几乎和 SPFA 一模一样</span></span><br><span class="line">	<span class="built_in">memset</span>(d,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> d);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!deg[i])q.<span class="built_in">push</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	d[s]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">		<span class="type">int</span> p=q.<span class="built_in">front</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=h[p];i;i=nxt[i])&#123;</span><br><span class="line">			<span class="type">int</span> j=to[i];</span><br><span class="line">			d[j]=<span class="built_in">min</span>(d[j],d[p]+w[i]);</span><br><span class="line">			<span class="keyword">if</span>(--deg[j]==<span class="number">0</span>)q.<span class="built_in">push</span>(j);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;s);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		<span class="type">int</span> a,b,c;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">		<span class="built_in">add</span>(a,b,c);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">topsort</span>(s);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,d[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>${\Huge \mathfrak{The\  End}}$</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Dumby的OI生涯</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>拓扑排序</tag>
        <tag>图论</tag>
        <tag>DAG</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>博客在线更新指北</title>
    <url>/2022/%E5%8D%9A%E5%AE%A2%E5%9C%A8%E7%BA%BF%E6%9B%B4%E6%96%B0%E6%8C%87%E5%8C%97/</url>
    <content><![CDATA[<p>利用 Vercel+Github 通过一些歪门邪道实现 Hexo 静态博客的在线更新。</p>
<span id="more"></span>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>之前一直觉得 Hexo 最大的缺点就是更新只能在本地，实在是不方便。</p>
<p>后来学会通过多台机子实现hexo分支同步的方法，但也需要将源代码载到本地。而且这个方法需要使用者的电脑上装有 Node.js 和 Git 环境，而最烦的地方就在这里。我许多时候用的都是学校机房的电脑，系统 win7，还带还原卡，环境配置很麻烦，每次都要重来。而且我自己的电脑是 win10，每次换地方更新时都要修改博客的配置（win7和win10间转换），非常麻烦。</p>
<p>由于我的博客是在Vercel上部署的，之前就想能不能用它来实现在线更新，但一直没成功，今天终于通过一些歪门邪道实现了。</p>
<h2 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h2><p>首先，博客需要有一个在Github上的源码仓库。这里的分支是 <code>hexo</code>。</p>
<p>然后，在Vercel中创建一个新项目，从Github中导入，选择博客的源码仓库，<code>FRAMEWORK PRESET</code> 选择 Other（或者 Hexo，这里建议选Other，因为选Hexo经常会有hexo g命令失效的问题，非常麻烦，other就不会有），然后直接 Deploy。</p>
<p>之后Vercel会自动部署生成博客，点Visit可访问。</p>
<p>前面这些都是常规操作，还有什么改域名之类的，不属于今天的讨论范围。</p>
<p>接下来是重点，骚操作开始了。</p>
<h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><p>首先在Github的源码仓库中更新文章，不管是删除、新增还是修改都可以。</p>
<p><img src="更新文章.PNG" alt="更新文章" title="更新文章"></p>
<p>保存后，Vercel 应该会检测到修改然后自动部署一遍。</p>
<p><strong>但是</strong>，它自动部署后，我们更新的文章<strong>并不会</strong>出现在部署出的博客中。</p>
<p>接下来，打开Vercel的这个界面，我们发现底下的Preview Deployments栏中有一个最新的Deployment。</p>
<p><img src="Deployment.PNG" alt="最新的Deployment" title="最新的Deployment"></p>
<p>点击那条Deployment最右边的三个点，选择Promote to Production。</p>
<p><img src="三个点.PNG" alt="三个点" title="三个点"></p>
<p>再点击 Promote to Production 之后Vercel应该又会自动Deploy一次，这次部署完之后，进入博客你就会发现，文章更新了！！！</p>
<p>于是在线更新就成功实现了。</p>
<p>虽然有点歪门邪道，我也不确定会不会有什么缺点和漏洞，但是我也是刚自己摸出来这个方法，就写篇博客记录下好了。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Dumby的折腾笔记</category>
      </categories>
      <tags>
        <tag>站务</tag>
      </tags>
  </entry>
  <entry>
    <title>合成器Global讲解</title>
    <url>/2022/%E5%90%88%E6%88%90%E5%99%A8Global%E8%AE%B2%E8%A7%A3/</url>
    <content><![CDATA[<p>本帖用于介绍合成器的Global面板。</p>
<span id="more"></span>
<p>首先看下 Serum 中的 Global 面板：</p>
<p><img src="Serum中的Global面板.png" alt="Serum中的Global面板" title="Serum中的Global面板"></p>
<p>先看下这几个东西：quality（声音质量）、tune（音高）、bpm（速度）。</p>
<p>这三东西是绝大多数合成器的global中都有的。</p>
<h3 id="Quality（声音质量）"><a href="#Quality（声音质量）" class="headerlink" title="Quality（声音质量）"></a>Quality（声音质量）</h3><p>通常声音质量越高要求的性能越大。</p>
<p>它在Serum中的这个位置：</p>
<p><img src="质量.png" alt="声音质量" title="声音质量"></p>
<h3 id="Tune（音高）"><a href="#Tune（音高）" class="headerlink" title="Tune（音高）"></a>Tune（音高）</h3><p>标准音高是 A（小字一组a），即 440Hz。</p>
<p>它在Serum中的这个位置：</p>
<p><img src="音高.png" alt="音高" title="音高"></p>
<h3 id="BPM（速度）"><a href="#BPM（速度）" class="headerlink" title="BPM（速度）"></a>BPM（速度）</h3><p>大部分合成器的BPM是与宿主的BPM绑定的。</p>
<p>应该都知道BPM是什么这里就不多说了。</p>
<p>之后会详细讲一下Serum的global面板，这里先讲到这（本来也没什么好说的）。</p>
<p>参考：</p>
<ul>
<li><a href="https://www.bilibili.com/video/BV1Ys411i7hF">B站UP主@AndreChen的教学视频 “【合辑】【合成器基础教学】入门/通用/必备知识——Abletive教学视频站”</a></li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Dumby的折腾笔记</category>
      </categories>
      <tags>
        <tag>合成器</tag>
      </tags>
  </entry>
  <entry>
    <title>已是2025</title>
    <url>/2025/%E5%B7%B2%E6%98%AF2025/</url>
    <content><![CDATA[<p>各位新年好啊。</p>
<p>vivo50新年有好运！😜😜</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>站务</category>
      </categories>
      <tags>
        <tag>站务</tag>
        <tag>通知</tag>
      </tags>
  </entry>
  <entry>
    <title>并查集学习笔记</title>
    <url>/2021/%E5%B9%B6%E6%9F%A5%E9%9B%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>学习下并查集及其常规操作（内附代码实现）。</p>
<span id="more"></span>
<h2 id="并查集是甚么"><a href="#并查集是甚么" class="headerlink" title="并查集是甚么"></a>并查集是甚么</h2><p>并查集（Disjoint-set data structure），直译为 <strong>“不交集数据结构”</strong>，顾名思义，它是种数据结构。并且，它是种用来处理 <strong>不交集（不相交集合）的合并和查询问题</strong> 的数据结构。<br>并查集维护的是<strong>元素之间的关系</strong>。</p>
<h2 id="常规操作"><a href="#常规操作" class="headerlink" title="常规操作"></a>常规操作</h2><p>每个不交集通常可以处理成一棵树，方便操作。<br>初始化时，将每个元素所在的集合设为它本身，体现在具体操作上就是将每个元素的父节点设为元素本身（此时每个元素所在集合的根都是元素本身）。</p>
<h3 id="找根"><a href="#找根" class="headerlink" title="找根"></a>找根</h3><p>递归实现。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x == father[x] ? father[x] : <span class="built_in">find</span>( father[x] );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h3><p>将 A集合 并入 B集合。体现在操作上就是将 A集合 的根的父节点设为 B节点 的根，这样通过将 A集合 的根设为 B集合 的根的儿子就可将 A集合 并入 B集合 。</p>
<p><img src="1.png" alt="1" title="1"></p>
<p>c++代码实现：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">	father[ <span class="built_in">find</span>(a) ] = <span class="built_in">find</span>(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p>要明白查询查的是啥。<br>查询的是两元素是否在同一集合中。<br>据此容易看出只要判断<strong>两个元素所在集合的根是否是同一个</strong>就能判断出两者是否在同一集合中。<br>代码实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">get</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">find</span>(a) == <span class="built_in">find</span>(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>能看出当在极端条件下（如集合的树的结构退化成一条链），find 函数的效率会非常低，常用的有几个优化方法。</p>
<h3 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h3><p>通过将每一个元素的父节点都指向根节点，可大大提高效率。</p>
<p><img src="2.png" alt="2" title="2"></p>
<p>优化时只要将 find 函数稍作修改就行了。</p>
<p>代码实现：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x == father[x] ? father[x] : father[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="按秩合并"><a href="#按秩合并" class="headerlink" title="按秩合并"></a>按秩合并</h3><p>按照一定顺序合并集合（如只将将小的集合并入大的集合）。<br><del>代码懒得打</del></p>
<h2 id="扩展域和边带权的并查集"><a href="#扩展域和边带权的并查集" class="headerlink" title="扩展域和边带权的并查集"></a>扩展域和边带权的并查集</h2><h3 id="扩展域"><a href="#扩展域" class="headerlink" title="扩展域"></a>扩展域</h3><p>此时集合中存储的是<strong>元素间的关系</strong>（且通常这些关系是有传递性或可推导性）。<br>具体看题。</p>
<h3 id="边带权"><a href="#边带权" class="headerlink" title="边带权"></a>边带权</h3><blockquote>
<p>并查集实际上是由若干树组成的森林，我们能在树中每条边上记录一个权值，即维护一个数组 d，用 d[x] 保存节点 x 到父节点 fa[x] 之间的权值。在每次路径压缩后，每个访问过的节点都会直接指向树根，如果我们同时更新这些节点的 d 值，就可以利用路径压缩过程来统计每个节点到树根间的路径上的一些信息。这就是所谓的“边带权”的并查集。    ——李煜东《算法竞赛进阶指南》</p>
</blockquote>
<p>具体看题。</p>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="模板题"><a href="#模板题" class="headerlink" title="模板题"></a><a href="https://www.acwing.com/problem/content/838/">模板题</a></h3><p>可以自己打打练练手。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10001001</span>;</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> p[x] != x ? p[x] = <span class="built_in">find</span>(p[x]) : x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)p[i] = i;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) </span><br><span class="line">	&#123;</span><br><span class="line">		string c;</span><br><span class="line">		cin &gt;&gt; c;</span><br><span class="line">		<span class="type">int</span> a, b;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">		<span class="keyword">if</span> (c[<span class="number">0</span>] == <span class="string">&#x27;M&#x27;</span>)p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">find</span>(a) == <span class="built_in">find</span>(b))<span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="搭配购买"><a href="#搭配购买" class="headerlink" title="搭配购买"></a><a href="https://www.acwing.com/problem/content/147/">搭配购买</a></h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>第一行输入三个整数 n,m,w，表示有 n 朵云，m 个搭配和你现有的钱的数目。<br>第二行至 n+1 行，每行有两个整数 c, d，表示第 i 朵云的价钱和价值。<br>第 n+2 至 n+1+m 行 ，每行有两个整数 $u_{i}$, $v_{i}$ 。表示买第 u 朵云就必须买第 v 朵云，同理，如果买第 v 朵就必须买第 u 朵。<br>求能买到最大价值的云朵的价值。</p>
<h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p>乍一看像是有依赖的背包问题，但数据规模太大（$10^{9}$），考虑用并查集加上01背包。<br>用并查集将所有绑定的云朵合并成一个云朵，再用01背包。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100101</span>;</span><br><span class="line"><span class="type">int</span> w[N], v[N], p[N], f[N], n, m, c;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fi</span><span class="params">(<span class="type">int</span> x)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> p[x] == x ? x : p[x] = <span class="built_in">fi</span>(p[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;c);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;w[i], &amp;v[i]);</span><br><span class="line">		p[i] = i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> a, b;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">		<span class="type">int</span> pa = <span class="built_in">fi</span>(a), pb = <span class="built_in">fi</span>(b);</span><br><span class="line">		<span class="keyword">if</span> (pa != pb) </span><br><span class="line">		&#123;</span><br><span class="line">			w[pb] += w[pa];</span><br><span class="line">			v[pb] += v[pa];</span><br><span class="line">			p[pa] = p[pb];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (p[i] == i) </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j = c; j &gt;= w[i]; j--) </span><br><span class="line">			&#123;</span><br><span class="line">				f[j] = <span class="built_in">max</span>(f[j], f[j - w[i]] + v[i]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, f[c]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="程序自动分析"><a href="#程序自动分析" class="headerlink" title="程序自动分析"></a><a href="acwing.com/problem/content/239/">程序自动分析</a></h3><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><p>给一串两数相等或两数不相等的约束条件，判断是否矛盾。</p>
<h4 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h4><p>先把所有不等于的式子记录下来，把等于的数所在的集合合并，最后判断不等式中的两数是否不在同一集合。<br>由于数据规模较大，要用哈希，此处直接用 STL 中的 unordered map 代替。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1001001</span>;</span><br><span class="line"><span class="type">int</span> n,cn;</span><br><span class="line">unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; p;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x==p[x]?x:p[x]=<span class="built_in">find</span>(p[x]);</span><br><span class="line">&#125;</span><br><span class="line">pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; q[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; m;</span><br><span class="line">        cn=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="type">int</span> a,b,c;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">            <span class="keyword">if</span>(!m[a])p[a]=a,m[a]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(!m[b])p[b]=b,m[b]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(c)&#123;</span><br><span class="line">                p[<span class="built_in">find</span>(a)]=<span class="built_in">find</span>(b);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                q[++cn]=<span class="built_in">make_pair</span>(a,b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> flag=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cn;i++)&#123;</span><br><span class="line">            <span class="type">int</span> x=q[i].first,y=q[i].second;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(x)==<span class="built_in">find</span>(y))&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">                flag=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)<span class="built_in">printf</span>(<span class="string">&quot;YES\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="银河英雄传说"><a href="#银河英雄传说" class="headerlink" title="银河英雄传说"></a><a href="https://www.acwing.com/problem/content/240/">银河英雄传说</a></h3><h4 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h4><p>N 艘战舰排成 N 列，给定两种指令：</p>
<ol>
<li>M i j，表示让第 i 号战舰所在列的全部战舰保持原有顺序，接在第 j 号战舰所在列的尾部。</li>
<li>C i j，表示询问第 i 号战舰与第 j 号战舰当前是否处于同一列中，如果在同一列中，它们之间间隔了多少艘战舰。</li>
</ol>
<p>编写程序处理这些命令。</p>
<h4 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h4><p>多加两个数组 d 和 siz 分别表示节点到其所在集合的根节点的距离和其所在集合的大小。<br>此处用到“边带权”的并查集。<br>在 find 函数的路径压缩的同时更新 d。<br>在合并时更新 siz。<br>两个同一集合中的元素间的距离就是 abs(d[x] - d[y]) -1。<br>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100101</span>;</span><br><span class="line"><span class="type">int</span> n, p[N], t, d[N], siz[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fi</span><span class="params">(<span class="type">int</span> x)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (p[x] != x) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> t = <span class="built_in">fi</span>(p[x]);</span><br><span class="line">		d[x] += d[p[x]];</span><br><span class="line">		p[x] = t;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">30010</span>; i++)p[i] = i, siz[i] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (t--) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> x, y;</span><br><span class="line">		string s;</span><br><span class="line">		cin &gt;&gt; s;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">		<span class="type">int</span> px = <span class="built_in">fi</span>(x), py = <span class="built_in">fi</span>(y);</span><br><span class="line">		<span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">&#x27;M&#x27;</span> &amp;&amp; px != py) </span><br><span class="line">		&#123;</span><br><span class="line">			d[px] += siz[py];</span><br><span class="line">			siz[py] += siz[px];</span><br><span class="line">			p[px] = py;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">&#x27;C&#x27;</span>) </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (px != py) </span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> </span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">abs</span>(d[x] - d[y]) - <span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="奇偶游戏"><a href="#奇偶游戏" class="headerlink" title="奇偶游戏"></a><a href="https://www.acwing.com/problem/content/description/241/">奇偶游戏</a></h3><h4 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h4><p>自己看题面去。</p>
<h4 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h4><p>开一个数组 sum 表示序列的前缀和，那么在每个问题中：<br>S[l-r] 有偶数个 1，等价于 sum[l - 1] 和 sum[r] 奇偶性相同；<br>S[l-r] 有奇数个 1，等价于 sum[l - 1] 和 sum[r] 奇偶性不同。<br>此时的 sum 是不确定的，是变量。<br>此题很像<a href="acwing.com/problem/content/239/">程序自动分析</a>，但传递关系不只一种：</p>
<ol>
<li>若 a 与 b 奇偶性相同，b 与 c 奇偶性也相同，那么 a 与 c 奇偶性相同。</li>
<li>若 a 与 b 奇偶性相同，b 与 c 奇偶性不同，那么 a 与 c 奇偶性不同。</li>
<li>若 a 与 b 奇偶性不同，b 与 c 奇偶性也不同，那么 a 与 c 奇偶性相同。</li>
</ol>
<p>另外，此题数据规模大，但实际要用的点较少，考虑用离散化，此处用 STL 中的 unordered map 代替。</p>
<p>处理此题的多种转移关系有两种办法：边带权 或者 扩展域。</p>
<h5 id="边带权-1"><a href="#边带权-1" class="headerlink" title="边带权"></a>边带权</h5><p>边权 d 为 0 或 1，表示 x 与 father[x] 奇偶性 相同 或 不同。<br>路径压缩时，将边上的权值做异或运算，得到 x 与根节点的奇偶性关系。<br>设离散化后 l -1 的值为 x，r 为 y，ans 表示每个读入的回答（0表示偶数个，1表示奇数个）。<br>先检查 x 和 y 是否在同一集合。</p>
<p>若在同一集合：<br>d[x] xor d[y] 即为 x 与 y 的奇偶性关系，若 d[x] xor d[y] != ans，则是假话。</p>
<p>若不在同一集合：<br>合并。首先要将根节点合并，然后因为 d[p] 未知（p为A集合根节点，q为B集合根节点，将 p 的父节点设为 q），可由方程 ans = d[x] xor d[y] xor d[p] 推得 d[p] = ans xor d[x] xor d[y] 。<br>代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">20010</span>;</span><br><span class="line"><span class="type">int</span> n, m, p[N], d[N], ans;</span><br><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; S;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (S.<span class="built_in">count</span>(x) == <span class="number">0</span>)S[x] = ++n;</span><br><span class="line">	<span class="keyword">return</span> S[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fi</span><span class="params">(<span class="type">int</span> x)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x != p[x]) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> t = <span class="built_in">fi</span>(p[x]);</span><br><span class="line">		d[x] ^= d[p[x]];</span><br><span class="line">		p[x] = t;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">	n = <span class="number">0</span>;</span><br><span class="line">	ans = m;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)p[i] = i;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> x, y;</span><br><span class="line">		string a;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">		cin &gt;&gt; a;</span><br><span class="line">		x = <span class="built_in">get</span>(x - <span class="number">1</span>), y = <span class="built_in">get</span>(y);</span><br><span class="line">		<span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (a[<span class="number">0</span>] == <span class="string">&#x27;o&#x27;</span>)t = <span class="number">1</span>;</span><br><span class="line">		<span class="type">int</span> px = <span class="built_in">fi</span>(x), py = <span class="built_in">fi</span>(y);</span><br><span class="line">		<span class="keyword">if</span> (px == py) &#123;</span><br><span class="line">			<span class="keyword">if</span> ((d[x]^d[y]) != t) </span><br><span class="line">			&#123;</span><br><span class="line">				ans = i - <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> </span><br><span class="line">		&#123;</span><br><span class="line">			p[px] = py;</span><br><span class="line">			d[px] = d[x] ^ d[y] ^ t;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="扩展域-1"><a href="#扩展域-1" class="headerlink" title="扩展域"></a>扩展域</h5><p>将每个节点 x 拆成两个节点 $x_{odd}$ 和 $x_{even}$ 表示 x 是奇数或偶数，通常叫成 x 的奇数域 和 偶数域。<br>设离散化后 l -1 的值为 x，r 为 y，ans 表示每个读入的回答（0表示偶数个，1表示奇数个）。<br>由关系来判断：</p>
<ol>
<li>ans == 0，合并 $x_{odd}$ 和 $y_{odd}$ ，合并 $x_{even}$ 和 $y_{even}$ 。表示“x为奇数”的条件与“y为奇数”的条件可互相推出；“x为偶数”的条件与“y为偶数”的条件可互相推出。</li>
<li>ans == 1，合并 $x_{odd}$ 和 $y_{even}$ ，合并 $x_{even}$ 和 $y_{odd}$ 。表示“x为奇数”的条件与“y为偶数”的条件可互相推出；“x为偶数”的条件与“y为奇数”的条件可互相推出。</li>
</ol>
<p>判断时，若 ans == 0， $x_{odd}$ 和 $y_{even}$ 在同一集合中则矛盾；若 ans == 0， $x_{odd}$ 和 $y_{odd}$ 在同一集合中则矛盾。<br>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">40010</span>,M=<span class="number">20010</span>;</span><br><span class="line"><span class="type">int</span> n,m,p[N],d[N],ans;</span><br><span class="line">unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; S;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(S.<span class="built_in">count</span>(x)==<span class="number">0</span>)S[x]=++n;</span><br><span class="line">	<span class="keyword">return</span> S[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fi</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x==p[x]?p[x]:p[x]=<span class="built_in">fi</span>(p[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// a+M  奇数域      a  偶数域</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">	n=<span class="number">0</span>;</span><br><span class="line">	ans=m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=N;i++)p[i]=i;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		<span class="type">int</span> x,y;</span><br><span class="line">		string a;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">		cin&gt;&gt;a;</span><br><span class="line">		x=<span class="built_in">get</span>(x<span class="number">-1</span>),y=<span class="built_in">get</span>(y);</span><br><span class="line">		<span class="keyword">if</span>(a[<span class="number">0</span>]==<span class="string">&#x27;e&#x27;</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">fi</span>(x+M)==<span class="built_in">fi</span>(y))&#123;</span><br><span class="line">				ans=i<span class="number">-1</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			p[<span class="built_in">fi</span>(x)]=<span class="built_in">fi</span>(y);</span><br><span class="line">			p[<span class="built_in">fi</span>(x+M)]=<span class="built_in">fi</span>(y+M);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">fi</span>(x)==<span class="built_in">fi</span>(y))&#123;</span><br><span class="line">				ans=i<span class="number">-1</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			p[<span class="built_in">fi</span>(x+M)]=<span class="built_in">fi</span>(y);</span><br><span class="line">			p[<span class="built_in">fi</span>(x)]=<span class="built_in">fi</span>(y+M);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="食物链"><a href="#食物链" class="headerlink" title="食物链"></a><a href="https://www.acwing.com/problem/content/242/">食物链</a></h2><p>上一题的进阶版，不想多讲了，这里给一个 边带权 的代码，<del>扩展域的代码就留作作业吧</del>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100101</span>;</span><br><span class="line"><span class="type">int</span> p[N],d[N],n,m,ans;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fi</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x!=p[x])&#123;</span><br><span class="line">		<span class="type">int</span> t=<span class="built_in">fi</span>(p[x]);</span><br><span class="line">		d[x]+=d[p[x]];</span><br><span class="line">		p[x]=t;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)p[i]=i;</span><br><span class="line">	<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">		<span class="type">int</span> t,x,y;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;t,&amp;x,&amp;y);</span><br><span class="line">		<span class="keyword">if</span>(x&gt;n||y&gt;n)&#123;</span><br><span class="line">			ans++;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="type">int</span> px=<span class="built_in">fi</span>(x),py=<span class="built_in">fi</span>(y);</span><br><span class="line">			<span class="keyword">if</span>(t==<span class="number">1</span>)&#123;</span><br><span class="line">				<span class="keyword">if</span>(px==py&amp;&amp;(d[x]-d[y])%<span class="number">3</span>)&#123;</span><br><span class="line">					ans++;</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span>(px!=py)&#123;</span><br><span class="line">					p[px]=py;</span><br><span class="line">					d[px]=d[y]-d[x];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span>(px==py&amp;&amp;(d[x]-d[y]<span class="number">-1</span>)%<span class="number">3</span>)&#123;</span><br><span class="line">					ans++;</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span>(px!=py)&#123;</span><br><span class="line">					p[px]=p[py];</span><br><span class="line">					d[px]=d[y]-d[x]+<span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>OK就这样吧，讲的很草率，反正没人看我博客，毕竟这只是“一只蒟蒻”的“学习笔记”罢了。<br>有错误 D 我。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Dumby的OI生涯</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>数据结构</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>合成器基本结构介绍</title>
    <url>/2022/%E5%90%88%E6%88%90%E5%99%A8%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>本贴用于学习合成器的各个模块，包括振荡器、滤波器等。</p>
<span id="more"></span>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文用到的主要工具是一个<strong>开源</strong>的宿主软件（DAW）Bespoke Synth。</p>
<p>它最大的特色就是它是模块化的，是一个“可定制的声音游乐场”。</p>
<p>如图：</p>
<p><img src="BespokeSynth示意图.png" alt="BespokeSynth" title="BespokeSynth"></p>
<p>（穷鬼用不起 Reaktor 只能用它了）</p>
<h2 id="模块讲解"><a href="#模块讲解" class="headerlink" title="模块讲解"></a>模块讲解</h2><p>我们就按照 Bespoke 的一些模块来讲。</p>
<p>这里只是简单介绍一下合成器的每种模块，之后每个模块（应该）会有单独帖子来讲解。</p>
<h4 id="输入模块"><a href="#输入模块" class="headerlink" title="输入模块"></a>输入模块</h4><p><img src="输入模块.png" alt="输入模块长这样" title="输入模块长这样"></p>
<p>这个输入模块相当于一个midi键盘了，不过输入模块不只有midi键盘一种。</p>
<h4 id="输出模块"><a href="#输出模块" class="headerlink" title="输出模块"></a>输出模块</h4><p><img src="输出模块.png" alt="输出模块长这样" title="输出模块长这样"></p>
<p>其中的 gain 起到的作用和耳膜类似，就是接收声音信号并将其扩大。底下的数值就是它扩大的倍数。</p>
<p>gain 模块连了条线下来到 splitter 上，这个 splitter 的作用就是将声音分成两个声道。</p>
<p>splitter 又连了两条线下来分别接到 output 1 和 2，这两个就是声音真正的输出了。</p>
<h4 id="振荡器-OSC"><a href="#振荡器-OSC" class="headerlink" title="振荡器 OSC"></a>振荡器 OSC</h4><p><img src="声音产生模块.png" alt="这是整个声音产生模块" title="这是整个声音产生模块"></p>
<p>准确来说图中的 wave 一列才是振荡器，不过现在大多数振荡器都会整合起一些功能。</p>
<p>振荡器（全称oscillator）是合成器中最重要的部分之一，它的功能就是也只是产生声音。</p>
<p>如图是著名合成器Serum中的OSC：</p>
<p><img src="serum的osc.png" alt="Serum的振荡器模块" title="Serum的振荡器模块"></p>
<p>如果没有其他模块，仅仅输入输出和振荡器连接起来的话，只要给它一个信号振荡器就会一直发出声音，哪怕信号停止输入。</p>
<p>那么为什么音乐中的各种声音都是有始有终的呢？</p>
<p>这就需要下面这些模块了。</p>
<h4 id="音量控制-AMP（或VCA）"><a href="#音量控制-AMP（或VCA）" class="headerlink" title="音量控制 AMP（或VCA）"></a>音量控制 AMP（或VCA）</h4><p>这个模块的准确名称叫做“电压控制放大器”，也是合成器的一个必要的模块。</p>
<p>还是这张图：</p>
<p><img src="声音产生模块.png" alt="这是整个声音产生模块" title="这是整个声音产生模块"></p>
<p>图中的 volume 一列就是音量控制（准确来说是受包络控制的音量控制模块，下面会讲）。</p>
<p>其功能，顾名思义，就是控制音量，但也仅仅是控制音量，就像这样：</p>
<p><img src="Reaktor6的VCA.png" alt="Reaktor6的音量控制模块之一" title="Reaktor6的音量控制模块之一"></p>
<p>如果只是将OSC接到VCA上，实际上还是不能在信号停止输入时停止声音，他们只能控制产生的声音的音量高低。</p>
<h4 id="包络-ENV"><a href="#包络-ENV" class="headerlink" title="包络 ENV"></a>包络 ENV</h4><p>包络全称 Envelope，在整个声音产生模块中无法直观地看出包络是什么。</p>
<p>我们上面说了声音产生模块那张图中的 volume 是受包络控制的音量控制模块，模块上方是一个波形，这个波形就是由包络产生的。</p>
<p>下面是Serum中的ENV模块：</p>
<p><img src="Serum中的ENV.png" alt="Serum中的包络模块" title="Serum中的包络模块"></p>
<p>简单来说，包络就是通过产生一个波形来控制其他模块（主要就是音量控制模块），从而达到模块控制的自动化。</p>
<p>通过产生一个波形来控制音量控制模块，音量就能按照波形进行调节：增大或是衰减。</p>
<p>有了以上几种模块后，就能够做出一个最简单最基础的合成器了，只不过产生的声音可能会很单调。</p>
<p>那么如果我们要制作一个减法合成器呢？</p>
<p>接下来就需要滤波器模块了。</p>
<h4 id="滤波器-FLT（或SVF）"><a href="#滤波器-FLT（或SVF）" class="headerlink" title="滤波器 FLT（或SVF）"></a>滤波器 FLT（或SVF）</h4><p>滤波器全称Filter（SVF指的是状态变量滤波器 State Variable Filter）。</p>
<p>又是这张图：</p>
<p><img src="声音产生模块.png" alt="这是整个声音产生模块" title="这是整个声音产生模块"></p>
<p>其中最右边 filter 一列就是滤波器。</p>
<p>其作用，顾名思义，就是滤去一些频率，从而使声音更加动听。</p>
<p>然后把上边一堆东西按照正确的顺序连接起来，就是一个最简单的减法合成器了。</p>
<p>偷一张B站up主AndreChen的视频截图（文字是我加的）：</p>
<p><img src="@AndreChen.png" alt="up主@AndreChen的减法合成器" title="up主@AndreChen的减法合成器"></p>
<h4 id="低频振荡器-LFO"><a href="#低频振荡器-LFO" class="headerlink" title="低频振荡器 LFO"></a>低频振荡器 LFO</h4><p>这个其实是非必要的，之后专门开一个帖子讲好了。</p>
<h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>以上这些模块就是合成器最基础的模块了。</p>
<p>不过这样的声音还是很难听，毕竟只是一个最简单的减法合成器。</p>
<p>可以在这个合成器的基础上加一些效果器之类的。或者也可以多做几个发声模块之类。</p>
<p>总之，以上就是合成器最基础的各个模块，可能会有漏洞或错误，如有发现请发邮件（地址在博客的关于页）给我。</p>
<p>参考：</p>
<ul>
<li><a href="https://www.bilibili.com/video/BV1Ys411i7hF">B站UP主@AndreChen的教学视频 “【合辑】【合成器基础教学】入门/通用/必备知识——Abletive教学视频站”</a></li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Dumby的折腾笔记</category>
      </categories>
      <tags>
        <tag>合成器</tag>
      </tags>
  </entry>
  <entry>
    <title>批处理学习笔记</title>
    <url>/2022/%E6%89%B9%E5%A4%84%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>本贴为批处理学习笔记。</p>
<p>别问为什么要学批处理，问就是折腾。</p>
<p>因为是折腾，所以学得很散很乱。</p>
<span id="more"></span>
<h2 id="ECHO"><a href="#ECHO" class="headerlink" title="ECHO"></a>ECHO</h2><p>主要用来显示一些东西。</p>
<h5 id="输出文本"><a href="#输出文本" class="headerlink" title="输出文本"></a>输出文本</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo 文本</span><br></pre></td></tr></table></figure>
<h6 id="输出空行"><a href="#输出空行" class="headerlink" title="输出空行"></a>输出空行</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo.</span><br><span class="line">echo,</span><br><span class="line">echo:</span><br><span class="line">echo;</span><br><span class="line">echo\</span><br><span class="line">echo/</span><br></pre></td></tr></table></figure>
<h5 id="开关回显"><a href="#开关回显" class="headerlink" title="开关回显"></a>开关回显</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo on</span><br><span class="line">echo off</span><br></pre></td></tr></table></figure>
<h5 id="回复命令"><a href="#回复命令" class="headerlink" title="回复命令"></a>回复命令</h5><p>这个后面再说。</p>
<h2 id="PAUSE"><a href="#PAUSE" class="headerlink" title="PAUSE"></a>PAUSE</h2><p>暂停。</p>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><h5 id="REM"><a href="#REM" class="headerlink" title="REM"></a>REM</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">REM 这是条注释</span><br></pre></td></tr></table></figure>
<h5 id=""><a href="#" class="headerlink" title="::"></a>::</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:: 这也是条注释</span><br></pre></td></tr></table></figure>
<p>在批处理文件中，单独一个以”:”为开头的行都被视作<strong>标签</strong>（后面会讲），并且标签后的所有内容均会被忽略。<br>但是，GOTO 命令只会识别有效标签，也就是冒号后面紧跟一个以字母或数字为开头的字符串。<br>所以冒号后面跟其他以非字母或数字开头的字符串都可以拿来做注释。</p>
<h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h5><p>如果你懒得一行一行打注释，你可以：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">goto tag</span><br><span class="line">这之间打注释。</span><br><span class="line">:tag</span><br></pre></td></tr></table></figure></p>
<h2 id="-1"><a href="#-1" class="headerlink" title="@"></a>@</h2><p>这个符号叫<strong>命令行回显屏蔽符</strong>。<br>功能就和名字一样。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@echo off</span><br></pre></td></tr></table></figure></p>
<p>这样就能让 echo off 那条命令也不显示。</p>
<h2 id="GOTO"><a href="#GOTO" class="headerlink" title="GOTO"></a>GOTO</h2><p>这东西大概就是让你跳到标签处运行。<br>标签必须单独一行，并且以单独一个冒号开头，冒号后面紧跟一个以字母或数字为开头的字符串。<br>如下：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:tag</span><br><span class="line">echo This is DUMBLOG.</span><br><span class="line">GOTO tag</span><br></pre></td></tr></table></figure></p>
<p>循环输出“This is DUMBLOG.”。</p>
<p>注意：</p>
<ol>
<li>GOTO必须和标签一一对应，否则会直接报错并退出。但是标签不一定要和GOTO一一对应，意思是可以有单独的标签存在，但不能有单独的GOTO存在。</li>
<li>标签名只能用常量，不能用变量。</li>
<li>若有标签重名，执行最顶上那个。</li>
</ol>
<h2 id="重定向符"><a href="#重定向符" class="headerlink" title="重定向符"></a>重定向符</h2><p>将命令的输出写入到指定的文件或 <em>nul</em> 中（nul是空设备，相当于直接把输出文本屏蔽掉）。</p>
<h5 id="gt"><a href="#gt" class="headerlink" title="&gt;"></a>&gt;</h5><p>“&gt;” 会覆盖文件中已有的内容。</p>
<h5 id="gt-gt"><a href="#gt-gt" class="headerlink" title="&gt;&gt;"></a>&gt;&gt;</h5><p>“&gt;&gt;” 不会覆盖文件中原有内容，而是将文本直接加到指定文件最后面。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@echo 可以这样来打注释 &gt; nul</span><br><span class="line">ping dumblog.top &gt; ping.txt</span><br><span class="line">@echo 把 ping 命令的输出写到文件 ping.txt 中去 &gt;&gt; nul</span><br></pre></td></tr></table></figure></p>
<h6 id="一些设备名"><a href="#一些设备名" class="headerlink" title="一些设备名"></a>一些设备名</h6><ul>
<li>con：控制台（键盘和显示器）</li>
<li>nul：空设备</li>
<li>clock$ 电子钟</li>
</ul>
<p>重定向符可用于Debug：<br>“&gt;nul”前的 1 表示输出流，2 表示错误流。</p>
<h2 id="SET"><a href="#SET" class="headerlink" title="SET"></a>SET</h2><p>SET的基础功能是用来显示、设置或删除 cmd.exe 环境变量。</p>
<p>语法：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set [v=[s]]</span><br></pre></td></tr></table></figure></p>
<p>v 指定环境变量名；<br>s 指定要赋给变量的字符串。</p>
<h5 id="显示"><a href="#显示" class="headerlink" title="显示"></a>显示</h5><p>直接输入没有参数的环境变量。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set PATH</span><br></pre></td></tr></table></figure></p>
<p>会显示环境变量 PATH 的值。</p>
<p>也可以：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set p</span><br></pre></td></tr></table></figure></p>
<p>显示所有以 p 开头的环境变量。</p>
<p>参考：</p>
<ul>
<li><a href="https://www.jianshu.com/p/5599830a8051?u_atoken=8332737f-b9a1-4dcb-840e-b688110eaa58&amp;u_asession=01gy6eOLwCcB_8-CDZf3z2KnC_FFeVK62IcIf3NKrQYdADchGulvx-MEPcd1yFYuePX0KNBwm7Lovlpxjd_P_q4JsKWYrT3W_NKPr8w6oU7K9kFAbUkDOvGooo_RddoXmGMKWrbBzYAhXhkL4v5_cjQmBkFo3NEHBv0PZUm6pbxQU&amp;u_asig=05CZuWUF1dXBOUj8LbF462yajfgDLZW2eAL69zvDx-75zyAdea6Ua2jjzgZA6EOK8WQcWGKTiNRFlF4OOzmHKVFDZcsLPvp2fgOhmg_mCF8_-4o_x_DSskOph_6hDjYwe_TYysqoeVo93yFIiaF_yNfnjEB_KMkiQAWteXiWUJ1Ev9JS7q8ZD7Xtz2Ly-b0kmuyAKRFSVJkkdwVUnyHAIJza3TvhMjGgDQPrWfIv4JXF8c1r2tAJnEudPVMUvAXVqKdf9JIAkyKervFWgmMgV8j-3h9VXwMyh6PgyDIVSG1W_i6qXCmp0m0JKxGlDsiF7TGVjuvW8Mbnw36tryIj0GRspsxe0TaTxvBcgIUCsX2G5rkLYuko5aLG-BbWxa0_RHmWspDxyAEEo4kbsryBKb9Q&amp;u_aref=W%2FaJqpVCqVnZ3ia2sJ0n5vx%2BIWE%3D">批处理(bat)命令之echo命令</a></li>
<li><a href="https://www.hxstrive.com/">人人编程网</a></li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Dumby的折腾笔记</category>
      </categories>
      <tags>
        <tag>批处理</tag>
        <tag>bat</tag>
      </tags>
  </entry>
  <entry>
    <title>数论学习笔记（欧拉函数专题篇）</title>
    <url>/2021/%E6%95%B0%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0%E4%B8%93%E9%A2%98%E7%AF%87%EF%BC%89/</url>
    <content><![CDATA[<p>快来学数论！本文介绍欧拉函数的定义性质及拓展。</p>
<span id="more"></span>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>1 到 $N$ 中与 $N$ 互质的数的个数被称为欧拉函数，记为 $\varphi(N)$。</p>
<h2 id="函数式"><a href="#函数式" class="headerlink" title="函数式"></a>函数式</h2><p>$\varphi \left ( n \right ) = n \times \prod_{i=1}^{m} \left ( 1-\frac{1}{p_{i}} \right )$</p>
<h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><h3 id="性质一"><a href="#性质一" class="headerlink" title="性质一"></a>性质一</h3><p>显然，如果 $N$ 为 质数，则 $\varphi(N)=N-1$</p>
<h3 id="性质二"><a href="#性质二" class="headerlink" title="性质二"></a>性质二</h3><p> 欧拉函数为 积性函数： 若 $\gcd(a , b ) = 1$，则 $\varphi(ab)=\varphi(a)\varphi(b)$。</p>
<blockquote>
<p>积性函数 指对于所有互质的整数 $a$ 和 $b$ 有性质 $f( ab ) = f( a ) f( b )$ 的数论函数。</p>
</blockquote>
<h3 id="性质三"><a href="#性质三" class="headerlink" title="性质三"></a>性质三</h3><p> 若 $n=p^{k}$，$p$ 为 质数，则 $\varphi(n)= n\left (1 - \frac{1}{p} \right )=  \left ( p - 1 \right )p^{k-1}$。</p>
<blockquote>
<p>证明<br>$n$ 个数中只有 $p$ 的倍数不与 $n$ 互质，而 $p$ 的倍数 $x$ 则有 $\dfrac{n}{p}=p^{k-1}$ 个，<br>因此 $\varphi(n)=n-\dfrac{n}{p}=n(1-\dfrac{1}{p})=p^{k}-p^{k-1}=(p-1)p^{k-1}$ 。</p>
</blockquote>
<h3 id="性质四"><a href="#性质四" class="headerlink" title="性质四"></a>性质四</h3><p> 若 $N=p_{1}^{c_{1}}p_{2}^{c_{2}}…p_{m}^{c_{m}}$，则：<br> $\varphi(N)=N \times \dfrac{p_{1}-1}{p_{1}} \times \dfrac{p_{2}-1}{p_{2}} \times … \times \dfrac{p_{m}-1}{p_{m}}$<br> $\varphi(N)=N \times \left ( 1-\dfrac{1}{p_{1}} \right ) \times \left ( 1-\dfrac{1}{p_{2}} \right ) \times …  \times \left ( 1-\dfrac{1}{p_{m}} \right )$</p>
<p>即：<br>${\small \varphi \left ( n \right ) = n \times \prod_{i=1}^{m} \left ( 1-\frac{1}{p_{i}} \right )} $</p>
<h3 id="性质五"><a href="#性质五" class="headerlink" title="性质五"></a>性质五</h3><p>$\forall  n &gt; 1$，1 到 $n$ 中与 $n$ 互质的数的和为 $n \times \dfrac{\varphi(n)}{2}$。</p>
<blockquote>
<p>证明<br>因为 $\gcd( n , x ) = \gcd( n , n-x )$，所以与 $n$ 不互质的数 $x$，$n - x$ 成对出现，平均值为 $\dfrac{n}{2}$ 。<br>因此，与 $n$ 互质的数的平均数也是 $\dfrac{n}{2}$，进而可得 1 到 $n$ 中所有与 $n$ 互质的数的和为  $\dfrac{n}{2} \varphi(n)$，化简得 $\dfrac{n\times \varphi(n)}{2}$。</p>
</blockquote>
<h3 id="性质六"><a href="#性质六" class="headerlink" title="性质六"></a>性质六</h3><p>如果 $a \mod p = 0$，其中 $p$ 为质数，则 $\varphi(a \times p)=p \times \varphi(a)$</p>
<blockquote>
<p>证明<br>因为 $a \mod p = 0$，所以 $a \times p$ 与 $a$ 包含相同的质因子，只是其中有一个质因子 $p$ 的指数不同。<br>直接把 $\varphi(a \times p)$ 和 $\varphi(a)$ 按照函数式写出来，前者除去后者，商为 $p$ ，即  $\dfrac{\varphi(a \times p)}{\varphi(a)}=p$<br>所以 $\varphi(a \times p)=p \times \varphi(a)$</p>
</blockquote>
<h3 id="性质七"><a href="#性质七" class="headerlink" title="性质七"></a>性质七</h3><p>如果 $a \mod p \ne 0$， 其中 $p$ 为质数，则 $\varphi(ap)=(p-1)\varphi(a)$</p>
<blockquote>
<p>证明<br>欧拉函数为积性函数。<br>所以 $\varphi(ap)=\varphi(a)\varphi(p)$，<br>又因为 $p$ 是质数，由 性质一 可得 $\varphi(p)=p-1$<br>所以 $\varphi(ap)=(p-1)\varphi(a)$</p>
</blockquote>
<h2 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h2><p>若正整数 $a$，$n$ 互质，则 $a^{\varphi(n)} \equiv 1\pmod{n}$，其中 $\varphi(n)$ 为欧拉函数。</p>
<blockquote>
<p>证明<br>设 1 到 $n$ 中所有与 $n$ 互质的数为 $a_{1},a_{2},…,a_{\varphi(n)}$<br>因为 $a$ 与 $n$ 互质，$a_{1}$ 与 $n$ 互质 （$a \equiv 1\pmod{n}$ 并且 $a_{1} \equiv 1\pmod{n}$<br>所以 $aa_{1}$ 与 n 互质 （$aa_{1} \equiv 1\pmod{n}$<br>同理 $aa_{1},aa_{2},…,aa_{\varphi(n)}$ 都与 $n$ 互质<br>所以 $aa_{1} \times aa_{2} \times … \times aa_{\varphi(n)}=a^{\varphi(n)} \times \left ( a_{1}a_{2}…a_{\varphi(n)}\right )$ 与 $n$ 互质<br>又因为  $a^{\varphi(n)} \times \left ( a_{1}a_{2}…a_{\varphi(n)}\right ) \equiv a_{1}a_{2}…a_{\varphi(n)} \pmod{n}$<br>所以  $a^{\varphi(n)} \equiv 1\pmod{n}$</p>
</blockquote>
<h3 id="费马小定理"><a href="#费马小定理" class="headerlink" title="费马小定理"></a>费马小定理</h3><p>为欧拉定理的一种情况。<br>若 $p$ 为质数，则对于任意整数 $a$，有 $a^{p} \equiv a \pmod{p}$，即 $a^{p-1} \equiv 1 \pmod{p}$</p>
<blockquote>
<p>证明<br>是欧拉函数的一种情况<br>将 $\varphi(p)=p-1$ 带入即可</p>
</blockquote>
<h2 id="欧拉函数求法"><a href="#欧拉函数求法" class="headerlink" title="欧拉函数求法"></a>欧拉函数求法</h2><h3 id="求单个数的欧拉函数"><a href="#求单个数的欧拉函数" class="headerlink" title="求单个数的欧拉函数"></a>求单个数的欧拉函数</h3><p>只要在 分解质因数 时顺便将欧拉函数求出来就好了。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">phi</span><span class="params">(<span class="type">int</span> n)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> ans = n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= <span class="built_in">sqrt</span>(n); i++) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (n % i == <span class="number">0</span>) </span><br><span class="line">		&#123;</span><br><span class="line">			ans = ans / i * (i - <span class="number">1</span>);</span><br><span class="line">			<span class="keyword">while</span> (n % i == <span class="number">0</span>)n /= i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (n &gt; <span class="number">1</span>)ans = ans / n * (n - <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="线性求多个数的欧拉函数"><a href="#线性求多个数的欧拉函数" class="headerlink" title="线性求多个数的欧拉函数"></a>线性求多个数的欧拉函数</h3><p>在 线性筛 实现的时候顺便求欧拉函数。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">euler</span><span class="params">(<span class="type">int</span> x)</span> </span></span><br><span class="line"><span class="function"></span>&#123;   <span class="comment">// primes数组存质数</span></span><br><span class="line">	<span class="comment">// phi数组存欧拉函数</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= x; i ++) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(!st[i]) </span><br><span class="line">		&#123;</span><br><span class="line">			primes[cn++] = i; </span><br><span class="line">			phi[i] = i - <span class="number">1</span>;</span><br><span class="line">			<span class="comment">//这句利用性质一</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; primes[j] &lt;= x / i; j ++) </span><br><span class="line">		&#123; </span><br><span class="line">			st[ primes[j] * i ] = <span class="number">1</span>;</span><br><span class="line">			phi[ primes[j] * i ] = phi[i] * (i % primes[j] ? primes[j] - <span class="number">1</span> : primes[j]);</span><br><span class="line">			<span class="comment">// 这句利用了性质六、七</span></span><br><span class="line">			<span class="keyword">if</span>( i % primes[j] == <span class="number">0</span> ) <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>OK，笔记完。<br>本蒟蒻刚学 OI ，如有错误请 D 我！！</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Dumby的OI生涯</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>数论</tag>
        <tag>质数</tag>
        <tag>欧拉函数</tag>
      </tags>
  </entry>
  <entry>
    <title>开会</title>
    <url>/2025/%E5%BC%80%E4%BC%9A/</url>
    <content><![CDATA[<p>我要发表暴论，爱tm听就听，不听就tm滚。</p>
<span id="more"></span>
<p>先贴一段：</p>
<ol>
<li>早自习出勤，统计重点关注对象，分类别给出解决方案（如果没有办法交给辅导员处理）</li>
<li>学雷锋月，开展学雷锋活动，形成文字、记录照片，发班级公众号，并转发至自行致远公众号</li>
<li>下周早自习开展早演讲，（7:55-8:05）每天安排一个人，时间5～10分钟左右，可以让导生先来演讲（有无ppt都可以），并形成排班表（第一周的演讲质量一定要拉上去！！！）（第一周分享主题:我的大学生活）另外，早锻炼预计在4月份开始。</li>
<li>合唱团（需要30人，男女各15人，指挥1人，男女不限）<br>每个班至少报3个人，至少2男一女（女生也可以多点）</li>
<li>下周组织学院内拔河比赛（每个班8男2女），下周每天的下午7.8节课，地点在综合训练馆附近，具体地点听通知。<blockquote>
<p>（1）.注意安全<br>（2）.可以组织动员班级的拉拉队，积极参与<br>（3）.如果有课成员可以不固定，只要人数够了就行（班长协调好！！！）</p>
</blockquote>
</li>
</ol>
<p>就看看这一段就感觉血压上来了。不知道以为我还在蝇州养猪场呢。</p>
<p>挨个讲讲，就第一个这早自习吧（包括晚自习也一样），想学的有的是时间学，有的是地方学，和年轻人打过交道的（我是说真正平等深入交流而不是布置作业之类的自上而下的接头）都知道现在人就算熬晚点也不会想起早点。<br>我是起来了，食堂是没法吃的，商业街是只有包子的，要么就吃面包。也不是不可以早自习下课那会儿再去吧，你要不看看有多少人是这种想法，看看那会儿食堂tmd有多少人。我tm要在这么点时间里排这么长队把一堆吃的捅进肚子里再回去上课。<br>就算早餐解决了，牛魔的我早上七点不到起来，搁着坐半个多小时。一上午的课可以说是基本不用听了，困得跟头猪一样。<br>nmd自习就非得坐这破教室里学是吧，多学这半个小时我能升天啊？反之，我多睡半个小时我就是能清醒一天，效率就是能更高。😅</p>
<p>第二个到目前没听到消息。</p>
<p>第三个也是幽默。早自习还不行，还得找个人上去叫两下才舒服。本蛆有幸被选中演讲。一个星期本来五天都要讲，隔壁班愣是一个没讲。什么第一周质量拉上去，纯tm搞笑。我的大学生活，nmd爱怎么过怎么过去，谁tm过得不是大学生活。想看厉害的自己搜下一搜一大把，想看有意思的自己搜下一搜一大把，想看摆烂的自己搜下一搜一大把。一群半死不死的东西坐在教室里，上面一个什么东西叽里咕噜咕哝着什么东西，这就是早演讲。</p>
<p>第四个第五个更是王炸。我以为什么每个班出几个人这种事随着我高中毕业已经成为过去式了，我是真想不到大学还来搞这种没名堂的东西。什么gp班级凝聚力你凝聚你码呢。我觉得凡是接受过义务教育的当代中国学生都tm对这种所谓凝聚力所谓增进交流的官腔犯恶心。</p>
<p>这些还只是 <strong>我的大学生活</strong> 的一小部分。就除了这些吧，什么年级大会，什么班会，我是真想问问了，你们tm都是有什么怪癖吗什么开会癖什么狗叫癖，简简单单几个事情，敲几个字就能解决，你非得把所有人聚到一个位于学校最角落的破地方听你们狗叫。nmd你要是写成文章直接发出来，想看的人自己会看，不想看的你叫去开会他照样不会听。<br>还有这班会吧，也是厉害。一张嘴就是陈腔滥调，是个中国人都是听这种p话从小听到大的，耳朵都磨出茧了。nmd真是不会点官腔都当不了领导啊。还有什么叫几个人起来分享经验，你分享nm呢。我上个学期没有一个星期没不翘课非要我说出来是吧。平时没事就打游戏非要我说出来是吧。作业永远七分抄非要我说出来是吧。就考个b试我运气好点md很屌了是吧。<br>所有人问话都是一个调调，班主任，书记，导员。我就拿同一个破例子我能回答所有人的问题。😅</p>
<p>是。我是戾气太重了。我想啊？</p>
<p>学校管理层也都是蠢猪，和蝇州养猪场的饲养员tm有的一拼。这学校几把路本来就修的史一样，nmd还搁这修减速带升降桩，怕学生堵不死是吧。</p>
<p>md一个个都是高级人类，tmd拿直肠思考就能解决我们凡人终生无法参透的问题😭😭。</p>
<p>牛逼，太牛逼。</p>
<p>今天又有人跳了，不知为何，白白失去一条生命固然可惜，但于他也许是解脱吧，希望人能有最好的结局🙏🏿，但不知学校里的某些出生是怎么看的。</p>
<p>就这样吧，懒得烦了。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Dumby的sb日常</category>
      </categories>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title>数论学习笔记（筛质数和约数篇一）</title>
    <url>/2021/%E6%95%B0%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E7%AD%9B%E8%B4%A8%E6%95%B0%E5%92%8C%E7%BA%A6%E6%95%B0%E7%AF%87%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<p>来学数论！本文介绍质数和约数以及各种对应常见应用。</p>
<span id="more"></span>
<h2 id="质数判定"><a href="#质数判定" class="headerlink" title="质数判定"></a>质数判定</h2><h3 id="试除法"><a href="#试除法" class="headerlink" title="试除法"></a>试除法</h3><p>枚举二到 $\sqrt{n}$ 的所有数 $i$，若 $n$ 能被 $i$ 整除，则 $n$ 不是质数。<br>否则则是质数。<br>为什么只需要枚举到 $\sqrt{n}$？<br>因为如果有一个数 $i &gt; \sqrt{n}$ ，且 $i|n$（“ <strong>|</strong> ”表示 “ <strong>整除</strong> ” ，即 $n \bmod{i}=0$），那么 $\dfrac{n}{i}$ 一定整除 $n$，而 $i &gt; \sqrt{n}$，则 $\dfrac{n}{i}$ 一定小于 $\sqrt{n}$，那么在从小到大的枚举中就已经判断出 $n$ 能被一个数整除，则无需再继续枚举。所以只需要枚举到 $\sqrt{n}$。</p>
<h2 id="质数筛选"><a href="#质数筛选" class="headerlink" title="质数筛选"></a>质数筛选</h2><h3 id="埃氏筛法"><a href="#埃氏筛法" class="headerlink" title="埃氏筛法"></a>埃氏筛法</h3><p>从二开始小到大枚举每一个数，当枚举到当前数位质数时（即该数未被标记过），则将该数及其所有倍数标记。<br>一遍跑下来以后，没有被标记的数即为质数。<br><del>代码懒得打</del></p>
<h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>由于在筛质数的过程中会有一些合数被重复标记，时间复杂度非线性（但非常接近线性）。<br>时间复杂度为 $O \left ( N log^{2} N \right )$。</p>
<h3 id="线性筛"><a href="#线性筛" class="headerlink" title="线性筛"></a>线性筛</h3><p>通过保证每个数只能被它的最小质因子筛去，而达到让每个数只被筛去一遍，使时间复杂度达到线性。<br>代码中解释。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">( <span class="type">int</span> x )</span> </span></span><br><span class="line"><span class="function"></span>&#123;   <span class="comment">//线性筛本体</span></span><br><span class="line">	<span class="comment">//primes[] 数组存质数</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= x; i ++) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>( ! st[i] ) primes[ cn ++ ] = i;   <span class="comment">//当前数未被标记过（即当前数为质数），将其标记</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; primes[j] &lt;= x / i; j ++) </span><br><span class="line">		&#123;   <span class="comment">//从小到大枚举每一个质数</span></span><br><span class="line">			st[ primes[j] * i ] = <span class="number">1</span>;  <span class="comment">//将每一个质数的倍数标记</span></span><br><span class="line">			<span class="keyword">if</span>( i % primes[j] == <span class="number">0</span> ) <span class="keyword">break</span>;   </span><br><span class="line">			<span class="comment">//如果 i 能被当前质数整除了，说明当前质数为 i 的最小质因子</span></span><br><span class="line">			<span class="comment">//此时就应跳出循环</span></span><br><span class="line">			<span class="comment">//因为 i*primes[j+1] 这个数的最小质因子也是primes[j]而不是primes[j+1]</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>主要就是一个 <code>if ( i % primes[j] == 0 ) break;</code> 该怎么理解。<br>设当前质数为 $p_{j}$，下一个质数为 $p_{j+1}$。<br>当枚举到 $p_{j}$ 时，因为 $p_{j}|i$，所以有 $p_{j}|i \times p_{j+1}$<br>所以 $p_{j}$ 为 $i \times p_{j+1}$ 的最小质因数（ $i \times p_{j+1}$ 在后面的循环中会被 $p_{j}$ 筛去）。<br>而我们要保证每个数只被它的最小质因数筛去，所以应该退出循环。</p>
<h4 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>由于每个数只被筛了一次，所以算法是线性的，时间复杂度为 $O( N )$。</p>
<h2 id="质因数分解"><a href="#质因数分解" class="headerlink" title="质因数分解"></a>质因数分解</h2><h3 id="算数基本定理"><a href="#算数基本定理" class="headerlink" title="算数基本定理"></a>算数基本定理</h3><p>任意一个大于 1 的正整数都能被分解为有限个质数的乘积，写作：<br>$N=p_{1}^{c_{1}}p_{2}^{c_{2}}…p_{m}^{c_{m}}$<br>其中 $c_{i}$ 都是正整数，$p_{i}$ 都是质数，且满足 $p_{1}$ &lt; $p_{2}$ &lt; … &lt; $p_{m}$</p>
<h3 id="试除法-1"><a href="#试除法-1" class="headerlink" title="试除法"></a>试除法</h3><p><del>懒得讲</del></p>
<h2 id="约数"><a href="#约数" class="headerlink" title="约数"></a>约数</h2><h3 id="约数个数"><a href="#约数个数" class="headerlink" title="约数个数"></a>约数个数</h3><p>求一个数的约数个数。<br>有如下定理：<br>正整数 $N$ 满足：<br>$N=p_{1}^{c_{1}}p_{2}^{c_{2}}…p_{m}^{c_{m}}$<br>则 N 的正约数个数为<br>$\left (c_{1}+1\right ) \times \left (c_{2}+1\right ) \times …\times \left (c_{m}+1\right )$<br>证明如下：<br>对于 $N$ 的一个质因数 $p_{1}$ ，它可以选择 0 个， 1 个， 2 个… $c_{1}$个，共 $\left ( c_{1} +1 \right )$ 种选法；<br>同样的，对于其他的质因数也有 $\left ( c_{2} +1 \right )$，$\left ( c_{3} +1 \right )$ … $\left ( c_{m} +1 \right )$种选法。<br>则总共能构成的排列有 $\left (c_{1}+1\right ) \times \left (c_{2}+1\right ) \times …\times \left (c_{m}+1\right )$ 种，即有 $\left (c_{1}+1\right ) \times \left (c_{2}+1\right ) \times …\times \left (c_{m}+1\right )$ 个约数。<br><del>代码懒得打</del></p>
<h3 id="约数之和"><a href="#约数之和" class="headerlink" title="约数之和"></a>约数之和</h3><p>有如下定理：<br>正整数 $N$ 满足：$N=p_{1}^{c_{1}}p_{2}^{c_{2}}…p_{m}^{c_{m}}$</p>
<p>则 N 的所有正约数之和为<br>$\left(1+p_{1}+p_{1}^{2}+\ldots+p_{1}^{c_{1}}\right) \times\left(1+p_{2}+p_{2}^{2}+\ldots+p_{2}^{c_{2}}\right) \times \ldots \times\left(1+p_{m}+p_{m}^{2}+\ldots+p_{m}^{c_{m}}\right)$<br>证明如下：<br>由于 $N$ 的约数个数为 $\left (c_{1}+1\right ) \times \left (c_{2}+1\right ) \times …\times \left (c_{m}+1\right )$，由乘法原理可得其正约数之和为 $\left(1+p_{1}+p_{1}^{2}+\ldots+p_{1}^{c_{1}}\right) \times\left(1+p_{2}+p_{2}^{2}+\ldots+p_{2}^{c_{2}}\right) \times \ldots \times\left(1+p_{m}+p_{m}^{2}+\ldots+p_{m}^{c_{m}}\right)$。<br><del>代码照样懒得打</del></p>
<h3 id="最大公约数"><a href="#最大公约数" class="headerlink" title="最大公约数"></a>最大公约数</h3><p>首先讲一下同余</p>
<h4 id="同余"><a href="#同余" class="headerlink" title="同余"></a>同余</h4><p>若 $a \bmod{m}=b \bmod{m}$ ，则称 $a$ 与 $b$ 同余，写作 $a \equiv b \pmod{m}$</p>
<h5 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h5><p>可以自己百度一下。<br>主要就几个。<br>这里用到的有：满足基本加减乘除运算（除去的数必须与 $m$ 互质）</p>
<h4 id="互质"><a href="#互质" class="headerlink" title="互质"></a>互质</h4><p>当 $a \equiv 1 \pmod{m}$ 时，我们称 $a$ 与 $m$ 互质。<br>即 $a$ 与 $m$ 的最大公约数为 1 。</p>
<h4 id="计算最大公约数"><a href="#计算最大公约数" class="headerlink" title="计算最大公约数"></a>计算最大公约数</h4><p>我们用 $\gcd(a,b)$ 表示 $a$ 与 $b$ 的最大公约数。</p>
<h5 id="九章算术-·-更相减损术"><a href="#九章算术-·-更相减损术" class="headerlink" title="九章算术 · 更相减损术"></a>九章算术 · 更相减损术</h5><p>不是很常用，这里不讲了。<br><del>我懒</del></p>
<h5 id="欧几里得算法"><a href="#欧几里得算法" class="headerlink" title="欧几里得算法"></a>欧几里得算法</h5><p>又称 辗转相除法 。<br>如下：<br>$\forall a$，$b \in N$ ，$b \ne 0$，$\gcd(a,b)=\gcd(b,a \bmod{b})$<br>证明如下：<br>若 $a &lt; b$，则 $\gcd(b,a \bmod{b})= \gcd(b,a)= \gcd(a,b)$<br>若 $a \ge b$，不妨设 $a = qb + r$，其中 $0 ≤ r &lt; b$。显然 $r = a \bmod {b}$。对于 $a$，$b$ 的任意公约数 $d$，因为 $d|a$，$d|bq$，所以 $d|(a - bq)$，即 $d|r$，因此 $d$ 也是 $b$，$r$ 的公约数。反之亦然。故 $a$，$b$ 的公约数集合与 $b$，$a \bmod {b}$ 的公约数集合相同，故它们的最大公约数也相等。<br>代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123; <span class="keyword">return</span> b ? <span class="built_in">gcd</span>(b, a % b) : a; &#125;</span><br></pre></td></tr></table></figure><br>就一行，短吧。<br>剩下的知识点以后再说吧 <em><del>（下辈子）</del></em>。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Dumby的OI生涯</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>数论</tag>
        <tag>质数</tag>
        <tag>约数</tag>
      </tags>
  </entry>
  <entry>
    <title>啊？你是说暑假就剩一星期了？</title>
    <url>/2025/%E5%95%8A%EF%BC%9F%E4%BD%A0%E6%98%AF%E8%AF%B4%E6%9A%91%E5%81%87%E5%B0%B1%E5%89%A9%E4%B8%80%E6%98%9F%E6%9C%9F%E4%BA%86%EF%BC%9F/</url>
    <content><![CDATA[<p>完了完了完了完了暑假怎么就没了😱😱😱<br>这个暑假都干了啥啊😭😭</p>
<span id="more"></span>
<h2 id="分手什么的"><a href="#分手什么的" class="headerlink" title="分手什么的"></a>分手什么的</h2><p>哦对了，原来暑假还分了个手啊，我以为啥都没干呢。</p>
<p>😁😁😭😭</p>
<p>以下是小丑的自述：</p>
<p>这篇的前一篇就是分手那天发的，怎么说呢，越想越气愤吧，有种<strong>始乱终弃玩完了就丢一边</strong>的感觉。<br>本人也是真🤡，我真膈应自己了都。</p>
<p>仔细想想的话其实<strong>这几个月对方天天都在等着我提分手</strong>吧，一开始控制不住自己的X瘾上来就是嗯舔和爽玩，玩了一个学期玩腻了就打算踢了😅</p>
<p>说什么自己又做那个<strong>在心里扣分</strong>的人了，其实是跟谁都愿意蛐蛐就是不愿意和我说罢了。<br><strong>社交圈乱的要命，边界感少的可怜</strong>（别说我之前为什么不说是不是也在心里扣分什么的，我之前没说是因为我之前是晓楚南什么都不懂觉得没什么，现在上帝视角看起来真的是恶心，全是铺垫了）<br>我记得刚开始那段时间隔三岔五的就要提一下它那个军师（这个军师就是我舍友，没有谴责我舍友的意思），我真服了tm到底它是跟我谈还是跟那个军师谈，我是跟它谈还是跟我舍友谈（当然我这里还是针对它而不是我舍友，我舍友是局外人，人品很好的）（还有我这里用“谈”这个字也是搞笑，如果从它玩我的这个角度切入的话这个事情就很合理了）。<br><strong>跟谁都玩的比我开</strong>，跟<strong>它的军师、它的高中的同学朋友，甚至是它的网友</strong>。</p>
<p>我是真🤡啊我去，服了。</p>
<p>刚开始追我的时候还在学校论坛上发什么<strong>吐槽我很冷淡不回它消息</strong>的帖子，说什么<strong>自己都是消息秒回落差很大什么的</strong>；后面我消息秒回，它倒是想回就回，其他<strong>要么不回要么不看要么过个半天什么的敷衍一下</strong>。再到后来就tm发现这东西自己<strong>偷偷把那个帖子给删了</strong>。。我真的😅</p>
<p>以前还说什么初恋分手的原因就是什么它初恋觉得它<strong>冷暴力</strong>它然后冷暴力回去，结果大吵一架不了了之之类的，现在我是知道为什么会觉得冷暴力了，md。</p>
<p>我刚开始那会儿还说服自己信任它，摆脱一开始对它的<strong>“这人就是个绿茶婊，轻佻得很”</strong>的第一印象，我是真🤡。</p>
<p>说什么好聚好散，tm哪里有什么好散，愁标志统一的套话罢了。<br>我分手的时候还问什么以后还能做朋友吗，我去，我也是真。<br><strong>分手前都没把我当个朋友看，分手后还tm想。。</strong></p>
<p>说起来也有点可笑吧，以前还在帖子里暗爽，现在却在帖子里喷。也许真的没我想的这么恶劣，但也只是也许，分都分了，现在只剩我的想法了。<br>算了算了，也没必要花太多心思在这啥身上了，我的暑假也不是只分了手。</p>
<h2 id="山沟沟什么的"><a href="#山沟沟什么的" class="headerlink" title="山沟沟什么的"></a>山沟沟什么的</h2><p>七月底那会儿去了山里睡了一晚上，主要就是去玩玩水吧，也没的什么好玩的了，我拿着手机玩了好久倒是。</p>
<p>哦对了还有一顿丰盛的晚餐（晚餐还能丰盛是因为其实我们是睡在小村子的村部里的，甚至在人家办公室里扎了两个帐篷🤓）</p>
<h2 id="海南什么的"><a href="#海南什么的" class="headerlink" title="海南什么的"></a>海南什么的</h2><p>八月中旬去了趟海南度了十天假，这个还不错，而且还是别人请客的，大部分都不用自己出钱🤓</p>
<p>这辈子第一次来到这么南的地方，这辈子第一次看到这么蓝的海水，这辈子第一次见到这么多的椰树（路边全是椰树，上面好多好多椰子，那里人还说摘个一两个没关系别摘太多就行，可惜树太高没爬上去🤓）。</p>
<p>不过客观点讲的话，请客那人没做好攻略，导致后面没新鲜感开始无聊，而且规划也有些不合理，我后面基本都在酒店打游戏（不过度假嘛毕竟，不打游戏算什么度假）。</p>
<p>我的电脑中途还因为窗户没关被浇透了，还好晾了几天复活了🤓👍🏿</p>
<p>总之呢，整体还行，但是揪出细节来的话就没那么好了，实际下海的时间没占很多，而且花了很多冤枉钱。</p>
<p>最后看看照片吧：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><img src="1.jpg" alt="初到海南" title="初到海南"></th>
<th><img src="2.jpg" alt="夕阳" title="夕阳"></th>
<th><img src="3.jpg" alt="正" title="正"></th>
<th><img src="4.jpg" alt="心爱的小摩托" title="心爱的小摩托"></th>
</tr>
</thead>
<tbody>
<tr>
<td>初见海南</td>
<td>夕阳</td>
<td>正</td>
<td>心爱的小摩托</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th><img src="5.jpg" alt="灯塔" title="灯塔"></th>
<th><img src="7.jpg" alt="海水" title="海水"></th>
<th><img src="8.jpg" alt="好有感觉的路" title="好有感觉的路"></th>
</tr>
</thead>
<tbody>
<tr>
<td>灯塔</td>
<td>海水</td>
<td>好有感觉的两边种满椰子树的路</td>
</tr>
</tbody>
</table>
</div>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Dumby的sb日常</category>
      </categories>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title>无题</title>
    <url>/2023/%E6%97%A0%E9%A2%98/</url>
    <content><![CDATA[<blockquote>
<p>本文是我的一位同学写的，我们无意间在他的桌子上翻到这篇文章，觉得写得甚好，就将它抄到本人的博客上。以下文章是我的抄写版，但我尽量将这位同学每一处批注与涂改都保留了下来。</p>
</blockquote>
<span id="more"></span>
<p><img src="One.jpg" alt="One" title="One"></p>
<p><img src="Two.jpg" alt="Two" title="Two"></p>
<blockquote>
<p>注：“高大”系某高层权威人士，“明”是一名同学。<br>又注：我抄写时疏忽，开头的两行应该放到文末。</p>
</blockquote>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Dumby的sb日常</category>
      </categories>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title>数论学习笔记（约数篇二）</title>
    <url>/2021/%E6%95%B0%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E7%BA%A6%E6%95%B0%E7%AF%87%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<p>本文介绍欧拉函数、同余以及拓展欧几里得算法。</p>
 <span id="more"></span>
<h2 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>1 到 $N$ 中与 $N$ 互质的数的个数被称为欧拉函数，记为 $\varphi(N)$。</p>
<h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><p> <strong>显然，如果 $N$ 为质数，则 $\varphi(N)=N-1$</strong></p>
<p> 欧拉函数为 <strong>积性函数</strong>： <strong>若 $\gcd(a,b)=1$，则 $\varphi(ab)=\varphi(a)\varphi(b)$</strong>。</p>
<p> <strong>若 $n=p^{k}$，$p$ 为质数，则 $\varphi(n)=n(1-\dfrac{1}{p})$</strong>。</p>
<blockquote>
<p>证明：<br>若 $x$ 与 $p^{k}$ 不互质，则有 $p|x$ 成立。<br>$x$ 共有 $\dfrac{n}{p}$ 个，因此 $\varphi(n)=n-\dfrac{n}{p}=n(1-\dfrac{1}{p})$</p>
</blockquote>
<p>若 $N=p_{1}^{c_{1}}p_{2}^{c_{2}}…p_{m}^{c_{m}}$，则：<br>$\varphi(N)=N \times \dfrac{p_{1}-1}{p_{1}} \times \dfrac{p_{2}-1}{p_{2}} \times … \times \dfrac{p_{m}-1}{p_{m}}$<br> $\varphi(N)=N \times \left ( 1-\dfrac{1}{p_{1}} \right ) \times \left ( 1-\dfrac{1}{p_{2}} \right ) \times …  \times \left ( 1-\dfrac{1}{p_{m}} \right )$<br>即：<br>${\small \varphi \left ( n \right ) = n \times \prod_{i=1}^{m} \left ( 1-\frac{1}{p_{i}} \right )} $</p>
<blockquote>
<p>证明：$\varphi$ 是积性函数。把 $n$ 拆成 $p_{i}^{a_{i}}$ 的乘积形式可立即得证。</p>
</blockquote>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>我们只要在分解质因数时顺便将欧拉函数求出来就好了。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">phi</span><span class="params">(<span class="type">int</span> n)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> ans = n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= <span class="built_in">sqrt</span>(n); i++) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (n % i == <span class="number">0</span>) </span><br><span class="line">		&#123;</span><br><span class="line">			ans = ans / i * (i - <span class="number">1</span>);</span><br><span class="line">			<span class="keyword">while</span> (n % i == <span class="number">0</span>)n /= i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (n &gt; <span class="number">1</span>)ans = ans / n * (n - <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="同余"><a href="#同余" class="headerlink" title="同余"></a>同余</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>若 $a \bmod {m} =  b \bmod {m}$ ，则称 $a$ 与 $b$ 同余，写作  $a \equiv b \pmod{m}$</p>
<h3 id="同余类、剩余系"><a href="#同余类、剩余系" class="headerlink" title="同余类、剩余系"></a>同余类、剩余系</h3><p>对于一个集合 ${ x|x=a+km,a \in \left [ 0,m-1 \right ] , k \in Z  }$ 的所有数模 $m$ 同余，余数都是 $a$ 。该集合被称为一个模 $m$ 的<strong>同余类</strong>，简记为 <strong>ā</strong>。<br>模 $m$ 的同余类一共 $m$ 个，它们构成 $m$ 的<strong>完全剩余系</strong>。<br>1 到 $m$ 中与 $m$ 互质的数代表的同余类共有 $\varphi(m)$ 个，它们构成 $m$ 的<strong>简化剩余系</strong></p>
<h3 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h3><p>若正整数 $a$，$n$ 互质，则 $a^{\varphi(n)} \equiv 1\pmod{n}$，其中 $\varphi(n)$ 为欧拉函数。</p>
<h4 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h4><p>设 $S={ a_{1},a_{2},…,a_{\varphi(n)} }$ 为 $n$ 的简化剩余系。<br>设 $a$ 与 $n$ 互质。<br>$\because a \equiv 1\pmod{n}$，$aa_{1} \equiv 1 \pmod{n}$<br>$\therefore aa_{1} \equiv 1 \pmod{n}$<br>同理，$aa_{2},aa_{3},…,aa_{\varphi(n)}\equiv 1 \pmod{n}$<br>$\therefore aa_{1} \times aa_{2} \times…\times aa_{\varphi(n)}\equiv1\pmod{n}$<br>$\therefore a^{\varphi(n)}\left ( a_{1}a_{2}…a_{\varphi(n)} \right )\equiv a_{1}a_{2}…a_{\varphi(n)} \pmod{n}$<br>$\therefore a^{\varphi(n)}\equiv 1 \pmod{n}$</p>
<h3 id="费马小定理"><a href="#费马小定理" class="headerlink" title="费马小定理"></a>费马小定理</h3><p>若 $p$ 为质数，则对于任意整数 $a$，有 $a^{p}\equiv a \pmod{p}$，即 $a^{p-1}\equiv 1\pmod{p}$<br><del>证明太简单了，懒得证</del>（用欧拉函数和欧拉定理证）</p>
<h2 id="扩展欧几里得算法"><a href="#扩展欧几里得算法" class="headerlink" title="扩展欧几里得算法"></a>扩展欧几里得算法</h2><h3 id="贝祖定理（裴蜀定理）"><a href="#贝祖定理（裴蜀定理）" class="headerlink" title="贝祖定理（裴蜀定理）"></a>贝祖定理（裴蜀定理）</h3><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><p>对于任意整数 $a$，$b$，存在一对整数 $x$，$y$，满足 $\mathbf{ax + by = \gcd(a,b)}$。特别地，一定存在 $x$，$y$ 满足 $ax + by = d$。<br>等价的表述：不定方程 $ax + by = c$ （$a$，$b$，$c$ 为整数）有解的充要条件为 $\gcd(a,b)| c$<br>推论：$a$，$b$ 互质等价于 $ax + by = 1$ 有解</p>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>考虑如何求得 $ax + by = d$ 的一个解。这里 $d = \gcd(a,b)$</p>
<p>考虑使用欧几里德算法的思想，令 $a = bq + r$，其中 $r= a \bmod b$；递归求出 $bx + ry = d$ 的一个解。</p>
<p>设求出 $bx + ry = d$ 的一个解为 $x = x_{0}$，$y = y_{0}$，考虑如何把它变形成 $ax + by = d$ 的解。</p>
<p>将 $a = bq + r$ 代入 $ax + by = d$、化简得 $b(xq + y)+ rx = d$</p>
<p>我们令 $xq + y = x_{0}$，$x = y_{0}$，则上式成立</p>
<p>故 $x=y_{0}$，$y=x_{0}-y_{0}q$ 为 $ax + by = d$ 的解</p>
<p>边界情况：$b = 0$ 时，令 $x = 1$，$y = 0$</p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">exgcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> &amp;x, <span class="type">int</span> &amp;y)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!b) </span><br><span class="line">	&#123;</span><br><span class="line">		x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> a;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> d = <span class="built_in">exgcd</span>(b, a % b, y, x);</span><br><span class="line">	y -= a / b * x;</span><br><span class="line">	<span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="求出-ax-by-c-的所有解"><a href="#求出-ax-by-c-的所有解" class="headerlink" title="求出 ax + by = c 的所有解"></a>求出 ax + by = c 的所有解</h4><p>先用 exgcd 求出任意一个解 $x_{0}$ 和 $y_{0}$。<br>则 $ax_{0}+by_{0}=c$<br>再求出 $ax + by = 0$ 的最小（绝对值）解 $x’ = \dfrac{b}{\gcd(a,b)}$ 和 $y’ = \dfrac{-a}{\gcd(a,b)}$<br>则 $(ax_{0}+by_{0})+k(ax’+by’)=c$<br>即 $a(x_{0}+kx’)+b(y_{0}+ky’)=c$<br>所有解就是 $x=x_{0}+kx’$，$y=y_{0}+ky’$，$k \in Z$</p>
<h3 id="乘法逆元"><a href="#乘法逆元" class="headerlink" title="乘法逆元"></a>乘法逆元</h3><p>若整数 <strong>b，m 互质</strong>，并且 $\mathbf{b|a}$，则存在一个整数 $x$，使得 $\mathbf{\dfrac{a}{b}\equiv a \times x\pmod{m}}$。<br>称 $x$ 为 $b$ 的模 $m$ 乘法逆元，记为 $b^{-1} \pmod{m}$。<br>可以推得：<strong>当 $m$ 为质数时，$b^{m-2}$ 即为 $b$ 的乘法逆元（即 $x$ ）。</strong><br>那么咋求逆元捏？</p>
<h4 id="快速幂求逆元"><a href="#快速幂求逆元" class="headerlink" title="快速幂求逆元"></a>快速幂求逆元</h4><h5 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h5><p>快速幂是啥？<br>可以看成是二进制优化的用来求 $\mathbf{a^{b}\bmod p}$ 的东西。</p>
<h5 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h5><p>求逆元相当于求 $b^{p-2}\bmod p$，所以能用快速幂求。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int unsigned long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3000101</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">qm</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> k, <span class="type">int</span> p)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (k) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (k &amp; <span class="number">1</span>)ans = ans * a % p;</span><br><span class="line">		k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">		a = a * a % p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">qm</span>(i, m - <span class="number">2</span>, m));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="扩展欧几里得算法（贝祖定理）求逆元"><a href="#扩展欧几里得算法（贝祖定理）求逆元" class="headerlink" title="扩展欧几里得算法（贝祖定理）求逆元"></a>扩展欧几里得算法（贝祖定理）求逆元</h3><p>求逆元又等价于求 $ax + by = 1$<br>所以可以直接上板子。</p>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">inv</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> x, y;</span><br><span class="line">	<span class="built_in">exgcd</span>(a, b, x, y);</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="线性求逆元"><a href="#线性求逆元" class="headerlink" title="线性求逆元"></a>线性求逆元</h3><p>在求 $i$ 的逆元时，</p>
<p>$\because p=\left \lfloor \dfrac{p}{i} \right \rfloor \times i+p \bmod i$（⌊ ⌋为向下取整），</p>
<p>令 $a = \left \lfloor \dfrac{p}{i} \right \rfloor$，$b = p \bmod i$，</p>
<p>$\therefore p=a \times i+b$</p>
<p>$\because a \times i+b=p$</p>
<p>$\therefore a\times i+b=0 \pmod{p}$</p>
<p>$\therefore a\times i=-b \pmod{p}$</p>
<p>$\therefore i=-\dfrac{b}{a} \pmod{p}$</p>
<p>$\therefore i^{-1}=- \dfrac{a}{b}\pmod{p}$</p>
<p>综上，$i$ 的逆元为 $\dfrac{-\left \lfloor \dfrac{p}{i} \right \rfloor\times i}{p \bmod i}$</p>
<p>设 $inv[ i ]$ 为 $i$ 的逆元，</p>
<p>$\because i^{-1}=-\dfrac{a}{b}\pmod{p}$</p>
<p>$\therefore inv[i]=-a\times b^{-1}\pmod{p}$</p>
<p>$\because b^{-1}=inv[b]$</p>
<p>$\therefore inv[i]=-\dfrac{a}{inv[b]}\pmod{p}$</p>
<p>$\therefore inv[i]=-\dfrac{\left \lfloor \dfrac{p}{i} \right \rfloor}{inv[p\bmod i]}\pmod{p}$</p>
<p>$\therefore inv[i]=\dfrac{p-\left \lfloor \dfrac{p}{i} \right \rfloor}{inv[p\bmod i]\bmod p}(\because x\bmod p=(x+p)\mod p)$</p>
<p>有了公式后就能用线性的复杂度求出每个数的逆元了。</p>
<h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (inv[<span class="number">1</span>] = <span class="number">1</span>, i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">	inv[i] = (p - p / i) * inv[p % i] % p;</span><br></pre></td></tr></table></figure>
<h2 id="线性同余方程"><a href="#线性同余方程" class="headerlink" title="线性同余方程"></a>线性同余方程</h2><p>形如 $ax ≡ c\pmod{m}$ 的方程（关于 $x$），称为线性同余方程。<br>该方程等价于 $ax + my = c$，有解条件为 $\gcd(a,m)| c$ 。<br>所以可以用 拓展$\gcd$ 来求。<br>求出 $x_{0}$ 和 $y_{0}$，满足 $ax_{0}+my_{0}=\gcd(a,m)$。<br>然后 $x=x_{0}\times\dfrac{b}{\gcd(a,m)}$<br>$x$ 即为解。</p>
<p>剩下的下次再说吧。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Dumby的OI生涯</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>数论</tag>
        <tag>约数</tag>
      </tags>
  </entry>
  <entry>
    <title>！！！🏮新年好🏮！！！</title>
    <url>/2022/%E6%96%B0%E5%B9%B4%E5%A5%BD%EF%BC%81%EF%BC%81%EF%BC%81/</url>
    <content><![CDATA[<p>已经是22年了捏。</p>
<p>！！！🏮新年好🏮！！！</p>
<p>Dumby_cat 隆重推出 Dumblog 新年款！！！（其实就是变红了。。。）</p>
<p>总之，祝各位来访者新年快乐！！！</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>站务</category>
      </categories>
      <tags>
        <tag>站务</tag>
        <tag>通知</tag>
      </tags>
  </entry>
  <entry>
    <title>合成器主要类别简介</title>
    <url>/2022/%E5%90%88%E6%88%90%E5%99%A8%E4%B8%BB%E8%A6%81%E7%B1%BB%E5%88%AB%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<p>用本帖记录一下合成器的种类及其基本原理。</p>
<span id="more"></span>
<p>当然，以下合成器类型都是一些最基础的类型，现在的主流合成器通常会将多种合成器结合，功能较多。</p>
<h2 id="减法合成器"><a href="#减法合成器" class="headerlink" title="减法合成器"></a>减法合成器</h2><p>首先就是减法合成器，基本原理就是将一段声音通过滤波器“减去”一部分来得到新的声音。</p>
<p>现在主流合成器基本上都有滤波功能，只不过减法合成器是以该功能为主。</p>
<p>实际上可以将减法合成器看做绝大多数合成器的基础。</p>
<h2 id="加法合成器"><a href="#加法合成器" class="headerlink" title="加法合成器"></a>加法合成器</h2><p>有减法自然有加法。</p>
<p>加法合成器就是通过多种波形相加来得到一些新的波形和声音。</p>
<h2 id="波表合成器"><a href="#波表合成器" class="headerlink" title="波表合成器"></a>波表合成器</h2><p>波表合成器基本就是指那种可以产生很多复杂波形的合成器，像著名的 SERUM 和 Massive 之类的。</p>
<h2 id="FM合成器（调频合成器）"><a href="#FM合成器（调频合成器）" class="headerlink" title="FM合成器（调频合成器）"></a>FM合成器（调频合成器）</h2><p>FM合成器主要就是可以通过一种波形去控制另一种波形。</p>
<p>通常FM合成器会有很多个振荡器来互相产生波形进行调制，从而使声音变得十分多样。</p>
<p>（不过这东西比较难搞）</p>
<h2 id="采样合成器"><a href="#采样合成器" class="headerlink" title="采样合成器"></a>采样合成器</h2><p>显然，这是种基于采样的合成器。</p>
<p>通常采样合成器无法过多改变声音内部结构，只能对声音进行加工之类的。</p>
<h2 id="粒子合成器"><a href="#粒子合成器" class="headerlink" title="粒子合成器"></a>粒子合成器</h2><p>粒子合成器就是将一些声音分成小部分，就像把声音打散成粒子一样，然后进行编辑和加工。</p>
<p>参考：</p>
<ul>
<li><a href="https://www.bilibili.com/video/BV1Ys411i7hF">B站UP主@AndreChen的教学视频 “【合辑】【合成器基础教学】入门/通用/必备知识——Abletive教学视频站”</a></li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Dumby的折腾笔记</category>
      </categories>
      <tags>
        <tag>合成器</tag>
      </tags>
  </entry>
  <entry>
    <title>日乐快生！（补）</title>
    <url>/2025/%E6%97%A5%E4%B9%90%E5%BF%AB%E7%94%9F%EF%BC%81%EF%BC%88%E8%A1%A5%EF%BC%89/</url>
    <content><![CDATA[<p>生日已经过了好几天了，今天才想起来发篇帖子，主要想展示下我的蛋糕😋😋。</p>
<span id="more"></span>
<p>主要我向那个定制蛋糕的客服描述得很清楚了，可是她还是搞不明白我的意思，最后做出来的效果衣驼，只能自己动手改一改了。。</p>
<table>
    <tr>
        <td><center> <img src="1.jpg" width="200" alt="1"/></center></td>
        <td><center> <img src="2.jpg" width="200" alt="2"/></center></td>
        <td><center> <img src="3.jpg" width="200" alt="3"/></center></td>
    </tr>
    <tr>
        <td><center> <img src="4.jpg" width="200" alt="4"/></center></td>
        <td><center> <img src="5.jpg" width="200" alt="5"/></center></td>
        <td><center> <img src="6.jpg" width="200" alt="6"/></center></td>
    </tr>
    <tr>
        <td><center> <img src="7.jpg" width="200" alt="7"/></center></td>
        <td><center> <img src="8.jpg" width="200" alt="8"/></center></td>
        <td><center> <img src="9.jpg" width="200" alt="9"/></center></td>
    </tr>
</table>

<p>🎉😋✨🎊😋🎉✨🎊😋</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Dumby的sb日常</category>
      </categories>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title>暑假，启动！！！</title>
    <url>/2023/%E6%9A%91%E5%81%87%EF%BC%8C%E5%90%AF%E5%8A%A8%EF%BC%81%EF%BC%81%EF%BC%81/</url>
    <content><![CDATA[<p>启动启动启动启动！还有这个！！</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Dumby的sb日常</category>
      </categories>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title>杂七杂八的公式和定理（律）</title>
    <url>/2022/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB%E7%9A%84%E5%85%AC%E5%BC%8F%E5%92%8C%E5%AE%9A%E7%90%86%EF%BC%88%E5%BE%8B%EF%BC%89/</url>
    <content><![CDATA[<p>本贴用来存一些零散的公式以及定理或定律。</p>
<p>总之就是知识大乱炖。</p>
<span id="more"></span>
<h2 id="等比数列求和公式"><a href="#等比数列求和公式" class="headerlink" title="等比数列求和公式"></a>等比数列求和公式</h2><p>设 $\left\{ a_{i} \right\}$ 为等比数列，公比为 $p$，$a_{1}$ 为第一项，前 $n$ 项和为 $S_{n}$，则有：</p>
<ol>
<li>$p\neq 1$ ： $S_{n}=\frac{a_{1}\left(1-p^{n}\right)}{1-p}$</li>
<li>$p=1$ ： $S_{n}=na_{1}$</li>
</ol>
<p>当数列从 $1$ 开始，公比 $p$ 不为 $1$ 时，有：</p>
<p>$\sum_{i=0}^{n}p^{i}=\frac{1-p^{n+1}}{1-p}$</p>
<p>特别的，若 $p\in\left(0,1\right)$，有：</p>
<p>$\sum_{i=0}^{\infty}p^{i}=\frac{1}{1-p}$</p>
<p>重要的是后面两个（尤其最后一个）。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Dumby的OI生涯</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>末流大砖的救赎</title>
    <url>/2025/%E6%9C%AB%E6%B5%81%E5%A4%A7%E7%A0%96%E7%9A%84%E6%95%91%E8%B5%8E/</url>
    <content><![CDATA[<p>我时常怀疑我高考出分那时候就已经死了。我怀疑我考的其实奇差无比，我怀疑我早已紫撒死去，否则我怎么会拿着不算很高但绝对不低的总分却上着末流的大专呢？</p>
<p>我似乎是有些头晕了，也不知是头顶的灯在闪烁，还是我的眼已经迷离。在一亮一暗中，我仿佛回到蝇州二厂，我仿佛还是那只伏在地上抽搐战栗的肉猪。</p>
<span id="more"></span>
<ol>
<li>今天早上一二节缺勤的，早自习无故不到缺勤的，今天之内手写一份情况说明，下午17:15到办公室交给我并说明情况!@所有人 再次提醒，所有课都不允许无故缺勤，保持良好的上课状态才能保持良好的学习状态！！！</li>
<li>今天下午开始，我会挨个给存在挂科现象同学的家长打电话，告知学业清理相关事项，请有挂科的同学们做好准备@所有人。建议是先跟爸爸妈妈汇报一下，不要我一说，爸爸妈妈不知道，你一下子麻爪就不合适</li>
<li><a href="/2025/03/19/%E5%BC%80%E4%BC%9A/">所谓“开会”</a></li>
<li>[“某个会议”]这个是所有人必须参加的哈</li>
<li>班长在今明两天内和学习委员一起，对班级内电分，微积分，大物学习学业有困难的同学进行排查，并安排对相关同学进行专项补习补弱，期中考试结束后以班级为单位提交相关工作的材料，切忌流于形式，可以不组织集中补弱，但是对于相对较难的问题和较为困难的同学可以安排结对复习，对口解题讲题等方式，能多帮助就多帮助，相关材料都可以应用于优班创建材料当中。@全体成员另外各班级强调，学院和学校最近在进行密集查课和查早，一定强调同学们要按时积极上课上早自习，不允许存在缺课，串课等现象发生，教室的摄像头现在上课就开，对于同学们的上课状态有精准到人的把握，所以一定认真上课，不要在上课出现玩手机，打游戏，睡觉等现象，按照校规校际，缺课达到一定次数不仅会影响平时成绩，更可能被直接取消考试资格，请大家一定慎之又慎！认真严肃的向班级同学们强调上课的重要性。 明天早锻炼，后天早自习我都会到操场和教室去，大家一定给同学们强调到位！周三周四周五我会密集查课，对于不到，串课的同学将计入缺勤名单上报给任课教师，大家一定认真上课！以上信息班长们自行阅读，与学习委员讨论，不允许直接转发到班群哈！</li>
<li>电分课注意课堂投入度哈，我这都能看到同学们在干啥，有几个同学在看电子书，有几个同学上课戴耳机，不允许出现这种情况哈@全体成员</li>
<li><a href="/2025/05/23/%E2%80%9C%E5%AD%A6%E4%B9%A0%E4%BA%92%E5%8A%A9%E5%B0%8F%E7%BB%84%E2%80%9D/">所谓“学习互助小组”</a></li>
<li>下午两个班级同学级的来开班会哈，没请假无故缺勤的一律假期通知家长通报期中成绩@全体成员。 [Later]xxx撤回了一条消息，因为有错别字❌。</li>
<li>【重要通知】一、 为督促年级学风建设，强化六级复习，定于6月2日晚19:00在吊楼A107（1,2,3）、A108（4,5）、A109（6,7）、A110（8,9）组织本学期第一次六级模拟考试，请同学们按时到场，有不能到的同学请附上理由找自己的导生请假。二、 端午回来后早锻炼取消，全面恢复早自习，早自习内容为六级英语听力模拟</li>
<li>“无手机课堂倡议书”</li>
<li>各位同学：自明天起，将严查早自习的出勤情况。任何迟到或缺勤的同学将被记录。希望大家今晚早点休息，明天按时到指定教室参加早自习的英语听力模拟@全体成员</li>
<li>[一份包含年级一大半人的表格]以上同学，今天下午78节课到A107补自习，我会在那边组织签到，另外五班早自习没来的同学名单一会五班学委会发出来哈@全体成员 </li>
<li>根据各个班级分配，结合学院同学日常表现，特邀请群内的大家担任本学期学院课堂秩序维护员，工作非常简单，结束后可以按照服务市场为大家发放劳育时长和志愿时长，希望同学们积极配合。为了更好的指导大家开展工作，同时也降低同学们的心理负担，我和xxx老师计划在今晚22:00组织一次简单的线上会议，给同学们说一下我们的工作怎么开展，希望大家不要有心理压力。这是在我们学院内端正学风，弘扬正气的一个开始，同学们就是带动其他同学的一面旗帜，希望大家积极配合，如果有不愿意的同学请私信自己的辅导员说明情况即可，我们不会强迫大家。如果愿意，请大家今晚22:00通过#腾讯会议：xxx参会，我和x老师会给大家说一下怎么开展工作，也为大家再次解释下这个倡议的初衷和目的，感谢大家！@全体成员请大家收到请回复收到</li>
</ol>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Dumby的sb日常</category>
      </categories>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title>杂谈</title>
    <url>/2024/%E6%9D%82%E8%B0%88/</url>
    <content><![CDATA[<p>断更好久（虽然也没人看就是了），这几个月在干什么嘞？🤔</p>
<span id="more"></span>
<p>上一篇文章还是3月份看完沙丘2写的了，后面备考也没什么心思写东西吧。</p>
<h2 id="那么我在干啥呢"><a href="#那么我在干啥呢" class="headerlink" title="那么我在干啥呢"></a>那么我在干啥呢</h2><p>总之就是莫名其妙过了两三个月然后考了乱考一通，考完接着去杭州搞三一，当然最后复交浙全都被刷了就是了。</p>
<p>复交笔试是一点过不了，复的还能让我有动笔的机会，交的，额，写了两题就开摆了，坐在那儿画了半天便便，睡了会儿觉，好不容易终于等到提前半小时交卷，成为第一个走出考场的人捏。🤓</p>
<p>浙大没有笔试，准备了半天的面试最后综合成绩89点多，比去年录取分高一点点，结果排名27，直接out。</p>
<p>最后的结果呢就是上了一个 <del>顶流大专</del> 末流酒吧舞，早自习早操晚自习是一个不落的，搁着上高四呢。</p>
<p>暑假么也没干什么，毕业以后和工程队的xdm出来聚了聚（xdm虽然是各奔东西了，怎么说呢，海内存知己天涯若比邻吧），然后宅家练车，8月出去旅了下游。</p>
<p>暑假的旅游唯一给我非常深刻印象的只有那个绍兴的兜率天宫。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><img src="远景.jpg" alt="远景" title="远景"></th>
<th><img src="近景.jpg" alt="近景" title="近景"></th>
</tr>
</thead>
<tbody>
<tr>
<td>在远处看</td>
<td>在门口往上看</td>
</tr>
</tbody>
</table>
</div>
<p>非常非常大，从最后几阶台阶上来时抬头透过石栏杆看到相当震撼。</p>
<p>这里有个视频，有流量可以看下（11.7MB）。</p>
<p><a href="./视频.mp4">👀👀视频👀👀</a></p>
<p>里面的佛像也是巨大无比：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><img src="佛脚下.jpg" alt="佛脚下" title="佛脚下"></th>
<th><img src="佛脚.jpg" alt="佛脚" title="佛脚"></th>
<th><img src="大佛.jpg" alt="大佛" title="大佛"></th>
</tr>
</thead>
<tbody>
<tr>
<td>佛脚下的人</td>
<td>佛脚</td>
<td>大佛全身</td>
</tr>
</tbody>
</table>
</div>
<h2 id="然后嘞🤔"><a href="#然后嘞🤔" class="headerlink" title="然后嘞🤔"></a>然后嘞🤔</h2><p>然后去了点其他地方，然后就去学校了。</p>
<p>且说这城市，忽阴忽雨，一个月<strong>两天晴天</strong>，不知道以为我在大嘤。</p>
<p>再说这学校，早自习早操晚自习<strong>一个不落下</strong>，看似上大鞋，实则准备<strong>冲击高考</strong>；<strong>弯曲而狭窄</strong>的道路，搭配<strong>反坦减速带</strong>，阿米来了都得颠他两颠；少之可怜的充电桩，莫名其妙建一堆不知道给谁用的停车场（现在还在建。。），时常起火的电瓶车，<strong>经常发生的交通事故</strong>。</p>
<p><strong>简直无敌！</strong></p>
<p>开学以后还和在一个城市的好哥们儿们聚了聚，还是很幸运有人能一起出来的。</p>
<p>开学以后也是看了好几部电影吧，《佐杜洛夫斯基的沙丘》《楚门的世界》《十诫》《白日梦想家》《盗梦空间》《哈利波特》《回到未来》，都是经典了。</p>
<p>除了打游戏看电影之类的，花了小四百买了一堆工具和几辆风火轮玩车模改装，还是很有意思的。</p>
<h2 id="不过"><a href="#不过" class="headerlink" title="不过"></a>不过</h2><p>大鞋确实不同高中，一天天感觉什么也没干但还是非常疲惫，好像没有方向和目标，不知道何去何从。<br>报名了科协和机器人队的比赛也只是强迫自己，实际上是处处被人带着走。<br>学来学去感觉也学不进去什么东西，感觉有点空虚和迷茫。</p>
<h2 id="不过II"><a href="#不过II" class="headerlink" title="不过II"></a>不过II</h2><p>出现了一个人。</p>
<p>🤔🤔🤔，<br>😳😳😳，<br>🥰🥰🥰。</p>
<p>（ta主动的🤓）</p>
<p>悄悄在这个无人问津的博客里说一句，</p>
<p><strong>和ni在一起真的很开心！！😘</strong></p>
<p>额，</p>
<h2 id="其实大鞋也没那么糟糕-吧！🤓"><a href="#其实大鞋也没那么糟糕-吧！🤓" class="headerlink" title="其实大鞋也没那么糟糕 吧！🤓"></a>其实大鞋也没那么糟糕 吧！🤓</h2><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Dumby的sb日常</category>
      </categories>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title>杂题思路笔记</title>
    <url>/2022/%E6%9D%82%E9%A2%98%E6%80%9D%E8%B7%AF%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>本贴用来记录口糊出来的杂题的思路、做法等。</p>
<p>没有代码，可能有错。</p>
<span id="more"></span>
<h2 id="CF490F-Treeland-Tour"><a href="#CF490F-Treeland-Tour" class="headerlink" title="CF490F Treeland Tour"></a>CF490F Treeland Tour</h2><p><a href="https://www.luogu.com.cn/problem/CF490F">题目链接</a>。</p>
<p>DFS + 线段树合并。</p>
<p>树上最长上升子序列在一个以 $u$ 为根的子树内可以看作以 $f_{i}-1$ 为结尾的 LIS + 1（$u$ 节点）+ 以 $f_{i}+1$ 为结尾的 LDS。</p>
<p>至于子树内的 LIS 之前肯定更新过了。</p>
<p>具体的，进行 DFS，从孩子向父亲更新。</p>
<p>对于每个节点，开一棵权值线段树，第 $i$ 个叶子结点存以数值 $i$ 为结尾的 LIS。</p>
<p>DFS 向上回溯时，从以 $u$ 的儿子 $v$ 为根的子树中找出一条最长的 LIS，更新答案，再将 $v$ 的权值线段树合并到 $u$ 上。</p>
<p>合并的时候再考虑一下从已更新的其他儿子的子树中找出的 LIS 或 LDS 与 $v$ 的子树中 LDS 或 LIS 加上 $u$ 形成的 LIS 对答案的贡献。</p>
<p>处理完 $u$ 的子节点后回溯之前将 $f_{u}$ 加到 $u$ 的权值线段树里去。</p>
<h2 id="P3224-HNOI2012-永无乡"><a href="#P3224-HNOI2012-永无乡" class="headerlink" title="P3224 [HNOI2012]永无乡"></a>P3224 [HNOI2012]永无乡</h2><p><a href="https://www.luogu.com.cn/problem/P3224">题目链接</a>。</p>
<p>思路非常简单。</p>
<p>用并查集维护连通块内有哪些岛，再线段树合并到连通块内的根的权值线段树上。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Dumby的OI生涯</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷 P1654 OSU!</title>
    <url>/2022/%E6%B4%9B%E8%B0%B7-P1654-OSU/</url>
    <content><![CDATA[<p>三倍经验。</p>
<span id="more"></span>
<h2 id="CF235B-Let’s-Play-Osu"><a href="#CF235B-Let’s-Play-Osu" class="headerlink" title="CF235B Let’s Play Osu!"></a>CF235B Let’s Play Osu!</h2><p>分类讨论一下再算下期望就行。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="comment">//#define int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp(x,y) make_pair(x,y)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb(x) push_back(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PII pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD=<span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1000002</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">10000001</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;<span class="keyword">register</span> <span class="type">char</span> c=<span class="built_in">getchar</span>();<span class="keyword">register</span> <span class="type">int</span> s=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">for</span>(;!<span class="built_in">isdigit</span>(c);c=<span class="built_in">getchar</span>())<span class="keyword">if</span>(c==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">-1</span>;<span class="keyword">for</span>(;<span class="built_in">isdigit</span>(c);c=<span class="built_in">getchar</span>())s=(s&lt;&lt;<span class="number">3</span>)+(s&lt;&lt;<span class="number">1</span>)+c-<span class="string">&#x27;0&#x27;</span>;<span class="keyword">return</span> s*f;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">readd</span><span class="params">()</span></span>&#123;<span class="type">int</span> y=<span class="number">0</span>;<span class="type">char</span> h=<span class="built_in">getchar</span>();<span class="keyword">while</span>(h&lt;<span class="string">&#x27;0&#x27;</span>||h&gt;<span class="string">&#x27;9&#x27;</span>)h=<span class="built_in">getchar</span>();<span class="keyword">while</span>(h&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;h&lt;=<span class="string">&#x27;9&#x27;</span>)y=y*<span class="number">10</span>+h-<span class="string">&#x27;0&#x27;</span>,h=<span class="built_in">getchar</span>();<span class="keyword">if</span>(h==<span class="string">&#x27;.&#x27;</span>)&#123;h=<span class="built_in">getchar</span>();<span class="type">double</span> t=<span class="number">0</span>,t2=<span class="number">0.1</span>;<span class="keyword">while</span>(h&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;h&lt;=<span class="string">&#x27;9&#x27;</span>)t=t+t2*(h-<span class="string">&#x27;0&#x27;</span>),t2/=<span class="number">10</span>,h=<span class="built_in">getchar</span>();<span class="keyword">return</span> y+t;&#125;<span class="keyword">return</span> y;&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">long</span> <span class="type">double</span> p;</span><br><span class="line"><span class="type">long</span> <span class="type">double</span> ff;</span><br><span class="line"><span class="type">long</span> <span class="type">double</span> aa,bb;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	n=<span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		p=<span class="built_in">readd</span>();</span><br><span class="line">		ff=ff+p*(<span class="number">2</span>*aa+<span class="number">1</span>);</span><br><span class="line">		aa=p*(aa+<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%.15Lf&quot;</span>,ff);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="洛谷-P1365-WJMZBMR打osu-Easy"><a href="#洛谷-P1365-WJMZBMR打osu-Easy" class="headerlink" title="洛谷 P1365 WJMZBMR打osu! / Easy"></a>洛谷 P1365 WJMZBMR打osu! / Easy</h2><p>同上。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1000001</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">char</span> a[N];</span><br><span class="line"><span class="type">long</span> <span class="type">double</span> x,y;</span><br><span class="line"><span class="type">long</span> <span class="type">double</span> len;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,a+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(a[i]==<span class="string">&#x27;o&#x27;</span>)&#123;</span><br><span class="line">			x=y+len*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">			len+=<span class="number">1.0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(a[i]==<span class="string">&#x27;x&#x27;</span>)&#123;</span><br><span class="line">			x=y;</span><br><span class="line">			len=<span class="number">0.0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			x=y+len+<span class="number">0.5</span>;</span><br><span class="line">			len=len/<span class="number">2.0</span>+<span class="number">0.5</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		y=x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%.4Lf&quot;</span>,x);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="洛谷-P1654-OSU"><a href="#洛谷-P1654-OSU" class="headerlink" title="洛谷 P1654 OSU!"></a>洛谷 P1654 OSU!</h2><p>需要注意推高次期望（这里是三次）时不能直接把原来的期望乘个几次，而要每<strong>次</strong>计算一遍。</p>
<p>如本题：</p>
<p>设 $a \left [ i \right ]$ 为一次幂，$b \left [ i \right ]$ 为二次，$f \left [ i \right ]$ 为三次，$p$ 为正确概率。<br>那么有：</p>
<p>$a \left [ i \right ] = p \left (a \left [i-1 \right ]+1 \right )$</p>
<p>$b \left [ i \right ] = p \left ( b \left [i-1 \right ] + 2 \times a \left [i-1 \right ] + 1 \right )$</p>
<p>$f \left [ i \right ] = f \left [i-1 \right ] + p \left (3 \times b \left [i-1 \right ] + 3 \times a \left [i-1 \right ] + 1 \right )$</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;<span class="keyword">register</span> <span class="type">char</span> c=<span class="built_in">getchar</span>();<span class="keyword">register</span> <span class="type">int</span> s=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">for</span>(;!<span class="built_in">isdigit</span>(c);c=<span class="built_in">getchar</span>())<span class="keyword">if</span>(c==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">-1</span>;<span class="keyword">for</span>(;<span class="built_in">isdigit</span>(c);c=<span class="built_in">getchar</span>())s=(s&lt;&lt;<span class="number">3</span>)+(s&lt;&lt;<span class="number">1</span>)+c-<span class="string">&#x27;0&#x27;</span>;<span class="keyword">return</span> s*f;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">readd</span><span class="params">()</span></span>&#123;<span class="type">int</span> y=<span class="number">0</span>;<span class="type">char</span> h=<span class="built_in">getchar</span>();<span class="keyword">while</span>(h&lt;<span class="string">&#x27;0&#x27;</span>||h&gt;<span class="string">&#x27;9&#x27;</span>)h=<span class="built_in">getchar</span>();<span class="keyword">while</span>(h&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;h&lt;=<span class="string">&#x27;9&#x27;</span>)y=y*<span class="number">10</span>+h-<span class="string">&#x27;0&#x27;</span>,h=<span class="built_in">getchar</span>();<span class="keyword">if</span>(h==<span class="string">&#x27;.&#x27;</span>)&#123;h=<span class="built_in">getchar</span>();<span class="type">double</span> t=<span class="number">0</span>,t2=<span class="number">0.1</span>;<span class="keyword">while</span>(h&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;h&lt;=<span class="string">&#x27;9&#x27;</span>)t=t+t2*(h-<span class="string">&#x27;0&#x27;</span>),t2/=<span class="number">10</span>,h=<span class="built_in">getchar</span>();<span class="keyword">return</span> y+t;&#125;<span class="keyword">return</span> y;&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">long</span> <span class="type">double</span> p,ff,aa,bb;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	n=<span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		p=<span class="built_in">readd</span>();</span><br><span class="line">		ff=ff+p*(<span class="number">3</span>*bb+<span class="number">3</span>*aa+<span class="number">1</span>);</span><br><span class="line">		bb=(bb+<span class="number">2</span>*aa+<span class="number">1</span>)*p;</span><br><span class="line">		aa=p*(aa+<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%.1Lf&quot;</span>,ff);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Dumby的OI生涯</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>DP</tag>
        <tag>期望</tag>
        <tag>线性DP</tag>
      </tags>
  </entry>
  <entry>
    <title>树形DP学习笔记</title>
    <url>/2021/%E6%A0%91%E5%BD%A2DP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>来做一些树形DP的经典题目吧。</p>
<span id="more"></span>
<p>开始开始！</p>
<h2 id="为什么叫树形DP？与线性DP有什么区别？"><a href="#为什么叫树形DP？与线性DP有什么区别？" class="headerlink" title="为什么叫树形DP？与线性DP有什么区别？"></a>为什么叫树形DP？与线性DP有什么区别？</h2><p>两者的本质一致，只不过是在处理数据时的迭代方式不同了而已。<br>即，数据间迭代关系由线性（线性DP）变成了非线性（树形DP）。<br>举个栗子，如下两题：<br><a href="https://www.luogu.com.cn/problem/P1115">最大子段和</a>和<a href="https://www.luogu.com.cn/problem/P1122">最大子树和</a></p>
<p>前者是 给出一个长度为 n 的序列 a，选出其中连续且非空的一段使得这段和最大。</p>
<p>后者是 给出一个节点数为 n 的树 a，选出其中几个连续节点（包括根节点）的非空集合使得这段和最大。</p>
<p>两者的思想一模一样，只有<strong>迭代的方式</strong>不一样。<br>甚至可以说，前者也只是后者的一种特殊情况。<br>如左侧为一棵树（最大子树和的情况），而右侧则是一棵退化的树（最大子段和的情况）。</p>
<p><img src="https://img-blog.csdnimg.cn/20210527202353320.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0R1bWJ5X2NhdA==,size_16,color_FFFFFF,t_70" alt="这是一棵树">        <img src="https://img-blog.csdnimg.cn/20210527202414265.PNG" alt="这是一棵退化的树"><br>所以，不能把树形DP当做单独的一种算法来学（<del>话说DP好像本来就算不上是算法</del>）。</p>
<h2 id="树形DP的几个经典应用"><a href="#树形DP的几个经典应用" class="headerlink" title="树形DP的几个经典应用"></a>树形DP的几个经典应用</h2><h3 id="树的直径"><a href="#树的直径" class="headerlink" title="树的直径"></a>树的直径</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>一棵树中两个节点之间的最远距离。</p>
<h4 id="求解"><a href="#求解" class="headerlink" title="求解"></a>求解</h4><p>如果单纯地讨论这个问题，可以通过跑两次DFS实现，后面有讲找所有点能到的最远距离，这里就不多讲了。<br>附：<a href="http://so.ssr.wiki/?%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84%E6%80%8E%E4%B9%88%E6%B1%82%20DFS">DFS法求树的直径</a></p>
<p>那么怎么通过树形DP解决该问题呢？</p>
<p>设 $f1[i]$ 为以 $i$ 节点为根节点的子树中， $i$ 到叶子节点的最大距离；<br>设 $f2[i]$ 为以 $i$ 节点为根节点的子树中， $i$ 到叶子节点的次大（第二大）距离。<br>令 $son$ 为 $i$ 的儿子<br>设 $w[i][son]$ 为 $son$ 到 $i$ 的路径长度<br>下面用代码解释：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>( f1[i] &lt; f1[son] + w[i][son] ) </span><br><span class="line">&#123;<span class="comment">//如果i节点到叶节点的最大距离 小于 son节点到叶节点的最大距离 加上 i节点到son节点的距离</span></span><br><span class="line">	f2[i]=f1[i];<span class="comment">//将i节点到叶节点的最大值变成次大值</span></span><br><span class="line">	f1[i]=f1[son]+w[i][son];<span class="comment">//更新最大值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>( f2[i] &lt; f1[son] + w[i][son] )</span><br><span class="line">&#123;<span class="comment">//如果i的最大值大于son的，但i的次大值小于son</span></span><br><span class="line">	f2[i]=f1[son]+w[i][son];<span class="comment">//更新次大值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>最后的直径则是 $(f1[i]+f2[i])$ 的最大值。</p>
<p>如果是邻接表的话则是：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dp</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	v[x]=<span class="number">1</span>;   <span class="comment">//v 数组记录点是否被走过</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = head[x]; i; i = nxt[i])&#123;</span><br><span class="line">		<span class="type">int</span> j = to[i];</span><br><span class="line">		<span class="keyword">if</span>(v[j]) <span class="keyword">continue</span>;  <span class="comment">//如果点做走过则跳过</span></span><br><span class="line">		<span class="built_in">dp</span>(j);</span><br><span class="line">		ans = <span class="built_in">max</span>(ans, d[x] + d[j] + w[i]);</span><br><span class="line">		d[x] = <span class="built_in">max</span>(d[x], d[j] + w[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>最后直径就是 ans 的值。</p>
<h3 id="树的重心"><a href="#树的重心" class="headerlink" title="树的重心"></a>树的重心</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>找一个点，使其所有子树中的最大子树节点数最少（或从此点将树分成两半，分成的两棵树权值差最小），该点即为该树的重心。</p>
<h4 id="求解-1"><a href="#求解-1" class="headerlink" title="求解"></a>求解</h4><p>可用DFS求解<br>同样地，附上链接：<br><a href="http://so.ssr.wiki/?%E6%A0%91%E7%9A%84%E9%87%8D%E5%BF%83%E6%80%8E%E4%B9%88%E6%B1%82">DFS法求树的重心</a></p>
<h5 id="例题：洛谷P1364：医院设置"><a href="#例题：洛谷P1364：医院设置" class="headerlink" title="例题：洛谷P1364：医院设置"></a>例题：<a href="https://www.luogu.com.cn/problem/P1364">洛谷P1364：医院设置</a></h5><h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><p>给定一棵带权二叉树，相邻两节点之间距离为 1 ，求出该树的重心，使每个点到重心的距离与点的权值的乘积 的总和 最小。</p>
<h5 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h5><p>设 $f[i]$ 为以 $i$ 为根的的总距离， $size[i]$ 为以 $i$ 为根的子树大小（“ 大小 ” 指的是带权的大小）<br><del>显然</del>，<br>$ans = min { f[i] ， 1 &lt;= i &lt;= n }$<br>那么，我们只要DFS求出任意一个点的 $f$ ，再通过转移方程求出所有的 $f$ 就好了<br>为了方便，我们先DFS求出 $f[1]$ 。<br>转移方程如下，对于每个 $i$ 可到达的 $j$ 点（ $j$ 为 $i$ 的儿子）：</p>
<p>$f[j] = f[i] + size[1] − size[j] − size[j]$</p>
<p>当我们从 $i$ 点转移到 $j$ 点时（即根从 $i$ 变为 $j$ 时），每个 $j$ 的子树的节点到根的距离都减 1 。本来 $j$ 的子树的节点应该到 $i$ 这个节点，但因为根节点下移一个，所以距离全部减 1 （- $size[j]$）。<br>同理，在根节点上方的节点到根节点的距离都加上 1 ， 总路程就加了（$size[1]$ − $size[j]$）。<br>$size[1]$ 即为整棵树的大小， $size[j]$则是除了 $j$ 节点的子树以外的节点数。<br><a href="https://www.luogu.com.cn/blog/GetKeyState/solution-p1364">参考博客</a></p>
<h6 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h6><p>这篇代码是蛮早写的，码风和后面不一致，敬请谅解。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,a,b,l,r,cn;</span><br><span class="line"><span class="type">int</span> dd[<span class="number">10000</span>],f[<span class="number">100000</span>],to[<span class="number">10000</span>],next[<span class="number">10000</span>],head[<span class="number">10000</span>],w[<span class="number">10000</span>];</span><br><span class="line"><span class="comment">//这里的 dd 数组就是 size 数组</span></span><br><span class="line"><span class="type">int</span> ans=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">( <span class="type">int</span> u , <span class="type">int</span> fa , <span class="type">int</span> dep )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	dd[u] = w[u];</span><br><span class="line">	<span class="keyword">for</span>( <span class="type">int</span> i = head[u] ; i ; i = next[i] )   <span class="comment">//邻接表储存</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>( to[i] != fa ) </span><br><span class="line">		&#123;   <span class="comment">//如果该点不是叶子节点</span></span><br><span class="line">			<span class="built_in">dfs</span>( to[i] , u , dep+<span class="number">1</span> );   <span class="comment">//继续向下搜</span></span><br><span class="line">			dd[u] += dd[to[i]];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	f[<span class="number">1</span>] += w[u] * dep;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dp</span><span class="params">( <span class="type">int</span> u , <span class="type">int</span> fa )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>( <span class="type">int</span> i = head[u] ; i ; i = next[i] ) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>( to[i] != fa )</span><br><span class="line">		&#123;</span><br><span class="line">			f[to[i]] = f[u] + dd[<span class="number">1</span>] - dd[to[i]]*<span class="number">2</span>;</span><br><span class="line">			<span class="built_in">dp</span>( to[i] , u );</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	ans = <span class="built_in">min</span>( ans , f[u] );</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">1</span> ; i &lt;= n ; i ++ )</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;w[i] , &amp;l , &amp;r);</span><br><span class="line">		<span class="keyword">if</span>( l )</span><br><span class="line">		&#123;</span><br><span class="line">			to[++cn] = l;</span><br><span class="line">			next[cn] = head[i];</span><br><span class="line">			head[i] = cn;</span><br><span class="line">			to[++cn] = i;</span><br><span class="line">			next[cn] = head[l];</span><br><span class="line">			head[l] = cn;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>( r )</span><br><span class="line">		&#123;</span><br><span class="line">			to[++cn] = r;</span><br><span class="line">			next[cn] = head[i];</span><br><span class="line">			head[i] = cn;</span><br><span class="line">			to[++cn] = i;</span><br><span class="line">			next[cn] = head[r];</span><br><span class="line">			head[r] = cn;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">dfs</span>( <span class="number">1</span> , <span class="number">0</span> , <span class="number">0</span> );</span><br><span class="line">	<span class="built_in">dp</span>( <span class="number">1</span> , <span class="number">0</span> );</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这里还有道进阶的题目 <del>（就当做习题好了）</del>。<br>题解的话，<del>我有时间写。。。吧</del><br>题目：<a href="http://poj.org/problem?id=3140">POJ-3140：Contestants Division</a></p>
<h3 id="最大子树"><a href="#最大子树" class="headerlink" title="最大子树"></a>最大子树</h3><h4 id="例题：最大子树和"><a href="#例题：最大子树和" class="headerlink" title="例题：最大子树和"></a>例题：<a href="https://www.luogu.com.cn/problem/P1122">最大子树和</a></h4><h5 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h5><p>给出一个节点数为 n 的树 a，选出其中几个连续节点（包括根节点）的非空集合使得这段和最大。</p>
<h5 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h5><p>前面说了树形DP与线性DP思想一致，在这题上就能得到充分体现。<br>首先，每个点有两种状态：取或不取。<br>开一个vector来存储每一个节点的儿子。<br>设 $f[i][1]$ 为以 $i$ 为根的最大子树和（取根节点），$f[i][0]$ 为以 $i$ 为根的最大子树和（不取根节点）<br>那么，转移方程就出来了：</p>
<p>$f[i][1]+=max { f[son][1] ， f[son][0] }$</p>
<p>$f[i][1]$ 每次加上自己儿子取或不取中大的一个（因为权值可能有负数，所以有时不取会比去了大）。</p>
<p>附上代码<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, x, y;</span><br><span class="line"><span class="type">int</span> a[<span class="number">17000</span>], v[<span class="number">17000</span>], f[<span class="number">17000</span>][<span class="number">2</span>];</span><br><span class="line">vector &lt; <span class="type">int</span> &gt; son[<span class="number">17000</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">find</span><span class="params">(<span class="type">int</span> root)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	f[root][<span class="number">1</span>] = a[root];</span><br><span class="line">	f[root][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; son[root].<span class="built_in">size</span>(); i++) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> y = son[root][i];</span><br><span class="line">		<span class="built_in">find</span>(y);</span><br><span class="line">		f[root][<span class="number">1</span>] += <span class="built_in">max</span>(f[y][<span class="number">1</span>], f[y][<span class="number">0</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">		son[y].<span class="built_in">push_back</span>(x);</span><br><span class="line">		v[x] = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!v[i]) </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">find</span>(i);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, <span class="built_in">max</span>(f[i][<span class="number">0</span>], f[i][<span class="number">1</span>]));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>仔细观察发现， $f[i][0]$ 不论如何都是 0 ，所以可以对上面的代码进行优化，把 $f[i][0]$ 直接改成 0 ，不必再更新。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, x, y;</span><br><span class="line"><span class="type">int</span> a[<span class="number">17000</span>], v[<span class="number">17000</span>], f[<span class="number">17000</span>];</span><br><span class="line">vector &lt; <span class="type">int</span> &gt; son[<span class="number">17000</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">find</span><span class="params">(<span class="type">int</span> root)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	f[root] = a[root];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; son[root].<span class="built_in">size</span>(); i++) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> y = son[root][i];</span><br><span class="line">		<span class="built_in">find</span>(y);</span><br><span class="line">		f[root] += <span class="built_in">max</span>(f[y], <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">		son[y].<span class="built_in">push_back</span>(x);</span><br><span class="line">		v[x] = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!v[i]) </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">find</span>(i);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, f[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="没有上司的舞会"><a href="#没有上司的舞会" class="headerlink" title="没有上司的舞会"></a><a href="https://www.luogu.com.cn/problem/P1352">没有上司的舞会</a></h3><p>经典老题</p>
<h5 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h5><p>给出一棵带权树，要求相邻的两点不能同时取，求能取到的最大权值和。</p>
<h5 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h5><p>同样地，每个点有两种状态，取或不取。<br>开一个vector来存储每一个节点的儿子。<br>我们设 $f[i][1]$ 为取根节点时子树取到的最大值， $f[i][0]$ 为<strong>不</strong>取根节点时子树取到的最大值。</p>
<p><strong>有没有发现这道题和最大子树和非常像？</strong> 唯一的区别就是后者比前者多了一个约束条件：相邻的两个点不能同时取。<br>那么，我们只要将原来的代码稍作改动即可。<br>即将转移方程改为：</p>
<p>$ f[i][1] += f[son][0] ； $<br>$f[i][0] += max { f[son][1] ， f[son][0] } ；$</p>
<p>当取根节点时，它的儿子节点只能不取； 当不取根节点时，它的儿子节点可以选择取或不取。<br>下面附上代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">vector &lt; <span class="type">int</span> &gt; son[<span class="number">10000</span>];</span><br><span class="line"><span class="type">int</span> f[<span class="number">10000</span>][<span class="number">2</span>], v[<span class="number">10000</span>], h[<span class="number">10000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	f[x][<span class="number">1</span>] = h[x];</span><br><span class="line">	f[x][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; son[x].<span class="built_in">size</span>(); i++) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> y = son[x][i];</span><br><span class="line">		<span class="built_in">find</span>(y);</span><br><span class="line">		f[x][<span class="number">1</span>] += f[y][<span class="number">0</span>];</span><br><span class="line">		f[x][<span class="number">0</span>] += <span class="built_in">max</span>(f[y][<span class="number">1</span>], f[y][<span class="number">0</span>]);  <span class="comment">//区别在这里</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;h[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> x, y;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">		son[y].<span class="built_in">push_back</span>(x);</span><br><span class="line">		v[x] = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!v[i]) </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">find</span>(i);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, <span class="built_in">max</span>(f[i][<span class="number">1</span>], f[i][<span class="number">0</span>]));</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="二叉苹果树"><a href="#二叉苹果树" class="headerlink" title="二叉苹果树"></a><a href="https://www.luogu.com.cn/problem/P2015">二叉苹果树</a></h3><p>这也是道经典题目。<br>做过树形DP的肯定做过这道和上一道题。</p>
<h5 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h5><p>给定一棵带权二叉树，要求减掉几条枝，求保留 $m$ 条枝能保留的最大权值和。</p>
<h5 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h5><p>设 $f[i][j]$ 为以 $i$ 为根节点的子树 取 $j$ 条枝 的最大权值和。<br>这道题可以看做是树上的01背包：<br>$m$ 即为背包容量，每条边的体积为 1 ，价值为点的权值<br>下面在代码中解释</p>
<h5 id="代码及解释"><a href="#代码及解释" class="headerlink" title="代码及解释"></a>代码及解释</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, m, a, b, cn, c;</span><br><span class="line"><span class="type">int</span> to[<span class="number">100009</span>], head[<span class="number">100009</span>], nxt[<span class="number">100009</span>], w[<span class="number">1000009</span>], f[<span class="number">10000</span>][<span class="number">1000</span>];</span><br><span class="line"><span class="comment">//to,head,nxt,w为邻接表储存：to 储存边通向的点，nxt 储存下一条边，w 储存边的权值</span></span><br><span class="line"><span class="comment">//f 上面解释了</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = head[x]; i; i = nxt[i]) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> y = to[i];<span class="comment">//y 为 x 的儿子节点</span></span><br><span class="line">		<span class="built_in">dfs</span>(y);<span class="comment">//向下搜索，直到叶子节点</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = m; j &gt;= <span class="number">1</span>; j--) </span><br><span class="line">		&#123;<span class="comment">//因为是01背包所以要倒着枚举</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> k = j - <span class="number">1</span> ; k &gt;= <span class="number">0</span>; k--) </span><br><span class="line">			&#123;<span class="comment">//             ↑减一是因为其如果要由儿子节点推得最大值，则至少要连接一个儿子，所以至少需要一条边</span></span><br><span class="line">				f[x][j] = <span class="built_in">max</span>(f[x][j], f[x][j - k - <span class="number">1</span>] + f[y][k] + w[i]);</span><br><span class="line">				<span class="comment">//以 x 为根的子树在选 j 条枝时总数等于</span></span><br><span class="line">				<span class="comment">//max&#123; 它本身，它的左子树选 k 条的最大值+它的右子树选 m-k-1 条枝的最大值 + 边权 &#125;</span></span><br><span class="line">				<span class="comment">//这里 j-k 还要 -1 是因为如果要两个儿子一起来推得最大值，则还要有一条边来连接根节点和儿子节点</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">		nxt[++cn] = head[a];</span><br><span class="line">		to[cn] = b;</span><br><span class="line">		head[a] = cn;</span><br><span class="line">		w[cn] = c;</span><br><span class="line">		<span class="comment">//邻接表储存</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, f[<span class="number">1</span>][m]);</span><br><span class="line">	<span class="comment">//输出以 1 为根节点的树选 m 条边的最大权值和，即答案</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>OK，基础应用讲的差不多了，接下来看几题例题。</p>
<h2 id="应用升级"><a href="#应用升级" class="headerlink" title="应用升级"></a>应用升级</h2><h3 id="树上背包"><a href="#树上背包" class="headerlink" title="树上背包"></a>树上背包</h3><h4 id="例题：选课"><a href="#例题：选课" class="headerlink" title="例题：选课"></a>例题：<a href="https://www.luogu.com.cn/problem/P2014">选课</a></h4><p>又一题经典老题 <del>（比本蒟蒻还大10岁）</del></p>
<h5 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h5><p>一个背包，容量为 M ，物品总数为 N ，每个物品体积为 1 ，价值为 $s[i]$ ，有一些物品需要在其他物品选择后才能选（即要选此物品必须先选另一个物品），求装满背包能得到的最大价值。</p>
<h5 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h5><p>这道题其实稍微转化一下就变成上面那道二叉苹果树了。<br>两者区别在于，上题是一棵树，而这题是森林。<br>其实，只要将 0 号节点 设为森林中的每一棵树的根节点的父节点，那么，就将这一片森林转化成一棵树了。<br>同时，因为加了一个 0 号节点，所以要将 M 加一。<br>其他基本与上题一致，具体在代码中解释<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, m, cn;</span><br><span class="line"><span class="type">int</span> f[<span class="number">10009</span>][<span class="number">1009</span>], head[<span class="number">10009</span>], to[<span class="number">10009</span>], nxt[<span class="number">10009</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dp</span><span class="params">(<span class="type">int</span> x)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = head[x]; i; i = nxt[i]) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> y = to[i];</span><br><span class="line">		<span class="built_in">dp</span>(y);</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = m + <span class="number">1</span>; j &gt;= <span class="number">1</span>; j--) </span><br><span class="line">		&#123;<span class="comment">//因为加了 0 节点，所以 m+1</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; j; k++) </span><br><span class="line">			&#123;<span class="comment">//k不能取 j 是因为要去掉该子树的根节点</span></span><br><span class="line">				f[x][j] = <span class="built_in">max</span>(f[x][j], f[y][k] + f[x][j - k]);</span><br><span class="line">				<span class="comment">//这里 j-k 不需要减一是因为这道题取的是点而不是边，所以最多只需要减一个点。</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> fa;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;fa, &amp;f[i][<span class="number">1</span>]);</span><br><span class="line">		nxt[++cn] = head[fa];</span><br><span class="line">		to[cn] = i;</span><br><span class="line">		head[fa] = cn;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">dp</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, f[<span class="number">0</span>][m + <span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这道题和上道题在DP时（转移方程处）都不需要比较子树和 m 的大小是因为当 m 超出子树大小时，$f$ 数组中储存的数为 0 ，因为这两道题的数据都不可能小于 0 ，所以 0 一定不会成为最大值，也就不会影响结果。</p>
<p>THEN NEXT！！！<br>福利（做一题赚一题）：一道<strong>几乎</strong>一模一样的题目：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1561">HDU-1561：The More,The Better</a>。</p>
<h3 id="换根法"><a href="#换根法" class="headerlink" title="换根法"></a>换根法</h3><h4 id="例题1：积蓄程度"><a href="#例题1：积蓄程度" class="headerlink" title="例题1：积蓄程度"></a>例题1：<a href="https://www.acwing.com/problem/content/289/">积蓄程度</a></h4><h5 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h5><p>给定一颗无向带权树，权值代表两点间流量的最大值，找一个节点作为根，向叶子节点流水（根节点的水流可以认为无限大），使整棵树的流水量最大。（建议自己读下acwing题面）<br>如图：<br><img src="https://img-blog.csdnimg.cn/20210528110359218.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0R1bWJ5X2NhdA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h5 id="题解-5"><a href="#题解-5" class="headerlink" title="题解"></a>题解</h5><p>这道题的思路是 二次扫描 + 换根法 。<br>设 $d[i]$ 为以 $i$ 为根的子树的总流量 ，  $f[i]$ 表示以 $i$ 为根到所有点的总流量。<br>以上图为例：<br>上图中，假如以 1 为根节点，则 $d[4]$ = 5 + 10 = 15 ; $d[1]$ = $f[1]$ = 11 + $min$ { 13 ， $d[4]$ } = 24;<br>两次扫描处理的东西不同：<br>第一次扫描：取一个点 DFS 一遍搜出所有的 $d[i]$；<br>第二次扫描：DP求出所有的 $f[i]$ 。<strong>&lt;= 换根法体现在这里</strong></p>
<p>下面分别来讲讲两次扫描的具体过程</p>
<h6 id="第一次扫描"><a href="#第一次扫描" class="headerlink" title="第一次扫描"></a>第一次扫描</h6><blockquote>
<p>取一个点 DFS 一遍搜出所有的 $d[i]$</p>
</blockquote>
<p>为了方便，我们这里取 1 号点开始DFS <del><em>（记住这个 “ 为了方便 ” ）</em></del><br>一棵树本来就是具有递归性质的，所以直接按照DFS的板子打就行了。<br>递归边界：递归至叶子节点处停止。<br>递归方程：<br>设 $x$ 为当前节点， $j$ 为 $x$ 的儿子，则 $d[x]= \sum_{j}^{j \in x}  \min { d[j] , w[x][j] }  $<br><em>（$w$ 数组存的是边的权值）</em><br>方程什么意思呢？<br>如图：<br><img src="https://img-blog.csdnimg.cn/20210528154003549.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0R1bWJ5X2NhdA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>首先DFS至 2 、3、5 号节点，此时 $d[2]$ = $\infty$ ， $d[3]$ = $\infty$ ， $d[5]$ = $\infty$。</p>
<p>接下来，因为 $d[3]$ 无限大，无法全部通过管道，所以只能从 边~3,4~ 中通过 5 的流量；<br>同理，因为 $d[5]$ 无限大，无法全部通过管道，所以只能从 边~5,4~ 中通过 10 的流量；<br>这样，子树中到达 4 节点的的流量就是 5 + 10 = 15 ， 所以 $d[4]$ = 15。</p>
<p>同理，因为 $d[4]$ =15 &gt; $w[1][4]$ = 13，无法全部通过管道，所以只能从 边~1,4~ 中通过 13 的流量；<br>因为 $d[2]$ 无限大，无法全部通过管道，所以只能从 边~1,2~ 中通过 11 的流量；<br>这样，子树中到达 1 节点的流量就是 13 + 11 = 24 ， 所以 $d[1]$ = 24。<br>又因为 1 号点是整棵树的根节点，所以 $f[1]$ = $d[1]$ = 24 。</p>
<p>如何判断叶子节点？<br>只需要记录下每个节点的度数就行了，如果度数为 1 ，则该节点为叶子节点。</p>
<p>所以，第一次扫描的代码就能打出来了。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs_d</span><span class="params">( <span class="type">int</span> x, <span class="type">int</span> fa )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>( deg[x] == <span class="number">1</span> ) <span class="comment">//deg 数组存储节点的度数</span></span><br><span class="line">	&#123;</span><br><span class="line">		d[x] = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">		<span class="keyword">return</span> d[x];</span><br><span class="line">	&#125;  <span class="comment">//到达叶子节点时的处理，即递归边界</span></span><br><span class="line">	</span><br><span class="line">	d[x] = <span class="number">0</span>;  <span class="comment">//将根节点初值赋为 0 </span></span><br><span class="line">	<span class="keyword">for</span>( <span class="type">int</span> i = head[x] ; i ; i = nxt[i] )  <span class="comment">//邻接表储存</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> j = to[i];  <span class="comment">//j 是 x 的子节点</span></span><br><span class="line">		<span class="keyword">if</span>( j == fa ) <span class="keyword">continue</span>;  </span><br><span class="line">		<span class="comment">//如果这个子节点（即下一步走的点）为自己的父节点，则跳过（防止往回递归）</span></span><br><span class="line">		d[x] += <span class="built_in">min</span> ( w[i], <span class="built_in">dfs_d</span> ( j, x ) );  <span class="comment">//上面解释了</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> d[x];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="第二次扫描"><a href="#第二次扫描" class="headerlink" title="第二次扫描"></a>第二次扫描</h6><blockquote>
<p>DP求出所有的 $f[i]$ 。</p>
</blockquote>
<p>$d[i]$ 求完了，接下来的问题是：如何DP求 $f[i]$ ？<br>还是用这张图来理解：<br><img src="https://img-blog.csdnimg.cn/20210528160419813.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0R1bWJ5X2NhdA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>若已经求出 $f[1]$ ，接下来求 $f[4]$ （即把<strong>根</strong>节点从 1 号点上<strong>换</strong>到 4 号点上）。<br>首先，4 号点原来的子树中的节点到 4 号点的流量是不会变的，唯一变化的是以 4 号点为根的子树以外的节点到 4 号点的流量。<br>那么，怎么求这个流量呢？</p>
<p>要知道，除去 4 号点的子树以外的点到 1 号点（即原来的根节点）的总流量是如下部分（红框内）：<br><img src="https://img-blog.csdnimg.cn/20210528161903229.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0R1bWJ5X2NhdA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><del>很显然</del>，只要将 $f[1]$ 减去 $d[4]$ 就好了。。。吗？<br>如果 $w[1][4]$ 小于 $d[4]$ 呢？<br>所以应是 将 $f[1]$ 减去 $d[4]$ 和 $w[1][4]$ 中小的一个。<br>但是这个红框内的水流一定能全部流到 4 号点吗?<br>当然不是，如果这个值大于 $w[1][4]$ 的话它就流不过来了。<br>所以红框内的水流到 4 号点时还得将这个值与 $w[1][4]$ 取 $min$。<br>所以，最终的转移方程就很容易地推出来了。<br>设 $x$ 点为 $j$ 点的父节点，则：<br>$f[j]=d[j]+\min{f[x]-\min{d[j],w[x][j]},w[x][j]}$</p>
<p>然后，读者们就会发现这个式子并不适用于叶子结点，因为叶子结点的 $d$ 值是 $\infty$ ，所以对于叶子结点还要进行特殊处理。<br>再次以上图为例：</p>
<p><img src="https://img-blog.csdnimg.cn/20210528160419813.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0R1bWJ5X2NhdA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>其中将根转移至 2 号点上时，总流量是多少？<br>我们发现 2 号点没有子树，也就是说它的流量全部来自于它的父节点。所以它的 $f$ 值也就很容易地推出来了。<br>设 $x$ 点为 $j$ 点的父节点，则：<br>$f[j]=\min{w[x][j],f[x]-w[x][j]}$<br>OK。这样第二次扫描的代码也能打出来了。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs_f</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> fa)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = head[x]; i; i = nxt[i])    <span class="comment">//邻接表储存</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> j = to[i];     <span class="comment">// j 是 x 的儿子</span></span><br><span class="line">		<span class="keyword">if</span> (j == fa)<span class="keyword">continue</span>;   <span class="comment">//防止往回扫描</span></span><br><span class="line">		<span class="keyword">if</span> (deg[j] == <span class="number">1</span>)   <span class="comment">//如果是叶子结点</span></span><br><span class="line">		&#123;</span><br><span class="line">			f[j] = <span class="built_in">min</span>(w[i], f[x] - w[i]);</span><br><span class="line">		&#125; <span class="keyword">else</span>    <span class="comment">//如果不是叶子结点</span></span><br><span class="line">		&#123;</span><br><span class="line">			f[j] = d[j] + <span class="built_in">min</span>(f[x] - <span class="built_in">min</span>(d[j], w[i]), w[i]);</span><br><span class="line">			<span class="built_in">dfs_f</span>(j, x);    <span class="comment">//继续向下扫描</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h6><p>这样处理以后，恭喜你，得到了一个 90 分代码！！！<br>90 分代码如下：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"><span class="type">int</span> T;</span><br><span class="line"><span class="type">int</span> n, cn;</span><br><span class="line"><span class="type">int</span> to[N], head[N], nxt[N], w[N], f[N], d[N], deg[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	nxt[++cn] = head[a];</span><br><span class="line">	to[cn] = b;</span><br><span class="line">	w[cn] = c;</span><br><span class="line">	head[a] = cn;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs_d</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> fa)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (deg[x] == <span class="number">1</span>) </span><br><span class="line">	&#123;</span><br><span class="line">		d[x] = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">		<span class="keyword">return</span> d[x];</span><br><span class="line">	&#125;</span><br><span class="line">	d[x] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = head[x]; i; i = nxt[i]) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> j = to[i];</span><br><span class="line">		<span class="keyword">if</span> (j == fa)<span class="keyword">continue</span>;</span><br><span class="line">		d[x] += <span class="built_in">min</span>(w[i], <span class="built_in">dfs_d</span>(j, x));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> d[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs_f</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> fa)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = head[x]; i; i = nxt[i]) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> j = to[i];</span><br><span class="line">		<span class="keyword">if</span> (j == fa)<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span> (deg[j] == <span class="number">1</span>) </span><br><span class="line">		&#123;</span><br><span class="line">			f[j] = <span class="built_in">min</span>(w[i], f[x] - w[i]);</span><br><span class="line">		&#125; <span class="keyword">else</span> </span><br><span class="line">		&#123;</span><br><span class="line">			f[j] = d[j] + <span class="built_in">min</span>(f[x] - <span class="built_in">min</span>(d[j], w[i]), w[i]);</span><br><span class="line">			<span class="built_in">dfs_f</span>(j, x);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">	<span class="keyword">while</span> (T--) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="keyword">sizeof</span> head);</span><br><span class="line">		<span class="built_in">memset</span>(deg, <span class="number">0</span>, <span class="keyword">sizeof</span> deg);</span><br><span class="line">		cn = <span class="number">0</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> x, y, z;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;x, &amp;y, &amp;z);</span><br><span class="line">			<span class="built_in">add</span>(x, y, z);</span><br><span class="line">			<span class="built_in">add</span>(y, x, z);</span><br><span class="line">			deg[x]++;</span><br><span class="line">			deg[y]++;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">dfs_d</span>(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">		f[<span class="number">1</span>] = d[<span class="number">1</span>];</span><br><span class="line">		<span class="built_in">dfs_f</span>(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)res = <span class="built_in">max</span>(res, f[i]);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>那么，还有一点错在哪儿呢？<br>仔细观察程序的 $dfs_d$ 片段，也就是第一次扫描的片段，我们发现，判断叶子结点的语句是在子程序开头的：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs_d</span><span class="params">( <span class="type">int</span> x, <span class="type">int</span> fa )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>( deg[x] == <span class="number">1</span> ) <span class="comment">//这里</span></span><br><span class="line">	&#123;</span><br><span class="line">		d[x] = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">		<span class="keyword">return</span> d[x];</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	d[x] = <span class="number">0</span>;  </span><br><span class="line">	<span class="keyword">for</span>( <span class="type">int</span> i = head[x] ; i ; i = nxt[i] ) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> j = to[i]; </span><br><span class="line">		<span class="keyword">if</span>( j == fa ) <span class="keyword">continue</span>;  </span><br><span class="line">		d[x] += <span class="built_in">min</span> ( w[i], <span class="built_in">dfs_d</span> ( j, x ) ); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> d[x];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>而且，我们在主函数中是将 1 号点看做根的。<br>还记得开头说的话吗？</p>
<blockquote>
<p>为了方便，我们这里取 1 号点开始DFS</p>
</blockquote>
<p>那如果 1 号点本身的度就只有一个呢？<br>所以我们应该加一段程序来找到第一个度不为 1 的节点来做初始的根。<br>那如果这棵树长这样怎么办？<br><img src="https://img-blog.csdnimg.cn/20210529132854951.png" alt=""><br>此时，没有一个点的度是大于 1 的，那么上面的想法就不能实现了。<br>其实，对于这种情况，只要加一个判断就好了。<br>设 $root$ 为初始的根，赋初值为 $n$ + 1 。<br>从 1 到 n 遍历一遍，找到度大于 1 的点，将点的编号赋值给 $root$ 。如果遍历完了 $root$ 的值还是大于 $n$ 即没有找到度大于 1 的点，这时只有上图这一种情况，所以直接返回边权即为答案。<br>程序如下：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> root = n + <span class="number">1</span>; </span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (deg[i] != <span class="number">1</span>) &#123;</span><br><span class="line">		root = i;</span><br><span class="line">		<span class="keyword">break</span>;   <span class="comment">//找到了根就跳出</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (root &gt; n)   <span class="comment">//如果没找到根</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, w[<span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">dfs_d</span>(root, <span class="number">-1</span>);   <span class="comment">//从根节点处开始扫描</span></span><br><span class="line">f[root] = d[root];</span><br><span class="line"><span class="built_in">dfs_f</span>(root, <span class="number">-1</span>);</span><br></pre></td></tr></table></figure><br>如此一来，只要将主程序改一下就能得到满分程序啦！<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">	<span class="keyword">while</span> (T--) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="keyword">sizeof</span> head);</span><br><span class="line">		<span class="built_in">memset</span>(deg, <span class="number">0</span>, <span class="keyword">sizeof</span> deg);</span><br><span class="line">		cn = <span class="number">0</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> x, y, z;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;x, &amp;y, &amp;z);</span><br><span class="line">			<span class="built_in">add</span>(x, y, z);</span><br><span class="line">			<span class="built_in">add</span>(y, x, z);</span><br><span class="line">			deg[x]++;</span><br><span class="line">			deg[y]++;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="type">int</span> root = n + <span class="number">1</span>;   <span class="comment">//开始找根</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (deg[i] != <span class="number">1</span>) &#123;</span><br><span class="line">				root = i;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (root &gt; n) </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, w[<span class="number">1</span>]);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">dfs_d</span>(root, <span class="number">-1</span>);</span><br><span class="line">		f[root] = d[root];</span><br><span class="line">		<span class="built_in">dfs_f</span>(root, <span class="number">-1</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)res = <span class="built_in">max</span>(res, f[i]);    <span class="comment">//找最大值</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>接下来再讲一题。</p>
<h4 id="例题2：HDU-2196-：-Computer"><a href="#例题2：HDU-2196-：-Computer" class="headerlink" title="例题2：HDU-2196 ： Computer"></a>例题2：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=2196">HDU-2196 ： Computer</a></h4><p><del><em>其实我都不知道这道题算不算换根法，毕竟我是只蒟蒻</em></del></p>
<h5 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h5><p>给定一棵<strong>带权</strong>树，求每个节点能到达的最远距离。</p>
<h5 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h5><h6 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h6><p>输入文件包含多组测试数据。<br>第一行输入 $n$ ，表示有几个节点。<br>接下来 $n$ - 1 行，从 2 号点开始输入。<br>每行两个整数，第一个表示该节点与哪个节点相连；第二个表示连接这两个节点的边的权值是多少。</p>
<h6 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h6><p>一行一个整数，第 $i$ 行表示第 $i$ 个点能到达的最远距离。</p>
<h5 id="题解-6"><a href="#题解-6" class="headerlink" title="题解"></a>题解</h5><p>这题和上题很像，还是需要二次扫描和还根法。</p>
<p>第一次扫描：扫描出每个节点在以它为根的子树能到达的<strong>最大</strong>距离和<strong>次大</strong>距离，并标记出最大距离经过了该节点的哪个儿子节点。</p>
<p>第二次扫描：求出每个节点通过它的父节点能到达的最大距离。</p>
<p>接下来详细讲讲两次扫描如何进行。</p>
<h6 id="第一次扫描-1"><a href="#第一次扫描-1" class="headerlink" title="第一次扫描"></a>第一次扫描</h6><p>第一次扫描的过程和求树的直径很像。</p>
<hr>
<p>求树的直径：<br>设 $f[i][0]$ 为以 $i$ 节点为根节点的子树中， $i$ 到叶子节点的最大距离；<br>设 $f[i][1]$ 为以 $i$ 节点为根节点的子树中， $i$ 到叶子节点的次大（第二大）距离。<br>令 $j$ 为 $x$ 的儿子。<br>设 $w[j][x]$ 为 $j$ 到 $x$ 的路径长度。<br>下面用代码解释：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>( f[x][<span class="number">0</span>] &lt; f[j][<span class="number">0</span>] + w[j][x] ) </span><br><span class="line">&#123;<span class="comment">//如果x节点到叶节点的最大距离 小于 j节点到叶节点的最大距离 加上 x节点到j节点的距离</span></span><br><span class="line">	f[x][<span class="number">1</span>]=f[i][<span class="number">0</span>];<span class="comment">//将x节点到叶节点的最大值变成次大值</span></span><br><span class="line">	f[x][<span class="number">0</span>]=f[j][<span class="number">0</span>]+w[j][x];<span class="comment">//更新最大值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>( f[x][<span class="number">1</span>] &lt; f[j][<span class="number">0</span>] + w[j][x] )</span><br><span class="line">&#123;<span class="comment">//如果x的最大值大于j的，但x的次大值小于j</span></span><br><span class="line">	f[x][<span class="number">1</span>]=f[j][<span class="number">0</span>]+w[j][x];<span class="comment">//更新次大值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<p>怎么样是不是很像？<br>所以只需要在原代码上加一个DFS和记录最大路径经过哪个儿子节点就好了。<br><del><em>其实是我懒</em></del><br>于是这段代码加上DFS后就是这个亚子的：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> fa)</span>   <span class="comment">//返回的是 x 节点在其子树中的最大距离</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (f[x][<span class="number">0</span>] != <span class="number">0x3f3f3f3f</span>)<span class="keyword">return</span> f[x][<span class="number">0</span>];   <span class="comment">//如果x点走过了，则直接返回最大距离</span></span><br><span class="line">	f[x][<span class="number">0</span>] = f[x][<span class="number">1</span>] = f[x][<span class="number">2</span>] = v[x] = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = head[x]; i; i = nxt[i])    <span class="comment">//邻接表储存</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> j = to[i];   <span class="comment">// j 为 x 的子节点</span></span><br><span class="line">		<span class="keyword">if</span> (j == fa)<span class="keyword">continue</span>;   <span class="comment">//防止往回扫描</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (f[x][<span class="number">0</span>] &lt; <span class="built_in">dfs1</span>(j, x) + w[i]) </span><br><span class="line">		&#123; <span class="comment">//如果x节点在其子树中的最大距离 小于 j节点在其子树中的最大距离 加上 x 到 j 的距离</span></span><br><span class="line">			v[x] = j;    <span class="comment">//记录最大距离经过哪个儿子节点</span></span><br><span class="line">			f[x][<span class="number">1</span>] = f[x][<span class="number">0</span>];    <span class="comment">//更新次大值</span></span><br><span class="line">			f[x][<span class="number">0</span>] = f[j][<span class="number">0</span>] + w[i];    <span class="comment">//更新最大值</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (f[x][<span class="number">1</span>] &lt; f[j][<span class="number">0</span>] + w[i]) </span><br><span class="line">		&#123; <span class="comment">//如果x的最大值大于j的，但x的次大值小于j</span></span><br><span class="line">			f[x][<span class="number">1</span>] = f[j][<span class="number">0</span>] + w[i];   <span class="comment">//更新次大值</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> f[x][<span class="number">0</span>];   <span class="comment">//返回最大值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>OK，接下来是第二次扫描。</p>
<h6 id="第二次扫描-1"><a href="#第二次扫描-1" class="headerlink" title="第二次扫描"></a>第二次扫描</h6><p>设 $f[i][2]$ 为 $i$ 节点通过其父节点能到达的最大距离。</p>
<p>此时有两种情况：父节点的最大距离经过此节点，则此点的 $f[i][2]$ 为父节点的次大距离和父节点通过它的父节点能到的最大距离的更大的一个。<br>此时方程如下：<br>令 $j$ 为 $x$ 的儿子。<br>$f[i][2]=\max{f[x][2],f[x][1]}$<br>若父节点的最大距离未经过此点，则此点的 $f[i][2]$ 为父节点的最大距离和父节点通过它的父节点能到的最大距离的更大的一个。<br>同样，此时方程如下：<br>$f[i][2]=\max{f[x][2],f[x][0]}$<br>所以第二次扫描的代码也<del>很容易</del>地打出来了。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> fa)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = head[x]; i; i = nxt[i])   <span class="comment">//邻接表储存</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> j = to[i];   <span class="comment">// j 为 x 的子节点</span></span><br><span class="line">		<span class="keyword">if</span> (j == fa)<span class="keyword">continue</span>;   <span class="comment">//防止往回扫描</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (j == v[x]) </span><br><span class="line">		&#123; <span class="comment">//如果父节点的最大距离路径经过了此节点</span></span><br><span class="line">			f[j][<span class="number">2</span>] = <span class="built_in">max</span>(f[x][<span class="number">2</span>], f[x][<span class="number">1</span>]) + w[i];</span><br><span class="line">		&#125; <span class="keyword">else</span> </span><br><span class="line">		&#123; <span class="comment">//否则</span></span><br><span class="line">			f[j][<span class="number">2</span>] = <span class="built_in">max</span>(f[x][<span class="number">2</span>], f[x][<span class="number">0</span>]) + w[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">dfs2</span>(j, x);   <span class="comment">//继续向下扫描</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h6><p>通篇代码如下：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n, x, y, cn;</span><br><span class="line"><span class="type">int</span> head[N], to[N], nxt[N], w[N], f[N][<span class="number">3</span>], v[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	nxt[++cn] = head[a];</span><br><span class="line">	to[cn] = b;</span><br><span class="line">	w[cn] = c;</span><br><span class="line">	head[a] = cn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> fa)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (f[x][<span class="number">0</span>] != <span class="number">0x3f3f3f3f</span>)<span class="keyword">return</span> f[x][<span class="number">0</span>];</span><br><span class="line">	f[x][<span class="number">0</span>] = f[x][<span class="number">1</span>] = f[x][<span class="number">2</span>] = v[x] = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = head[x]; i; i = nxt[i]) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> j = to[i];</span><br><span class="line">		<span class="keyword">if</span> (j == fa)<span class="keyword">continue</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (f[x][<span class="number">0</span>] &lt; <span class="built_in">dfs1</span>(j, x) + w[i]) </span><br><span class="line">		&#123;</span><br><span class="line">			v[x] = j;</span><br><span class="line">			f[x][<span class="number">1</span>] = f[x][<span class="number">0</span>];</span><br><span class="line">			f[x][<span class="number">0</span>] = f[j][<span class="number">0</span>] + w[i];</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (f[x][<span class="number">1</span>] &lt; f[j][<span class="number">0</span>] + w[i]) </span><br><span class="line">		&#123;</span><br><span class="line">			f[x][<span class="number">1</span>] = f[j][<span class="number">0</span>] + w[i];</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> f[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> fa)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = head[x]; i; i = nxt[i]) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> j = to[i];</span><br><span class="line">		<span class="keyword">if</span> (j == fa)<span class="keyword">continue</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (j == v[x]) </span><br><span class="line">		&#123;</span><br><span class="line">			f[j][<span class="number">2</span>] = <span class="built_in">max</span>(f[x][<span class="number">2</span>], f[x][<span class="number">1</span>]) + w[i];</span><br><span class="line">		&#125; <span class="keyword">else</span> </span><br><span class="line">		&#123;</span><br><span class="line">			f[j][<span class="number">2</span>] = <span class="built_in">max</span>(f[x][<span class="number">2</span>], f[x][<span class="number">0</span>]) + w[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">dfs2</span>(j, x);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n) == <span class="number">1</span> &amp;&amp; n) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">		<span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="keyword">sizeof</span> head);</span><br><span class="line">		<span class="built_in">memset</span>(v, <span class="number">0</span>, <span class="keyword">sizeof</span> v);</span><br><span class="line">		cn = <span class="number">0</span>;   <span class="comment">//初始化</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">			<span class="built_in">add</span>(i, x, y);   <span class="comment">//邻接表储存</span></span><br><span class="line">			<span class="built_in">add</span>(x, i, y);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">dfs1</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">		<span class="built_in">dfs2</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">		<span class="comment">//两次扫描</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">max</span>(f[i][<span class="number">0</span>], f[i][<span class="number">2</span>]));   <span class="comment">//max&#123;f[i][0], f[i][2]&#125; 即为最大距离</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>OK，我们的换根法就讲完啦！</p>
<p>接下来的又是一些例题。</p>
<h2 id="习题-习题-更多的习题"><a href="#习题-习题-更多的习题" class="headerlink" title="习题 习题 更多的习题"></a>习题 习题 更多的习题</h2><h3 id="POJ-1655：Balancing-Act"><a href="#POJ-1655：Balancing-Act" class="headerlink" title="POJ-1655：Balancing Act"></a><a href="http://poj.org/problem?id=1655">POJ-1655：Balancing Act</a></h3><p>因为是英文题面，我这里题目描述就写详细一点好了。</p>
<h4 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一棵无权树。将一个节点的 Balance 定义为从该树中删除该节点所创建的森林中最大的树的大小。<br>求出最小的balance值和其所对应的节点编号。</p>
<h5 id="输入-1"><a href="#输入-1" class="headerlink" title="输入"></a>输入</h5><p>输入文件的第一行包含一个整数 t（1 &lt;= t &lt;= 20），即测试样例的数量。每个测试样例的第一行包含一个整数 N（1 &lt;= N &lt;= 20,000），即节点的数量。接下来的 N-1行，每行两个节点编号，表示一条边的两个端点。没有一条边会被列出两次。</p>
<h5 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h5><p>对于每个测试样例，输出一行包含两个整数，即具有最小Balance的节点编号和对应的Balance值。</p>
<h4 id="题解-7"><a href="#题解-7" class="headerlink" title="题解"></a>题解</h4><p><del>不是我说，但是这是真的水</del><br>又一题换根法的应用。<br>不过比起前面几题，换根味道不是很浓，<del>而且这题也很水</del><br>只需要一次DFS。<br>设 $f[i]$ 为 $i$ 号点的 Balance 值；<br>设 $son[i]$ 为以 $i$ 号点为根的子树的节点数；<br>设 $j$ 为 $x$ 的儿子节点。<br>那么根据定义，可得到如下公式:<br> $son[x]=\sum_{j}^{j \in x} son[j]+1$<br> 即 $son[x]$ 等于以它的每个子节点为根的子树的节点数之和加一（加一是因为包括它本身）。<br> 我们只需要在初始化 $son$ 数组时将每个值都赋值为 1 就可以在DFS中免掉加一的操作。</p>
<p>接下来是 $f$ 数组。<br>在算 $f[x]$ 时首先考虑 $x$ 的子树中最大的一个，然后考虑除了以 $x$ 点为根的子树外的树的最大值；<br>将两个最大值比较，取大者即为 $f[x]$ 。<br>所以，$f[x]$ 的方程也列出来了：<br>$f[x]=\max {f[x],son[j]}(j \in x)$<br>$f[x]=\max {f[x],n-son[x]}$<br>SO，这道题就这样了。</p>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"><span class="type">int</span> n, x, y, cn;</span><br><span class="line"><span class="type">int</span> head[N], nxt[N], to[N], f[N], son[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	nxt[++cn] = head[a];</span><br><span class="line">	to[cn] = b;</span><br><span class="line">	head[a] = cn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> fa)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = head[x]; i; i = nxt[i])   <span class="comment">//邻接表储存</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> j = to[i];   <span class="comment">// j 为 x 的儿子</span></span><br><span class="line">		<span class="keyword">if</span> (j == fa)<span class="keyword">continue</span>;   <span class="comment">//防止往回扫描</span></span><br><span class="line">		son[x] += <span class="built_in">dfs</span>(j, x);   <span class="comment">//递归求出 son[x]</span></span><br><span class="line">		f[x] = <span class="built_in">max</span>(f[x], son[j]);   <span class="comment">//考虑 x 的子树中最大的一个</span></span><br><span class="line">	&#125;</span><br><span class="line">	f[x] = <span class="built_in">max</span>(n - son[x], f[x]);   <span class="comment">//考虑除了以 x 点为根的子树外的树的最大值，并比较两个最大值</span></span><br><span class="line">	<span class="keyword">return</span> son[x];   <span class="comment">//返回以 x 为根的子树大小</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> T;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> (T--) </span><br><span class="line">	&#123;  <span class="comment">//多组测试数据</span></span><br><span class="line">		<span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="keyword">sizeof</span> head);</span><br><span class="line">		<span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">		cn = <span class="number">0</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">			<span class="built_in">add</span>(x, y);</span><br><span class="line">			<span class="built_in">add</span>(y, x);</span><br><span class="line">			son[i] = <span class="number">1</span>;     <span class="comment">//在输入时初始化 son 数组，减少循环次数。</span></span><br><span class="line">		&#125;</span><br><span class="line">		son[n] = <span class="number">1</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (n == <span class="number">1</span>) </span><br><span class="line">		&#123;  <span class="comment">//如果 n 为以则直接输出</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;1 0\n&quot;</span>);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="type">int</span> minn = <span class="number">0x3f3f3f3f</span>, k;   <span class="comment">//minn存最小值，k 存节点编号</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (f[i] &lt; minn) </span><br><span class="line">			&#123;</span><br><span class="line">				minn = f[i];</span><br><span class="line">				k = i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, k, minn);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><del>水题讲完啦</del><br>福利（做一题赚一题）：一道和这题几乎一模一样的题：<a href="http://poj.org/problem?id=3107">POJ-3107：Godfather</a>（就好像 选课 和 The More,The Better 的区别）。</p>
<h3 id="ZOJ-3201：Tree-of-Tree"><a href="#ZOJ-3201：Tree-of-Tree" class="headerlink" title="ZOJ-3201：Tree of Tree"></a><a href="https://zoj.pintia.cn/problem-sets/91827364500/problems/91827367825">ZOJ-3201：Tree of Tree</a></h3><p><del>一道水题。</del></p>
<h4 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h4><p>给你一棵带权树，找出节点数在 K 内的最大子树。</p>
<h5 id="输入-2"><a href="#输入-2" class="headerlink" title="输入"></a>输入</h5><p>多组测试样例。<br>每组样例第一行两个整数，表示节点总数 N （1 &lt;= N &lt;= 100）和 K（1 &lt;= K &lt;= N） 。<br>第二行 N 个整数，表示每个节点的权值（节点从 0 开始编号）。<br>后面 N - 1 行，每行两个整数，表示一条边的两个端点。</p>
<h5 id="输出-2"><a href="#输出-2" class="headerlink" title="输出"></a>输出</h5><p>每个样例一行输出，表示最大权值的子树的权值和。</p>
<h4 id="题解-8"><a href="#题解-8" class="headerlink" title="题解"></a>题解</h4><p>又一道树上背包，而且比前面的简单多了。<br>打腻了邻接表，这道题换个口味。<br>于是乎，可以用 VECTOR 来做。<br>即，用 VECTOR 存储每个节点的儿子，用时直接取出就好了。<br>下面直接在代码中解释：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> f[N][<span class="number">110</span>];</span><br><span class="line">vector &lt; <span class="type">int</span> &gt; son[N];   <span class="comment">//STL 容器：向量 （STL太香啦！！！）</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> fa)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; son[x].<span class="built_in">size</span>(); i++) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> j = son[x][i];</span><br><span class="line">		<span class="keyword">if</span> (j == fa)<span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">dfs</span>(j, x);</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> p = m; p &gt; <span class="number">0</span>; p--) </span><br><span class="line">		&#123;   <span class="comment">//01背包，倒着防止重复计算出现错误</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; p; k++) </span><br><span class="line">			&#123;   <span class="comment">//这里 k 必须从小到大遍历，否则会发生 神 奇 的 错 误（我在这卡了那么 一 小 会 儿 吧）</span></span><br><span class="line">				f[x][p] = <span class="built_in">max</span>(f[x][p], f[x][p - k] + f[j][k]);</span><br><span class="line">				<span class="comment">//普通得不能再普通地更新最大值</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m) != EOF) </span><br><span class="line">	&#123; <span class="comment">//多组测试样例</span></span><br><span class="line">		<span class="built_in">memset</span>(f, <span class="number">-1</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) </span><br><span class="line">		&#123;</span><br><span class="line">			son[i].<span class="built_in">clear</span>();</span><br><span class="line">		&#125;  <span class="comment">//初始化</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;f[i][<span class="number">1</span>]);</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> x, y;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">			son[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">			son[y].<span class="built_in">push_back</span>(x);   <span class="comment">//无向边储存</span></span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">-1</span>);   <span class="comment">//从 0 号点开始递归</span></span><br><span class="line">		</span><br><span class="line">		<span class="type">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) </span><br><span class="line">		&#123;</span><br><span class="line">			ans = <span class="built_in">max</span>(ans, f[i][m]);</span><br><span class="line">		&#125;  <span class="comment">//找最大值</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>I AM SO WATERY！！！</p>
<h3 id="POJ-2378"><a href="#POJ-2378" class="headerlink" title="POJ-2378"></a><a href="http://poj.org/problem?id=2378">POJ-2378</a></h3><p>跟 POJ-1655：Balancing Act 一样，只要在最后输出时判断一下最大值有没有超过 n/2 就好了，如果没超过就直接输出。<br>代码这里就不打了，<del>留给读者做习题好了</del>。</p>
<h3 id="洛谷P1272：重建道路"><a href="#洛谷P1272：重建道路" class="headerlink" title="洛谷P1272：重建道路"></a><a href="https://www.luogu.com.cn/problem/P1272">洛谷P1272：重建道路</a></h3><p><del>终于有一道不是那么水的题啦！</del></p>
<h4 id="题目描述-9"><a href="#题目描述-9" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一棵无权树，求出至少要删多少条边才能得到一棵节点数为 m 的子树。</p>
<h4 id="题解-9"><a href="#题解-9" class="headerlink" title="题解"></a>题解</h4><p>也是一道树上背包的题目。<br>背包容量是节点数 m ，每个物品的重量为 1 。<br>其实这题还是和前几道树上背包很像，只有几处不同。<br>这道题也只需要一次DFS（有没有发现树形DP通常都用DFS来迭代）。<br>设 $f[i][j]$ 为以 $i$ 为根的子树取 $j$ 个节点至少需要删去几条边（包括子树与父节点间的边）。<br>那么，由定义得， $f[i][1]$ 就等于 $i$ 点的度数。<br>如图：<br><img src="https://img-blog.csdnimg.cn/20210601180244945.PNG" alt=""><br>此时的 $f[2][1]$ 就等于 3 ，即 1-2 边， 2-4 边， 2-5 边。<br>那么，将 $m$ 条边从 1 号点分下去，一直分到叶子节点或者分完了为止。<br>所以，转移方程也比较容易地写出来了：<br>$j$ 为 $x$ 的儿子。<br>$f[x][p]=\min{f[x][p],f[x][p-k]+f[j][k]-2},(1&lt;=p&lt;=m,1&lt;=k&lt;=p)$<br>这里面的 <strong>-2</strong> 是什么意思呢？<br>我们把上面的转移方程换成下面的样子看看：<br>$f[x][p]=\min{f[x][p],(f[x][p-k]-1)+(f[j][k]-1)},(1&lt;=p&lt;=m,1&lt;=k&lt;=p)$<br>那这里把两个分别都 <strong>-1</strong> 是什么意思呢？<br>如图所示：<br><img src="https://img-blog.csdnimg.cn/20210601182401411.PNG" alt="在这里插入图片描述"><br>我们之前定义 $f$ 数组储存的是最少<strong>去掉</strong>的边，如在此图中， $f[2]$和$f[3]$ 分别将两个画了小红点的边去掉了。但是我们在计算时需要将这些边算上（要不然怎么连接子树）。所以要分别 <strong>-1</strong>。<br>OK，思想讲完了，下面直接上代码吧。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">400</span>;</span><br><span class="line"><span class="type">int</span> n, m, cn, x, y;</span><br><span class="line"><span class="type">int</span> nxt[N], f[N][N], to[N], head[N], a[N], num[N], ans = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="comment">//num 数组储存每个节点的度数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>   <span class="comment">//邻接表储存</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	to[++cn] = y;</span><br><span class="line">	nxt[cn] = head[x];</span><br><span class="line">	head[x] = cn;</span><br><span class="line">	num[x]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> fa)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	f[x][<span class="number">1</span>] = num[x];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = head[x]; i; i = nxt[i])   <span class="comment">//邻接表储存</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> j = to[i];   <span class="comment">// j 为 x 的儿子</span></span><br><span class="line">		<span class="keyword">if</span> (j == fa)<span class="keyword">continue</span>;   <span class="comment">//防止往回 DFS</span></span><br><span class="line">		<span class="built_in">dfs</span>(to[i], x);</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> p = m; p &gt;= <span class="number">1</span>; p--) </span><br><span class="line">		&#123;   <span class="comment">//背包</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= p; k++) </span><br><span class="line">			&#123;   <span class="comment">//分配边数</span></span><br><span class="line">				f[x][p] = <span class="built_in">min</span>(f[x][p], f[x][p - k] + f[j][k] - <span class="number">2</span>);  <span class="comment">//转移</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans = <span class="built_in">min</span>(ans, f[x][m]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">	<span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(f));</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">		<span class="built_in">add</span>(x, y);</span><br><span class="line">		<span class="built_in">add</span>(y, x);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="POJ-2057：The-Lost-House"><a href="#POJ-2057：The-Lost-House" class="headerlink" title="POJ-2057：The Lost House"></a><a href="http://poj.org/problem?id=2057">POJ-2057：The Lost House</a></h3><h4 id="题目描述-10"><a href="#题目描述-10" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一棵树，节点数 n &lt;= 1000（每个节点的分支 &lt;= 8），一只蜗牛在根（1 号节点）处，他要到叶子节点上去找房子，而有几个节点上（根节点上没有）有虫子告诉你房子在不在这棵子树上，求出蜗牛最快找到房子的路径的期望值。</p>
<h4 id="输入-3"><a href="#输入-3" class="headerlink" title="输入"></a>输入</h4><p>多组样例。<br>每组样例第一行一个整数 n 表示节点数，接下来 n 行一个整数 $a$ 和一个字母 $b$。<br>第 $i$ 行的整数 $x$ 表示第 $i$ 个节点的父节点是 $x$ ，字母 $b$ 为 Y 时表示 $i$ 号节点有虫子提供信息，为 N 时则是没有。<br>（$i$ = 1 的那行输入其实可以忽略）<br>n = 0 表示输入结束。</p>
<h4 id="输出-3"><a href="#输出-3" class="headerlink" title="输出"></a>输出</h4><p>对于每个样例，输出一行包含一个四位小数的浮点数，表示最小的期望值。</p>
<h4 id="题解-10"><a href="#题解-10" class="headerlink" title="题解"></a>题解</h4><p>首先，啥是期望值？</p>
<p>百度百科定义如下：</p>
<blockquote>
<p>数学期望（或均值，亦简称期望）是试验中每次可能结果的概率乘以其结果的总和，是最基本的数学特征之一。它反映随机变量平均取值的大小。</p>
</blockquote>
<p>在这题中可以把它理解成加权平均值。（两者不一样，只是这题较特殊）<br><del><em>（其实我到现在都不是很明白期望值是个什么东西）</em></del></p>
<p>说不明白，举个例子吧。<br><img src="https://img-blog.csdnimg.cn/20210603175702875.gif" alt="在这里插入图片描述"><br>snail - 蜗牛，worm - 虫子。<br>如图所示，蜗牛在 1 号点，房子在 2、4、5 中的某一点。一只虫子在 3 号点，它可以告诉蜗牛房子是否在第4和第5点中的某一点（房子是否在此子树上）。因此，蜗牛可以选择两种策略。</p>
<p>他可以先去 2 号点。如果他在那里找不到房子，他应该回到 1 号点，然后通过3号点到达 4（或5）号点。如果还是不行，他就得返回3点，然后去5点（或4点），在那里他无疑会找到房子。在这个选择中，蜗牛所走的距离为 1、4、6，分别对应于房子在2、4（或5）、5（或4）点的情况。所以期望值是（1+4+6）/3=11/3。</p>
<p>显然，这种策略并没有充分利用虫子给的的信息。如果蜗牛先去3号点，从蠕虫那里得到有用的信息，然后选择回到 1 号点，然后去 2 号点，或者去 4 号或 5 号点碰碰运气，那么他所走的距离将是 2、3、4，对应于房子的不同位置。在这样的策略中，数学期望值将是（2+3+4）/3=3，而这正是蜗牛应该在树上搜寻的路线。</p>
<p>接下来，<strong>直入主题</strong>。<br>设 $f[i][0]$ 为在以 $i$ 为根的子树中<strong>没有找到</strong>房子的步数的总和；<br>设$f[i][1]$ 为在以 $i$ 为根的子树中<strong>找到</strong>房子的步数的总和；<br>设 $lea[i]$ 为以 $i$ 为根的子树中的叶子节点数；<br>设 $bug[i]$ 储存第 $i$ 个节点处是否有虫子。</p>
<p>设 P~i~ 为房子在 $i$ 子树上的概率，两个节点分别为 $x$ 和 $y$ 。<br>题目要求我们找到最小的期望值，那么我们就应该比较以下两种情况哪一种的期望值更小：<br>先 $x$ 后 $y$ ：<br>$f[x][1] <em> P~x~+(f[x][0]+2+f[y][1]) </em> P~y~$<br>先 $y$ 后 $x$：<br>$f[y][1] <em> P~y~+(f[y][0]+2+f[x][1]) </em> P~x~$<br>这里结合定义稍微想一下应该就能出来了，我就不多说了 <del><em>（就是懒呗）</em></del> 。<br>通过观察得，比较上面两个式子的大小其实就是比较下面两个式子的大小：<br>$(f[x][0]+2) <em> P~y~ 和 (f[y][0]+2) </em> P~x~$<br>这里 <strong>+2</strong> 是连接该子树的边的来回两次。<br>按照这个式子将子树排序，按照顺序遍历后得到的结果就是最优的了。</p>
<p>然后来推转移方程。<br>（$j$ 为 $x$ 的儿子）<br>首先，根据定义能得到：<br>$f[x][0]=\sum{f[j][0]+2}(前提是此时bug[x]=0，即此处没有虫子)$<br>为什么要 +2 上面已经解释了。<br> 当此处有虫子时也就是 $bug[x]$ = 1 时 $f[x][0]$ = 0<br> 这是因为当这里有虫子时，虫子会告诉你房子在不在这棵子树上。<br>当目前节点为叶子节点时，$f[x][0]=f[x][1]=0$<br>在某个分叉处，我们枚举房子在此子树上的各个叶子节点时 所需的距离。<br>方程如下：<br>$f[x][1] += f[x][0] <em> lea[q[x][i]] + f[q[x][i]][1] + lea[q[x][i]]$<br>$q$ 储存 $x$ 的儿子。<br>也可以写成：<br>$f[x][1] += (f[x][0]+1) </em> lea[q[x][i]] + f[q[x][i]][1]$<br>因为 $f[x][0]$ 初始化为 0 ，且与 $f[x][1]$ 同步更新，所以此时只需将它 <strong>+1</strong> 后乘上 该子树的叶子节点数 再加上找到房子的路径长度就行了。<br>为什么要乘上叶子结点数？ 因为在某一个叶子结点找到房子时 其他的路径可以是任意顺序的。如有三个节点 1 , 2，3 。房子在 1 号节点上，那么找到房子的路径可以是 1 或 21 或 31 或 231 或 321 。</p>
<p>这种大家还是自己画个图推一下比较好 <del><em>（我又懒又菜，只能水一下了）</em></del></p>
<p><del>然后就水完了</del><br>此题部分参考<a href="https://www.cnblogs.com/fht-litost/p/9471692.html">此博客</a></p>
<p>下面是代码：</p>
<h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> n, a;</span><br><span class="line"><span class="type">char</span> b[<span class="number">5</span>];</span><br><span class="line">vector &lt;<span class="type">int</span>&gt; q[N]; <span class="comment">// q 拿来存儿子节点</span></span><br><span class="line"><span class="type">int</span> f[N][<span class="number">2</span>], bug[N], lea[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span></span><br><span class="line"><span class="function"></span>&#123;  <span class="comment">//比较函数，用这个来排序</span></span><br><span class="line">	<span class="keyword">return</span> (f[x][<span class="number">0</span>] + <span class="number">2</span>) * lea[y] &lt; (f[y][<span class="number">0</span>] + <span class="number">2</span>) * lea[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> len = q[x].<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">if</span> (len == <span class="number">0</span>) </span><br><span class="line">	&#123;   <span class="comment">//如果是叶子节点</span></span><br><span class="line">		f[x][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">		f[x][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">		lea[x] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) <span class="built_in">dfs</span>(q[x][i]);   <span class="comment">//一直向下搜索，直到搜到叶子结点为止</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) lea[x] += lea[q[x][i]];  <span class="comment">//一棵子树中的叶子结点数</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">sort</span>(q[x].<span class="built_in">begin</span>(), q[x].<span class="built_in">end</span>(), cmp);   <span class="comment">//将 x 的儿子节点按照上述规则排序</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) </span><br><span class="line">	&#123;     <span class="comment">//DP</span></span><br><span class="line">		f[x][<span class="number">1</span>] += f[x][<span class="number">0</span>] * lea[q[x][i]] + f[q[x][i]][<span class="number">1</span>] + lea[q[x][i]];</span><br><span class="line">		f[x][<span class="number">0</span>] += f[q[x][i]][<span class="number">0</span>] + <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (bug[x]) </span><br><span class="line">	&#123;   <span class="comment">//如果此处有虫子则 f[x][0] 清零</span></span><br><span class="line">		f[x][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n) &amp;&amp; n) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">		<span class="built_in">memset</span>(bug, <span class="number">0</span>, <span class="keyword">sizeof</span> bug);</span><br><span class="line">		<span class="built_in">memset</span>(lea, <span class="number">0</span>, <span class="keyword">sizeof</span> lea);</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)q[i].<span class="built_in">clear</span>();</span><br><span class="line">		<span class="comment">//初始化</span></span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%s&quot;</span>, &amp;a, b);  <span class="comment">// 1 号节点不用管</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) </span><br><span class="line">		&#123;  <span class="comment">//输入</span></span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d%s&quot;</span>, &amp;a, b);</span><br><span class="line">			<span class="keyword">if</span> (b[<span class="number">0</span>] == <span class="string">&#x27;Y&#x27;</span>)bug[i] = <span class="number">1</span>;   <span class="comment">//如果有虫子</span></span><br><span class="line">			q[a].<span class="built_in">push_back</span>(i);   <span class="comment">//向 q[x] 中推入儿子的下标</span></span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%.4lf\n&quot;</span>, <span class="number">1.0</span> * f[<span class="number">1</span>][<span class="number">1</span>] / lea[<span class="number">1</span>]);   <span class="comment">// 1.0* 是为了将 int 转化成 double</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这题挺不错的，但我讲的不怎么好，敬请谅解，毕竟我是只蒟蒻。</p>
<p>下一题。</p>
<h3 id="POJ-1848：Tree"><a href="#POJ-1848：Tree" class="headerlink" title="POJ-1848：Tree"></a><a href="http://poj.org/problem?id=1848">POJ-1848：Tree</a></h3><h4 id="题目描述-11"><a href="#题目描述-11" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一棵树，求最少连多少条边，使得每个点在且仅在某一个环内。（一个环至少三个点）</p>
<h4 id="题解-11"><a href="#题解-11" class="headerlink" title="题解"></a>题解</h4><p>这道题挺好的 <em><del>（整了我好久）</del></em><br><a href="http://hi.baidu.com/19930705cxjff/blog/item/1df66e4a4ff3022e08f7ef5d.html">参考博客</a><br>首先，找到DP的状态。</p>
<p>设 $f[x][0]$ 为以 $x$ 为根的子树中，让每一个节点各自在一个环中需要加的边数。</p>
<p>设 $f[x][1]$ 为以 $x$ 为根的子树中，让除了根节点以外的节点各自在一个环中需要加的边数。</p>
<p>设 $f[x][2]$ 为以 $x$ 为根的子树中，让除了根节点以及与根相连的一条链（加上根节点至少两个节点）以外的节点各自在一个环中需要加的边数。</p>
<p>状态有了，怎么转移呢？<br>四种转移状态。<br>如图：<br>（借用其他大佬的图片一用）<br><img src="https://img-blog.csdnimg.cn/20210618113846253.png" alt="在这里插入图片描述"></p>
<blockquote>
<p>根R的所有子树自己解决（取状态0），转移到R的状态1。即R所有的儿子都变成每个顶点恰好在一个环中的图，R自己不变。</p>
<p>即 $f[x][1]$ 可以分为它的子节点的 $f[son][0]$ 之和。<br><img src="https://img-blog.csdnimg.cn/20210618113906349.png" alt="在这里插入图片描述"><br>根R的k-1个棵树自己解决，剩下一棵子树取状态1和状态2的最小值，转移到R的状态2。剩下的那棵子树和根R就构成了长度至少为2的一条链。</p>
</blockquote>
<p>让其中一个子节点（或与子节点相连的链）与根节点构成一条链。<br><img src="https://img-blog.csdnimg.cn/20210618113912693.png" alt="在这里插入图片描述"></p>
<blockquote>
<p>根R的k-2棵子树自己解决，剩下两棵子树取状态1和状态2的最小值，在这两棵子树之间连一条边，转移到R的状态0。</p>
</blockquote>
<p>让其中两个子节点（或者与子节点相连的链）与根节点组成一个环（因为一个环至少有三个节点）。<br><img src="https://img-blog.csdnimg.cn/20210618113917172.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0R1bWJ5X2NhdA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p>根R的k-1棵子树自己解决，剩下一棵子树取状态2（子树里还剩下长度至少为2的一条链），在这棵子树和根之间连一条边，构成一个环，转移到R的状态0。</p>
</blockquote>
<p>让其中一个子节点（或与子节点相连的一条链）加上根节点再加一条边组成一个环。</p>
<p>那么转移方程怎么写呢？<br>我们设 $sum$ 是 $x$ 节点的 $f[j][0]$ 的总和（ $j$ 是 $x$ 的儿子）<br>设 $min1$ 为 最小的一个 $f[j][1]$ 或 $f[j][2]$ 减去 $f[j][0]$ 的值。<br>设 $min2$ 为 次小的一个 $f[j][1]$ 或 $f[j][2]$ 减去 $f[j][0]$ 的值（$j$ 与 $min1$ 的不是同一个）。<br>设 $min3$ 为最小的一个 $f[j][2]$ 减去 $f[j][0]$ 的值。</p>
<p>为啥要减去 $f[j][0]$？<br>因为在求 $sum$ 时已经把 $f[j][0]$ 算上了，如果此处不减去 $f[j][0]$，在最后相加时会重复计算一个 $f[j][0]$ 。<br>也就是说，$min1、min2$ 实际上储存的是 最小的 $f[j][1]$ 或 $f[j][2]$ 以及 次小的 $f[j][1]$ 或 $f[j][2]$ 只是为了避免重复就减去了$f[j][0]$（具体等下看代码）。</p>
<p>当 $x$ 节点的 $sum$ 、$min1$ 、$min2$ 、$min3$ 都求出时：<br>根据定义得<br>$f[x][1]=sum$<br>$f[x][2]=sum+min1$<br>此时就能看出求 $min1、min2$  时为什么要减去 $f[j][0]$ 了。<br>以及有两种情况的 $f[x][0]$：<br>$f[x][0]=sum+1+\min(min1+min2 , min3)$<br>在两个情况中选择较小的一个。<br>下面见代码。</p>
<h4 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1100</span>;</span><br><span class="line"><span class="type">int</span> head[N], to[N], nxt[N], f[N][<span class="number">3</span>];</span><br><span class="line"><span class="type">int</span> n, cn;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//邻接表储存</span></span><br><span class="line">	nxt[++cn] = head[a];</span><br><span class="line">	to[cn] = b;</span><br><span class="line">	head[a] = cn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> fa)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> sum = <span class="number">0</span>, min1 = inf, min2 = inf, min3 = inf;</span><br><span class="line">	<span class="comment">//初始化</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = head[x]; i != <span class="number">-1</span>; i = nxt[i]) <span class="comment">//邻接表</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> j = to[i];</span><br><span class="line">		<span class="keyword">if</span> (j == fa)<span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">dfs</span>(j, x); <span class="comment">//从叶子结点往回 DP</span></span><br><span class="line">		</span><br><span class="line">		sum += f[j][<span class="number">0</span>]; <span class="comment">//计算 sum</span></span><br><span class="line">		</span><br><span class="line">		min3 = <span class="built_in">min</span>(min3, f[j][<span class="number">2</span>] - f[j][<span class="number">0</span>]);</span><br><span class="line">		<span class="comment">//求出最小的 f[j][2]，并减去 f[j][0]</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">min</span>(f[j][<span class="number">2</span>] - f[j][<span class="number">0</span>], f[j][<span class="number">1</span>] - f[j][<span class="number">0</span>]) &lt; min1) </span><br><span class="line">		&#123;  <span class="comment">//如果当前值比最小值小</span></span><br><span class="line">			min2 = min1;  <span class="comment">//更新次小值</span></span><br><span class="line">			min1 = <span class="built_in">min</span>(f[j][<span class="number">2</span>] - f[j][<span class="number">0</span>], f[j][<span class="number">1</span>] - f[j][<span class="number">0</span>]);</span><br><span class="line">			<span class="comment">//更新最小值</span></span><br><span class="line">			</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">min</span>(f[j][<span class="number">2</span>] - f[j][<span class="number">0</span>], f[j][<span class="number">1</span>] - f[j][<span class="number">0</span>]) &lt; min2) </span><br><span class="line">		&#123;  <span class="comment">//如果当前值比最小值大，比次小值小</span></span><br><span class="line">			min2 = <span class="built_in">min</span>(f[j][<span class="number">2</span>] - f[j][<span class="number">0</span>], f[j][<span class="number">1</span>] - f[j][<span class="number">0</span>]);</span><br><span class="line">			<span class="comment">//更新次小值</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	f[x][<span class="number">1</span>] = sum;</span><br><span class="line">	f[x][<span class="number">2</span>] = sum + min1;</span><br><span class="line">	f[x][<span class="number">0</span>] = sum + <span class="number">1</span> + <span class="built_in">min</span>(min1 + min2, min3);</span><br><span class="line">	<span class="comment">//求出各状态的值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n) != EOF) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head);</span><br><span class="line">		<span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">		cn = <span class="number">0</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> x, y;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">			<span class="built_in">add</span>(x, y);</span><br><span class="line">			<span class="built_in">add</span>(y, x);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f[<span class="number">1</span>][<span class="number">0</span>] &gt;= inf ? <span class="number">-1</span> : f[<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来是今天的最后一题。</p>
<h3 id="POJ-2152：Fire"><a href="#POJ-2152：Fire" class="headerlink" title="POJ-2152：Fire"></a><a href="http://poj.org/problem?id=2152">POJ-2152：Fire</a></h3><h4 id="题目描述-12"><a href="#题目描述-12" class="headerlink" title="题目描述"></a>题目描述</h4><p>在一棵树形的城市群中建立一些消防站（每个城市中建立消防站所需的花费不同），但每个城市有一个到消防站的最大距离限制，求需要的最小花费。</p>
<h4 id="输入-4"><a href="#输入-4" class="headerlink" title="输入"></a>输入</h4><p>多组测试数据。<br>第一行输入测试数据组数。</p>
<p>每族第一行一个整数 N，表示有几座城市。<br>第二行 N 个整数，表示在每个城市中建立消防站需要花费的金额。<br>第三行 N 个整数，表示每个城市到消防站的最大距离限制。<br>接下来 N - 1 行每行三个整数u、v、L，表示在 u 城市与 v 城市间有一条长度为 L 的路径。</p>
<h4 id="输出-4"><a href="#输出-4" class="headerlink" title="输出"></a>输出</h4><p>每组数据输出一行，表示最小的花费。</p>
<h4 id="题解-12"><a href="#题解-12" class="headerlink" title="题解"></a>题解</h4><p><del>这题好难啊</del><br>以后有空 <del>（下辈子）</del> 再来补吧。</p>
<p>OK<br>今天的树形DP打完了。<br>你学废了吗？</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Dumby的OI生涯</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>DP</tag>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷 P1081 [NOIP2012 提高组] 开车旅行 题解</title>
    <url>/2022/%E6%B4%9B%E8%B0%B7-P1081-NOIP2012-%E6%8F%90%E9%AB%98%E7%BB%84-%E5%BC%80%E8%BD%A6%E6%97%85%E8%A1%8C-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>先预处理出最近和次近的城市，记录下每次循环后所在城市的位置，然后倍增处理。</p>
<span id="more"></span>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://www.luogu.com.cn/problem/P1081">洛谷题目链接</a><br><a href="https://www.acwing.com/problem/content/295/">Acwing题目链接</a></p>
<h2 id="嗲吗"><a href="#嗲吗" class="headerlink" title="嗲吗"></a>嗲吗</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="comment">// #define int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp(x,y) make_pair(x,y)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb(x) push_back(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PII pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD=<span class="number">1000000007</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100001</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">10000001</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;<span class="keyword">register</span> <span class="type">char</span> c=<span class="built_in">getchar</span>();<span class="keyword">register</span> <span class="type">int</span> s=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">for</span>(;!<span class="built_in">isdigit</span>(c);c=<span class="built_in">getchar</span>())<span class="keyword">if</span>(c==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">-1</span>;<span class="keyword">for</span>(;<span class="built_in">isdigit</span>(c);c=<span class="built_in">getchar</span>())s=(s&lt;&lt;<span class="number">3</span>)+(s&lt;&lt;<span class="number">1</span>)+c-<span class="string">&#x27;0&#x27;</span>;<span class="keyword">return</span> s*f;&#125;</span><br><span class="line"><span class="type">int</span> n,m,h[N],pos[N][<span class="number">20</span>],a[N],b[N],x;</span><br><span class="line">set&lt;pair&lt;ll,<span class="type">int</span>&gt;&gt;s;</span><br><span class="line">ll d[N][<span class="number">20</span>],da[N][<span class="number">20</span>],db[N][<span class="number">20</span>];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(pair&lt;ll,<span class="type">int</span>&gt; a,pair&lt;ll,<span class="type">int</span>&gt; b)</span></span>&#123;<span class="keyword">return</span> a.first==b.first?h[a.second]&lt;h[b.second]:a.first&lt;b.first;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">freopen</span>(<span class="string">&quot;in.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin); <span class="built_in">freopen</span>(<span class="string">&quot;out.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">	n=<span class="built_in">read</span>();</span><br><span class="line">	<span class="type">int</span> LOG=<span class="built_in">log2</span>(n)+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) h[i]=<span class="built_in">read</span>();</span><br><span class="line">	s.<span class="built_in">insert</span>(&#123;<span class="number">0x3f3f3f3f3f3f3f3f</span>,<span class="number">0</span>&#125;);</span><br><span class="line">	s.<span class="built_in">insert</span>(&#123;<span class="number">-0x3f3f3f3f3f3f3f3f</span>,<span class="number">0</span>&#125;);</span><br><span class="line">	vector&lt;pair&lt;ll,<span class="type">int</span>&gt;&gt;ooo;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=n;i;i--)&#123;</span><br><span class="line">		ooo.<span class="built_in">clear</span>();</span><br><span class="line">		<span class="keyword">auto</span> it=s.<span class="built_in">lower_bound</span>(&#123;h[i],i&#125;);</span><br><span class="line">		<span class="keyword">auto</span> ij=it;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">1</span>;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(ij!=s.<span class="built_in">end</span>())&#123;</span><br><span class="line">				ooo.<span class="built_in">push_back</span>(&#123;<span class="built_in">abs</span>((ll)h[i]-ij-&gt;first),ij-&gt;second&#125;);</span><br><span class="line">				ij++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">1</span>;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(it!=s.<span class="built_in">begin</span>())&#123;</span><br><span class="line">				it--;</span><br><span class="line">				ooo.<span class="built_in">push_back</span>(&#123;<span class="built_in">abs</span>((ll)h[i]-it-&gt;first),it-&gt;second&#125;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">sort</span>(ooo.<span class="built_in">begin</span>(),ooo.<span class="built_in">end</span>(),cmp);</span><br><span class="line">		b[i]=ooo[<span class="number">0</span>].second;</span><br><span class="line">		a[i]=ooo[<span class="number">1</span>].second;</span><br><span class="line">		s.<span class="built_in">insert</span>(&#123;h[i],i&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">memset</span>(d,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> d);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(a[i])da[i][<span class="number">1</span>]=<span class="built_in">abs</span>(h[a[i]]-h[i]);</span><br><span class="line">		<span class="keyword">if</span>(b[a[i]])db[i][<span class="number">1</span>]=<span class="built_in">abs</span>(h[b[a[i]]]-h[a[i]]);</span><br><span class="line">		d[i][<span class="number">1</span>]=da[i][<span class="number">1</span>]+db[i][<span class="number">1</span>];</span><br><span class="line">		pos[i][<span class="number">1</span>]=b[a[i]];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">2</span>;l&lt;LOG;l++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;pos[i][l<span class="number">-1</span>];i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(!pos[pos[i][l<span class="number">-1</span>]][l<span class="number">-1</span>])<span class="keyword">continue</span>;</span><br><span class="line">			d[i][l]=d[i][l<span class="number">-1</span>]+d[pos[i][l<span class="number">-1</span>]][l<span class="number">-1</span>];</span><br><span class="line">			da[i][l]=da[i][l<span class="number">-1</span>]+da[pos[i][l<span class="number">-1</span>]][l<span class="number">-1</span>];</span><br><span class="line">			db[i][l]=db[i][l<span class="number">-1</span>]+db[pos[i][l<span class="number">-1</span>]][l<span class="number">-1</span>];</span><br><span class="line">			pos[i][l]=pos[pos[i][l<span class="number">-1</span>]][l<span class="number">-1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	x=<span class="built_in">read</span>();</span><br><span class="line">	<span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="type">double</span> anss=<span class="number">10000000000000000</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="type">int</span> sa=<span class="number">0</span>,sb=<span class="number">0</span>,k=<span class="number">1</span>,p=i,xx=x;</span><br><span class="line">		<span class="keyword">while</span>(k)&#123;</span><br><span class="line">			<span class="keyword">if</span>(xx&gt;=d[p][k])xx-=d[p][k],sa+=da[p][k],sb+=db[p][k],p=pos[p][k],k++;</span><br><span class="line">			<span class="keyword">else</span> k--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(a[p]&amp;&amp;xx&gt;=<span class="built_in">abs</span>(h[a[p]]-h[p]))sa+=<span class="built_in">abs</span>(h[a[p]]-h[p]);</span><br><span class="line">		<span class="type">double</span> op=<span class="number">10000000000000000</span>;</span><br><span class="line">		<span class="keyword">if</span>(sb!=<span class="number">0</span>) op=(<span class="type">double</span>)sa/sb;</span><br><span class="line">		<span class="keyword">if</span>(op+<span class="number">0.000001</span>&lt;anss)&#123;</span><br><span class="line">			anss=op;</span><br><span class="line">			ans=i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">abs</span>(op-anss)&lt;=<span class="number">0.000001</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(h[ans]&lt;h[i])ans=i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">	m=<span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">		<span class="type">int</span> s=<span class="built_in">read</span>();</span><br><span class="line">		x=<span class="built_in">read</span>();</span><br><span class="line">		<span class="type">int</span> sa=<span class="number">0</span>,sb=<span class="number">0</span>,k=<span class="number">1</span>,p=s,xx=x;</span><br><span class="line">		<span class="keyword">while</span>(k)&#123;</span><br><span class="line">			<span class="keyword">if</span>(xx&gt;=d[p][k])xx-=d[p][k],sa+=da[p][k],sb+=db[p][k],p=pos[p][k],k++;</span><br><span class="line">			<span class="keyword">else</span> k--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(a[p]&amp;&amp;xx&gt;=<span class="built_in">abs</span>(h[a[p]]-h[p]))sa+=<span class="built_in">abs</span>(h[a[p]]-h[p]);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,sa,sb);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Dumby的OI生涯</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>DP</tag>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷 P2824 排序</title>
    <url>/2022/%E6%B4%9B%E8%B0%B7-P2824-%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>洛谷P2824 [HEOI2016/TJOI2016]排序题解。</p>
<span id="more"></span>
<p><a href="https://www.luogu.com.cn/problem/P2824">洛谷P2824 [HEOI2016/TJOI2016]排序</a>。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="离线做法"><a href="#离线做法" class="headerlink" title="离线做法"></a>离线做法</h3><p>受 01 串排序的启发，我们可以二分答案，将大于等于 $mid$ 的数设为 $1$，小于的设为 $0$，然后排个序。</p>
<p>如果排完序后询问的 $q$ 位置的数仍为 $1$，则 $mid$ 可行。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#define ll long long</span></span><br><span class="line"><span class="comment">//#define int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp(x,y) make_pair(x,y)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb(x) push_back(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PII pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD=<span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">10000002</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">10000001</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;<span class="keyword">register</span> <span class="type">char</span> c=<span class="built_in">getchar</span>();<span class="keyword">register</span> <span class="type">int</span> s=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">for</span>(;!<span class="built_in">isdigit</span>(c);c=<span class="built_in">getchar</span>())<span class="keyword">if</span>(c==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">-1</span>;<span class="keyword">for</span>(;<span class="built_in">isdigit</span>(c);c=<span class="built_in">getchar</span>())s=(s&lt;&lt;<span class="number">3</span>)+(s&lt;&lt;<span class="number">1</span>)+c-<span class="string">&#x27;0&#x27;</span>;<span class="keyword">return</span> s*f;&#125;</span><br><span class="line"><span class="type">int</span> n,m,q;</span><br><span class="line"><span class="type">int</span> a[N],f[N];</span><br><span class="line"><span class="type">int</span> t[N],l[N],r[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> l,r,d,add;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> l(x) tr[x].l</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> r(x) tr[x].r</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> d(x) tr[x].d</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> add(x) tr[x].add</span></span><br><span class="line">&#125; tr[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="built_in">l</span>(p)=l,<span class="built_in">r</span>(p)=r,<span class="built_in">add</span>(p)=<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">		<span class="built_in">d</span>(p)=f[l];</span><br><span class="line">		<span class="keyword">return</span> ; </span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">build</span>(p*<span class="number">2</span>,l,mid);</span><br><span class="line">	<span class="built_in">build</span>(p*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">	<span class="built_in">d</span>(p)=<span class="built_in">d</span>(p*<span class="number">2</span>)+<span class="built_in">d</span>(p*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">add</span>(p)!=<span class="number">2</span>)&#123;</span><br><span class="line">		<span class="built_in">d</span>(p*<span class="number">2</span>)=<span class="built_in">add</span>(p)*(<span class="built_in">r</span>(p*<span class="number">2</span>)-<span class="built_in">l</span>(p*<span class="number">2</span>)+<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">d</span>(p*<span class="number">2</span>+<span class="number">1</span>)=<span class="built_in">add</span>(p)*(<span class="built_in">r</span>(p*<span class="number">2</span>+<span class="number">1</span>)-<span class="built_in">l</span>(p*<span class="number">2</span>+<span class="number">1</span>)+<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">add</span>(p*<span class="number">2</span>)=<span class="built_in">add</span>(p*<span class="number">2</span>+<span class="number">1</span>)=<span class="built_in">add</span>(p);</span><br><span class="line">		<span class="built_in">add</span>(p)=<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l&lt;=<span class="built_in">l</span>(p)&amp;&amp;<span class="built_in">r</span>(p)&lt;=r)&#123;</span><br><span class="line">		<span class="built_in">add</span>(p)=d;</span><br><span class="line">		<span class="built_in">d</span>(p)=d*(<span class="built_in">r</span>(p)-<span class="built_in">l</span>(p)+<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">pushdown</span>(p);</span><br><span class="line">	<span class="type">int</span> mid=(<span class="built_in">l</span>(p)+<span class="built_in">r</span>(p))&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(l&lt;=mid)<span class="built_in">change</span>(p*<span class="number">2</span>,l,r,d);</span><br><span class="line">	<span class="keyword">if</span>(r&gt;mid)<span class="built_in">change</span>(p*<span class="number">2</span>+<span class="number">1</span>,l,r,d);</span><br><span class="line">	<span class="built_in">d</span>(p)=<span class="built_in">d</span>(p*<span class="number">2</span>)+<span class="built_in">d</span>(p*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">asksum</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l&lt;=<span class="built_in">l</span>(p)&amp;&amp;<span class="built_in">r</span>(p)&lt;=r) <span class="keyword">return</span> <span class="built_in">d</span>(p);</span><br><span class="line">	<span class="built_in">pushdown</span>(p);</span><br><span class="line">	<span class="type">int</span> mid=(<span class="built_in">l</span>(p)+<span class="built_in">r</span>(p))&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(l&lt;=mid)ans+=<span class="built_in">asksum</span>(p*<span class="number">2</span>,l,r);</span><br><span class="line">	<span class="keyword">if</span>(r&gt;mid)ans+=<span class="built_in">asksum</span>(p*<span class="number">2</span>+<span class="number">1</span>,l,r);</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">l</span>(p)==<span class="built_in">r</span>(p)) <span class="keyword">return</span> <span class="built_in">d</span>(p);</span><br><span class="line">	<span class="built_in">pushdown</span>(p);</span><br><span class="line">	<span class="type">int</span> mid=(<span class="built_in">l</span>(p)+<span class="built_in">r</span>(p))&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(k&lt;=mid)<span class="keyword">return</span> <span class="built_in">ask</span>(p*<span class="number">2</span>,k);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">ask</span>(p*<span class="number">2</span>+<span class="number">1</span>,k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ll,rr;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> mid)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		f[i]=(a[i]&gt;=mid);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!t[i])&#123;</span><br><span class="line">			<span class="type">int</span> sum=<span class="built_in">asksum</span>(<span class="number">1</span>,l[i],r[i]);</span><br><span class="line">			<span class="built_in">change</span>(<span class="number">1</span>,l[i],r[i]-sum,<span class="number">0</span>);</span><br><span class="line">			<span class="built_in">change</span>(<span class="number">1</span>,r[i]-sum+<span class="number">1</span>,r[i],<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="type">int</span> sum=<span class="built_in">asksum</span>(<span class="number">1</span>,l[i],r[i]);</span><br><span class="line">			<span class="built_in">change</span>(<span class="number">1</span>,l[i],l[i]+sum<span class="number">-1</span>,<span class="number">1</span>);</span><br><span class="line">			<span class="built_in">change</span>(<span class="number">1</span>,l[i]+sum,r[i],<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">ask</span>(<span class="number">1</span>,q);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	n=<span class="built_in">read</span>(),m=<span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)a[i]=<span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)t[i]=<span class="built_in">read</span>(),l[i]=<span class="built_in">read</span>(),r[i]=<span class="built_in">read</span>();</span><br><span class="line">	q=<span class="built_in">read</span>();</span><br><span class="line">	ll=<span class="number">1</span>,rr=n;</span><br><span class="line">	<span class="keyword">while</span>(ll&lt;=rr)&#123;</span><br><span class="line">		<span class="type">int</span> mid=(ll+rr)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">check</span>(mid))ll=mid+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> rr=mid<span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ll<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="在线做法"><a href="#在线做法" class="headerlink" title="在线做法"></a>在线做法</h3><p>在线做法同 <a href="https://www.luogu.com.cn/problem/CF558E">CF558E A Simple Task</a>。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Dumby的OI生涯</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>线段树</tag>
        <tag>数据结构</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷 P4550 收集邮票</title>
    <url>/2022/%E6%B4%9B%E8%B0%B7-P4550-%E6%94%B6%E9%9B%86%E9%82%AE%E7%A5%A8/</url>
    <content><![CDATA[<p>洛谷 P4550 收集邮票题解。</p>
<span id="more"></span>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>和 <a href="/2022/UVA10288-%E4%BC%98%E6%83%A0%E5%88%B8-Coupons/" title="UVA10288 优惠券">UVA10288 优惠券</a> 很像，只不过加了价格随次数变动的条件。</p>
<p>在原来式子的基础上改一下，第一次取出第 $i$ 个物品期望需要的价格是取出前 $i$ 个物品期望需要的次数总和（也就是价格）乘上取出第 $i$ 个期望需要的次数（注意这里的价格是平均过的）。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="comment">//#define int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp(x,y) make_pair(x,y)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb(x) push_back(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PII pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD=<span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1000002</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">10000001</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;<span class="keyword">register</span> <span class="type">char</span> c=<span class="built_in">getchar</span>();<span class="keyword">register</span> <span class="type">int</span> s=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">for</span>(;!<span class="built_in">isdigit</span>(c);c=<span class="built_in">getchar</span>())<span class="keyword">if</span>(c==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">-1</span>;<span class="keyword">for</span>(;<span class="built_in">isdigit</span>(c);c=<span class="built_in">getchar</span>())s=(s&lt;&lt;<span class="number">3</span>)+(s&lt;&lt;<span class="number">1</span>)+c-<span class="string">&#x27;0&#x27;</span>;<span class="keyword">return</span> s*f;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">readd</span><span class="params">()</span></span>&#123;<span class="type">int</span> y=<span class="number">0</span>;<span class="type">char</span> h=<span class="built_in">getchar</span>();<span class="keyword">while</span>(h&lt;<span class="string">&#x27;0&#x27;</span>||h&gt;<span class="string">&#x27;9&#x27;</span>)h=<span class="built_in">getchar</span>();<span class="keyword">while</span>(h&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;h&lt;=<span class="string">&#x27;9&#x27;</span>)y=y*<span class="number">10</span>+h-<span class="string">&#x27;0&#x27;</span>,h=<span class="built_in">getchar</span>();<span class="keyword">if</span>(h==<span class="string">&#x27;.&#x27;</span>)&#123;h=<span class="built_in">getchar</span>();<span class="type">double</span> t=<span class="number">0</span>,t2=<span class="number">0.1</span>;<span class="keyword">while</span>(h&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;h&lt;=<span class="string">&#x27;9&#x27;</span>)t=t+t2*(h-<span class="string">&#x27;0&#x27;</span>),t2/=<span class="number">10</span>,h=<span class="built_in">getchar</span>();<span class="keyword">return</span> y+t;&#125;<span class="keyword">return</span> y;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> n=<span class="built_in">read</span>();</span><br><span class="line">	<span class="type">double</span> sum=<span class="number">0</span>,ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		sum+=<span class="number">1.0</span>*n/(n-i+<span class="number">1</span>);</span><br><span class="line">		ans+=sum*<span class="number">1.0</span>*n/(n-i+<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%.2lf&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Dumby的OI生涯</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>DP</tag>
        <tag>期望</tag>
        <tag>线性DP</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P3263题解报告</title>
    <url>/2021/%E6%B4%9B%E8%B0%B7P3263%E9%A2%98%E8%A7%A3%E6%8A%A5%E5%91%8A/</url>
    <content><![CDATA[<p>洛谷P3263有意义的字符串题解。</p>
<span id="more"></span>
<p><a href="https://www.luogu.com.cn/problem/P3263">洛谷P3263</a></p>
<h2 id="题意描述"><a href="#题意描述" class="headerlink" title="题意描述"></a>题意描述</h2><p>给定 $b$、$d$ 和 $n$。</p>
<p><del>试</del>求出：</p>
<p>$\left \lfloor  \left (    \frac{b+\sqrt{d} }{2}   \right )^{n} \right \rfloor \bmod{p} $</p>
<p>其中  $p=7528443412579576937$ ，$0 &lt; b^{2} \le d &lt; (b+1)^{2}\le 10^{18}$，$n\le 10^{18}$ 且 $b\bmod{2}=1$，$d \bmod{4}=1$。</p>
<h2 id="题解报告"><a href="#题解报告" class="headerlink" title="题解报告"></a>题解报告</h2><p>式子较为复杂，看了下标签是“矩阵乘法”，更加蒙了。（原本都打算搞个 $double$ 的矩阵了。。。）</p>
<p>想要让式子与矩乘挂上钩，首先想到要把那个根号给去掉。于是想到在原式后加一个式子使两者相加能将根号去掉。</p>
<p>由于有一个 $n$，可以想到将带根号的那一项取负，其他不变（暂不考虑取模和向下取整），然后原式变为：</p>
<p>$\left (  \frac{b-\sqrt{d} }{2}  \right )^{n}$</p>
<p>在原式后加上现在这个式子便可将根号消掉，即：</p>
<p>$\left (  \frac{b+\sqrt{d} }{2}  \right )^{n}+ \left (  \frac{b-\sqrt{d} }{2} \right )^{n}$</p>
<p>然后在式子最后减去一个 $\left (  \frac{b-\sqrt{d} }{2} \right )^{n}$ 就好了。</p>
<p>设 $x$ 为 $\frac{b+\sqrt{d} }{2}$，$y$ 为 $\frac{b-\sqrt{d} }{2}$。</p>
<p>设 $f_{n}=x^{n}+y^{n}$。</p>
<p>那么可以设我们的状态矩阵为：</p>
<p>$\begin{bmatrix}  f_{n}&amp;f_{n-1} \end{bmatrix}$</p>
<p>需要通过 </p>
<p>$\begin{bmatrix}  f_{n-1}&amp;f_{n-2} \end{bmatrix}$</p>
<p>转移到</p>
<p>$\begin{bmatrix}  f_{n}&amp;f_{n-1} \end{bmatrix}$</p>
<p>接下来考虑如何转移。</p>
<p>将 $f_{n}$ 拆成 $X\times f_{n-1}-X\times f_{n-2}$ 的形式，又因为 $f_{n-1}=x^{n-1}+y^{n-1}$，$f_{n-2}=x^{n-2}+y^{n-2}$，代入得： </p>
<p>$X\times \left ( x^{n-1}+y^{n-1} \right ) -X\times \left ( x^{n-2}+y^{n-2} \right )$</p>
<p>于是稍加考虑就可以得出：</p>
<p>$x^{n}+y^{n}=\left ( x+y \right ) \times \left ( x^{n-1}+y^{n-1} \right ) - xy \times \left ( x^{n-2}+y^{n-2} \right )$</p>
<p>所以转移式为：</p>
<p>$f_{n}=\left ( x+y \right ) \times f_{n-1}- xy \times f_{n-2}$</p>
<p>能保证这个式子中没有任何浮点数吗？</p>
<p>我们发现 $f_{1}=\frac{b+\sqrt{d} }{2}+\frac{b-\sqrt{d} }{2}=b$，$f_{2}= \left (  \frac{b+\sqrt{d} }{2}  \right )^{2}+ \left (  \frac{b-\sqrt{d} }{2} \right )^{2} = \frac{b^{2}+d }{2}$。</p>
<p>$b$ 一定是整数，而由于 $b\bmod{2}=1$，$d \bmod{4}=1$，由费马小定理可得 $b^{2}\equiv b \pmod{2}$，所以 $b^{2}+d \bmod{2}=0$，所以 $\frac{b^{2}+d }{2}$ 也是整数。</p>
<p>于是乎，$f_{1}$ 和 $f_{2}$ 都是整数，接下来只需证明出他俩前面的系数也是整数就好了。</p>
<p>首先易得 $x+y=b$，所以 $x+y$ 是整数，然后 $xy=\frac{b^{2}-d}{4}$，由欧拉定理可得 $b^{\varphi (4)}=b^{2}\equiv 1\pmod{4}$，又因为 $d \bmod{4}=1$，所以 $\left ( b^{2}-d \right ) \bmod 4=0$，所以 $xy$ 为整数。</p>
<p>综上，$f_{n}$ 总为整数。</p>
<p>所以转移矩阵也同时推出来了。</p>
<p>如下：</p>
<p>$\begin{bmatrix} b &amp;1 \\ -\frac{b^{2}-d}{4} &amp;0\end{bmatrix}$</p>
<p>这里的 $-\frac{b^{2}-d}{4}$ 为了方便可以写成 $\frac{d-b^{2}}{4}$。</p>
<p>最后再来看看刚才这个东西对答案的影响：</p>
<blockquote>
<p>然后在式子最后减去一个 $\left (  \frac{b-\sqrt{d} }{2} \right )^{n}$ 就好了。</p>
</blockquote>
<p>由于答案是向下取整，所以当 $-\left (  \frac{b-\sqrt{d} }{2} \right )^{n}$ 为正且大小在区间 $\left [ 0,1 \right )$ 时对答案无影响。</p>
<p>由于 $0 &lt; b^{2} \le d &lt; (b+1)^{2}\le 10^{18} $，所以 $\left (  \frac{b-\sqrt{d} }{2} \right )^{n}$ 的范围一定在区间 $\left [ 0,1 \right )$ 内。</p>
<p>接下来只要讨论式子的正负性。</p>
<p>因为 $0 &lt; b^{2} \le d$，所以 $\frac{b-\sqrt{d} }{2}$ 一定小于 0。</p>
<p>当 $n \bmod{2}=1$ 时，即 $n$ 为奇数时，$-\left (  \frac{b-\sqrt{d} }{2} \right )^{n}$ 一定的范围一定在 $\left [ 0,1 \right )$ 内，对答案没有影响。</p>
<p>相反，当 $n \bmod{2}=0$ 时，$-\left (  \frac{b-\sqrt{d} }{2} \right )^{n}$ 的范围在区间 $\left ( -1,0 \right ]$ 内。当式子等于 0 时,即 $b=\sqrt{d}$，$b^{2}=d$ 时，该式对答案无影响。</p>
<p>综上，当且仅当 $n$ 为偶数且 $b^{2} \ne d$ 时，该式对答案有影响，答案向下取整后的值需要减一。</p>
<p>说了一大堆，终于到了大家最爱的代码时间。</p>
<h2 id="嗲吗"><a href="#嗲吗" class="headerlink" title="嗲吗"></a>嗲吗</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">tormul</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> k)</span> </span></span><br><span class="line"><span class="function"></span>&#123;  <span class="comment">//龟速乘</span></span><br><span class="line">	ull ans = <span class="number">0</span>;  <span class="comment">//注意要开 ull，否则会 TLE！！（玄学 T，难道不应该 WA 吗）</span></span><br><span class="line">	<span class="keyword">while</span> (k) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (k &amp; <span class="number">1</span>)ans = (ans + a) % MOD;</span><br><span class="line">		a = (ull)(a + a) % MOD;  <span class="comment">//开 ull。</span></span><br><span class="line">		k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">mat</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">	<span class="built_in">mat</span>() &#123; <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span> a); &#125;</span><br><span class="line">	mat <span class="keyword">operator</span> *(<span class="type">const</span> mat &amp;b)<span class="type">const</span> </span><br><span class="line">	&#123;</span><br><span class="line">		mat op;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) </span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">2</span>; k++) </span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++) </span><br><span class="line">					op.a[i][j] = (ull)(op.a[i][j] + <span class="built_in">tormul</span>(a[i][k], b.a[k][j])) % MOD;  <span class="comment">//ull</span></span><br><span class="line">		<span class="keyword">return</span> op;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; ans, I;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	I.a[<span class="number">0</span>][<span class="number">0</span>] = b, I.a[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>, I.a[<span class="number">1</span>][<span class="number">0</span>] = (d - b * b) / <span class="number">4</span>;</span><br><span class="line">	ans.a[<span class="number">0</span>][<span class="number">0</span>] = (b * b + d) / <span class="number">2</span>, ans.a[<span class="number">0</span>][<span class="number">1</span>] = b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	b = <span class="built_in">read</span>(), d = <span class="built_in">read</span>(), n = <span class="built_in">read</span>();</span><br><span class="line">	<span class="built_in">init</span>();</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">0ll</span>) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">1ll</span>) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>, (<span class="type">int</span>)((b + <span class="built_in">sqrt</span>(d)) / <span class="number">2</span>) % MOD);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	n -= <span class="number">2</span>;</span><br><span class="line">	<span class="type">int</span> ff = <span class="number">0</span>; <span class="comment">//用来判断最后减去的式子对答案是否有影响。</span></span><br><span class="line">	<span class="keyword">if</span> (b * b != d &amp;&amp; n % <span class="number">2</span> == <span class="number">0</span>) ff--;</span><br><span class="line">	<span class="keyword">while</span> (n) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (n &amp; <span class="number">1</span>)ans = ans * I;</span><br><span class="line">		I = I * I;</span><br><span class="line">		n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ans.a[<span class="number">0</span>][<span class="number">0</span>] += ff;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>, ans.a[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有错误请 D 我</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Dumby的OI生涯</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>矩阵乘法</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈傅里叶分析</title>
    <url>/2022/%E6%B5%85%E8%B0%88%E5%82%85%E9%87%8C%E5%8F%B6%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>学这个不是因为OI，只是为了更深刻地了解一下合成器原理。</p>
<span id="more"></span>
<p>傅里叶分析可以分为傅里叶级数和傅里叶变换</p>
<h2 id="傅里叶级数"><a href="#傅里叶级数" class="headerlink" title="傅里叶级数"></a>傅里叶级数</h2><p>级数就是把数列的每个项依次用加号连接起来得到的函数。</p>
<p>如果你要公式的话：</p>
<p>给定一个周期为 $T$ 的函数 $x(t)$，那么它可以表示为无穷级数：</p>
<p>$x(t)=\sum_{k=-\infty}^{+\infty} a_{k} \cdot e^{j k\left(\frac{2 \pi}{T}\right) t}$</p>
<p>其中，$a_{k}$ 可以按照如下方式计算：</p>
<p>$a_{k}=\frac{1}{T} \int_{T} x(t) \cdot e^{-j k\left(\frac{2 \pi}{T}\right) t} d t$</p>
<p>以上就是傅里叶级数的公式，显然这对我们这些蒟蒻来说过于晦涩难懂了。</p>
<p>那么傅里叶级数到底是什么东西？</p>
<p>按照傅里叶的理论，任何满足条件（狄利克雷条件）的周期函数都可以用三角函数构成的无穷级数来表示。<br>这种级数就叫做傅里叶级数。</p>
<h2 id="傅里叶变换"><a href="#傅里叶变换" class="headerlink" title="傅里叶变换"></a>傅里叶变换</h2><p>傅里叶变换，表示能将满足一定条件的某个函数表示成三角函数（正弦和/或余弦函数）或者它们的积分的线性组合。（百度百科）</p>
<p>注意傅里叶变换和傅里叶级数两者的区别：</p>
<blockquote>
<p>任何满足条件（狄利克雷条件）的<strong>周期函数</strong>都可以用三角函数构成的无穷级数来表示。（傅里叶级数）<br>将<strong>满足一定条件的某个函数</strong>表示成三角函数（正弦和/或余弦函数）或者它们的积分的线性组合。（傅里叶变换）</p>
</blockquote>
<p>傅里叶级数强调的是<strong>周期函数</strong>，而傅里叶变换针对的是<strong>非周期函数</strong>。</p>
<p>傅里叶级数是将<strong>周期函数</strong>转化为<strong>非周期离散函数</strong>，而傅里叶变换将<strong>非周期函数</strong>转化为<strong>非周期连续函数</strong>。</p>
<p>理论知识只需要了解到这里就够了（对于理解合成器的原理），接下来聊一聊它的实际用处。</p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>用一个最典型的波形来举个例子。</p>
<p><img src="方波.png" alt="方波" title="方波"></p>
<p>按照上文所说，这个方波是可以经过傅里叶分析变成一系列的正弦波的，那么如何做到呢？</p>
<p>我们看看普通的一个正弦波：</p>
<p><img src="方波1.png" alt="正弦波叠加方波" title="正弦波叠加方波"></p>
<p>如果给这个正弦波再加上一个正弦波（紫色的是新加的正弦波）：</p>
<p><img src="方波2.png" alt="两个正弦波相加叠加方波" title="两个正弦波相加叠加方波"></p>
<p>再加：</p>
<p><img src="方波3.png" alt="三个正弦波相加叠加方波" title="三个正弦波相加叠加方波"></p>
<p>不停的加：</p>
<p><img src="方波4.png" alt="十个正弦波相加叠加方波" title="十个正弦波相加叠加方波"></p>
<p>我们发现，在加了很多很多正弦波以后，它变成了这样：</p>
<p><img src="方波5.png" alt="500个正弦波相加叠加方波" title="500个正弦波相加叠加方波"></p>
<p>如果写成公式，方波是这样的：</p>
<p>$f(x)=\frac{4}{\pi} \sum_{i=1}^{\infty}\frac{1}{2i-1}\sin((2i-1)x)$</p>
<p>也就是说，方波可以分解成无穷多个正弦波。<br>我们可以通过很多正弦波来叠加出方波，拓展开，可以用很多正弦波叠加出任何符合条件的复杂波形。</p>
<p>有很多合成器都是根据这个理论实现的（比如最基础的加法合成器和减法合成器）。</p>
<p>顺便结合合成器讲讲一些合成器和傅里叶分析中重要的概念：时域、频域、相位域。</p>
<p>打开合成器（这里用Serum做演示），看到OSC A一栏，注意到现在用的是默认的锯齿波。<br>我们现在看到的这个：</p>
<p><img src="时域.png" alt="时域图像" title="时域图像"></p>
<p>这个就是该波形的时域图像。</p>
<p>具体点讲，我们将图像按照时间的变化画出就能得到这么一张时域图像。</p>
<p><img src="时间轴.png" alt="时间轴" title="时间轴"></p>
<p>严谨地说，时域（Time domain）是描述数学函数或物理信号对时间的关系。（百度百科）</p>
<p>接下来点击编辑按钮进入波形的编辑界面：</p>
<p><img src="波形编辑.png" alt="波形编辑界面" title="波形编辑界面"></p>
<p>看到上半部分：</p>
<p><img src="上半部分.png" alt="编辑界面的上半部分" title="编辑界面的上半部分"></p>
<p>左下角有个箭头的按钮，那个按钮叫 <strong>“Wave to FFT”</strong>，即将波形进行 <strong>快速傅里叶变换</strong>。</p>
<p>快速傅里叶变换 (Fast Fourier Transform), 即利用计算机计算离散傅里叶变换（DFT)的高效、快速计算方法的统称，简称FFT。（百度百科）</p>
<p>我们点击该按钮后，电脑就会根据下半部分的波形计算出这个：</p>
<p><img src="频域.png" alt="频域图像" title="频域图像"></p>
<p>这个就是这个锯齿波在频域上的图像，这张图也叫频谱。</p>
<p>严谨地讲，频域（frequency domain）是描述信号在频率方面特性时用到的一种坐标系；而频谱是频率谱密度的简称，是频率的分布曲线。（百度百科）</p>
<p>掏两张知乎巨佬Heinrich的图：</p>
<p>频谱是：</p>
<p><img src="图一.jpg" alt="知乎巨佬的图" title="知乎巨佬的图"></p>
<p>整合一下：</p>
<p><img src="图二.jpg" alt="知乎巨佬的图" title="知乎巨佬的图"></p>
<p>接下来回到开始的主界面：</p>
<p><img src="主界面.png" alt="主界面" title="主界面"></p>
<p>我们看到下面编辑栏里有个旋钮叫 <strong>“PHASE”</strong>，意思是 <strong>“相位”</strong>。</p>
<p>相位(phase)是对于一个波，特定的时刻在它循环中的位置：一种它是否在波峰、波谷或它们之间的某点的标度。（百度百科）</p>
<p>简单来说相位就是用来确定一个波在循环中的位置的东西。</p>
<p>对于一个正弦波：</p>
<p>$y=A\sin\left(\frac{2\pi}{T}t+\varphi_{0}\right)$</p>
<p>$A$ 是该波的振幅，$T$ 是该波的周期，括号中的 $\frac{2\pi}{T}t+\varphi_{0}$ 就是这个波的相位，而 $\varphi_{0}$ 就是这个波的初相。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;一个草率的结尾&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对了，推荐韩昊巨佬（知乎Heinrich）的文章，链接在下面。</p>
<p>参考：</p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/19763358">韩 昊 的文章《傅里叶分析之掐死教程》</a></li>
<li><a href="https://baike.baidu.com/item/%E5%82%85%E9%87%8C%E5%8F%B6%E7%BA%A7%E6%95%B0/5210337">百度百科</a></li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Dumby的折腾笔记</category>
      </categories>
      <tags>
        <tag>合成器</tag>
        <tag>傅里叶分析</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P4197 Peaks (Kruskal重构树) 题解</title>
    <url>/2022/%E6%B4%9B%E8%B0%B7P4197-Peaks-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<p>克鲁斯卡尔重构树介绍以及洛谷P4197 Peaks 题解。</p>
<span id="more"></span>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>先说下 Kruskal重构树 是啥。</p>
<h3 id="Kruskal重构树"><a href="#Kruskal重构树" class="headerlink" title="Kruskal重构树"></a>Kruskal重构树</h3><p>在一个无向联通图中，按照 Kruskal 求最小生成树的方法找到最小的边。</p>
<p>把这些找出来的边抽象成点，把边的两端所在的集合的根节点作为新点的左右儿子，把边权作为新点的点权。</p>
<p>在加了 $n-1$ 次点后，我们得到一棵符合大（小） 根堆性质的有 $n$ 个节点的二叉树，这棵树就叫Kruskal重构树。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>得到Kruskal重构树后，我们只需要先处理出叶子节点的 DFS序，然后倍增找到第一个大于 $x$ 的询问节点的祖先节点，再用主席树查一下第 $k$ 大就好了。</p>
<p>整体思路是 Kruskal重构 -&gt; 倍增 -&gt; DFS序 -&gt; 主席树。</p>
<h2 id="嗲吗"><a href="#嗲吗" class="headerlink" title="嗲吗"></a>嗲吗</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="comment">// #define int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp(x,y) make_pair(x,y)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb(x) push_back(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PII pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD=<span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2000002</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">10000001</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;<span class="keyword">register</span> <span class="type">char</span> c=<span class="built_in">getchar</span>();<span class="keyword">register</span> <span class="type">int</span> s=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">for</span>(;!<span class="built_in">isdigit</span>(c);c=<span class="built_in">getchar</span>())<span class="keyword">if</span>(c==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">-1</span>;<span class="keyword">for</span>(;<span class="built_in">isdigit</span>(c);c=<span class="built_in">getchar</span>())s=(s&lt;&lt;<span class="number">3</span>)+(s&lt;&lt;<span class="number">1</span>)+c-<span class="string">&#x27;0&#x27;</span>;<span class="keyword">return</span> s*f;&#125;</span><br><span class="line"><span class="type">int</span> n,m,q;</span><br><span class="line"><span class="type">int</span> h[N],a[N];<span class="comment">//离散山高和山高</span></span><br><span class="line"><span class="type">int</span> tot;<span class="comment">//重构树节点数</span></span><br><span class="line"><span class="type">int</span> v[N];<span class="comment">//重构树非叶子节点点权（原道路长度）</span></span><br><span class="line"><span class="type">int</span> fa[N][<span class="number">21</span>];<span class="comment">//父节点（倍增）</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">	<span class="type">int</span> a,b,d;</span><br><span class="line">	<span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> edge x)<span class="type">const</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> d&lt;x.d;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;E[M];<span class="comment">//用于Kruskal的边</span></span><br><span class="line"><span class="type">int</span> faf[N];<span class="comment">//并查集父节点</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> x==faf[x]?x:faf[x]=<span class="built_in">find</span>(faf[x]);&#125;<span class="comment">//并查集找爹，用于Kruskal</span></span><br><span class="line"><span class="type">int</span> ch[N][<span class="number">2</span>];<span class="comment">//重构树中每个节点的儿子</span></span><br><span class="line"><span class="type">int</span> cnt;<span class="comment">//重构树中叶子节点个数</span></span><br><span class="line"><span class="type">int</span> idl[N];<span class="comment">//idl[i]表示重构树中以i为根的子树中最左边的叶子节点的新编号</span></span><br><span class="line"><span class="type">int</span> idr[N];<span class="comment">//同上</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">kruskal</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">stable_sort</span>(E+<span class="number">1</span>,E+m+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) faf[i]=i;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		<span class="type">int</span> Fa=<span class="built_in">find</span>(E[i].a),Fb=<span class="built_in">find</span>(E[i].b);</span><br><span class="line">		<span class="keyword">if</span>(Fa==Fb)<span class="keyword">continue</span>;</span><br><span class="line">		v[++tot]=E[i].d;</span><br><span class="line">		faf[tot]=tot;</span><br><span class="line">		ch[tot][<span class="number">0</span>]=Fa,ch[tot][<span class="number">1</span>]=Fb;</span><br><span class="line">		faf[Fa]=faf[Fb]=tot;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> rt[N],cn;<span class="comment">//主席树</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> l,r,cn;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> l(x) tr[x].l</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> r(x) tr[x].r</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> cn(x) tr[x].cn</span></span><br><span class="line">&#125;tr[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">build</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> k,<span class="type">int</span> pr)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> p=++cn;</span><br><span class="line">	<span class="built_in">cn</span>(p)=<span class="built_in">cn</span>(pr)+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(l==r) <span class="keyword">return</span> p;</span><br><span class="line">	<span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(k&lt;=mid)<span class="built_in">l</span>(p)=<span class="built_in">build</span>(l,mid,k,<span class="built_in">l</span>(pr)),<span class="built_in">r</span>(p)=<span class="built_in">r</span>(pr);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">r</span>(p)=<span class="built_in">build</span>(mid+<span class="number">1</span>,r,k,<span class="built_in">r</span>(pr)),<span class="built_in">l</span>(p)=<span class="built_in">l</span>(pr);</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> k,<span class="type">int</span> L,<span class="type">int</span> R)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(k&gt;<span class="built_in">cn</span>(R)-<span class="built_in">cn</span>(L))<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span>(l==r)<span class="keyword">return</span> a[l];</span><br><span class="line">	<span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> sum=<span class="built_in">cn</span>(<span class="built_in">r</span>(R))-<span class="built_in">cn</span>(<span class="built_in">r</span>(L));</span><br><span class="line">	<span class="keyword">if</span>(k&lt;=sum)<span class="keyword">return</span> <span class="built_in">ask</span>(mid+<span class="number">1</span>,r,k,<span class="built_in">r</span>(L),<span class="built_in">r</span>(R));</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">ask</span>(l,mid,k-sum,<span class="built_in">l</span>(L),<span class="built_in">l</span>(R));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;<span class="comment">//求新编号并建起主席树</span></span><br><span class="line">	<span class="keyword">if</span>(!ch[p][<span class="number">0</span>])&#123;</span><br><span class="line">		idl[p]=idr[p]=++cnt;</span><br><span class="line">		rt[cnt]=<span class="built_in">build</span>(<span class="number">1</span>,n,h[p],rt[cnt<span class="number">-1</span>]);</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	fa[ch[p][<span class="number">0</span>]][<span class="number">0</span>]=fa[ch[p][<span class="number">1</span>]][<span class="number">0</span>]=p;</span><br><span class="line">	<span class="built_in">dfs</span>(ch[p][<span class="number">0</span>]);<span class="built_in">dfs</span>(ch[p][<span class="number">1</span>]);</span><br><span class="line">	idl[p]=idl[ch[p][<span class="number">0</span>]];</span><br><span class="line">	idr[p]=idr[ch[p][<span class="number">1</span>]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	n=<span class="built_in">read</span>(),m=<span class="built_in">read</span>(),q=<span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;h[i]=<span class="built_in">read</span>();a[i]=h[i];&#125;</span><br><span class="line">	<span class="built_in">sort</span>(a+<span class="number">1</span>,a+n+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)h[i]=<span class="built_in">lower_bound</span>(a+<span class="number">1</span>,a+n+<span class="number">1</span>,h[i])-a;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) E[i].a=<span class="built_in">read</span>(),E[i].b=<span class="built_in">read</span>(),E[i].d=<span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++) E[++m].a=<span class="number">1</span>,E[m].b=i,E[m].d=<span class="number">0x7fffffff</span>;</span><br><span class="line">	tot=n; <span class="built_in">kruskal</span>(); <span class="built_in">dfs</span>(tot);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">20</span>;i++) <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=tot;j++) fa[j][i]=fa[fa[j][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">	<span class="keyword">while</span>(q--)&#123;</span><br><span class="line">		<span class="type">int</span> u=<span class="built_in">read</span>(),x=<span class="built_in">read</span>(),k=<span class="built_in">read</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">20</span>;i&gt;=<span class="number">0</span>;i--) <span class="keyword">if</span>(fa[u][i]&amp;&amp;v[fa[u][i]]&lt;=x)u=fa[u][i];</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">ask</span>(<span class="number">1</span>,n,k,rt[idl[u]<span class="number">-1</span>],rt[idr[u]]));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Dumby的OI生涯</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>倍增</tag>
        <tag>Kruskal</tag>
        <tag>DFS</tag>
        <tag>主席树</tag>
      </tags>
  </entry>
  <entry>
    <title>测试用贴</title>
    <url>/2022/%E6%B5%8B%E8%AF%95%E7%94%A8%E8%B4%B4/</url>
    <content><![CDATA[<p>这是一个测试专用帖。</p>
<p>用于测试博客的各个功能。</p>
<span id="more"></span>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        可以收起的目录
    </div>
    <div class='spoiler-content'>
        <!-- toc -->
<ul>
<li><a href="#markdown-----">Markdown 测试部分</a></li>
<li><a href="#------">这是二级目录</a><ul>
<li><a href="#------">这是三级目录</a><ul>
<li><a href="#------">这是四级目录</a><br>~ <a href="#------">这是五级目录</a><ul>
<li><a href="#------">这是六级目录</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->

    </div>
</div>
<h2 id="Markdown-测试部分"><a href="#Markdown-测试部分" class="headerlink" title="Markdown 测试部分"></a>Markdown 测试部分</h2><p>目录没用。<br>25.6.24，目录有用了现在。</p>
<p>一级目录不建议使用</p>
<h2 id="这是二级目录"><a href="#这是二级目录" class="headerlink" title="这是二级目录"></a>这是二级目录</h2><h3 id="这是三级目录"><a href="#这是三级目录" class="headerlink" title="这是三级目录"></a>这是三级目录</h3><h4 id="这是四级目录"><a href="#这是四级目录" class="headerlink" title="这是四级目录"></a>这是四级目录</h4><h5 id="这是五级目录"><a href="#这是五级目录" class="headerlink" title="这是五级目录"></a>这是五级目录</h5><h6 id="这是六级目录"><a href="#这是六级目录" class="headerlink" title="这是六级目录"></a>这是六级目录</h6><p><em>这是斜体</em>，<strong>这是加黑</strong>，<del>这是删除线</del>。</p>
<blockquote>
<p>这是一个Tag。</p>
</blockquote>
<p>这是脚注<sup><a href="#fn_1" id="reffn_1">1</a></sup>。</p>
<p><a href="https://dumblog.top/">这是个链接</a>。</p>
<p>这是张照片。<br><img src="https://dumblog.top/favicon.ico" alt="这是张照片"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这是c++代码块</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;Hello World!!!&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码块有个神奇特性。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//```</span><br><span class="line">//DUMBLOG</span><br><span class="line">//```</span><br><span class="line">//写一些东西</span><br><span class="line">//</span><br><span class="line">//如上文字直接写在```下面一行代码块和文字间会有一个大空。</span><br><span class="line">//</span><br><span class="line">//</span><br><span class="line">//```</span><br><span class="line">//DUMBLOG</span><br><span class="line">//```</span><br><span class="line">//</span><br><span class="line">//写一些东西</span><br><span class="line">//</span><br><span class="line">//像这样空就会小很多</span><br></pre></td></tr></table></figure><br>这样空会很大。</p>
<ol>
<li>这是列表</li>
<li>这是列表</li>
</ol>
<ul>
<li>这还是列表</li>
<li><p>这还是列表</p>
</li>
<li><p>[ ] 这是任务单</p>
</li>
<li>[x] 这是完成的任务单</li>
</ul>
<p>任务单没用。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>这是表格</th>
<th>表格！！</th>
</tr>
</thead>
<tbody>
<tr>
<td>表格</td>
<td>表格</td>
</tr>
</tbody>
</table>
</div>
<p>$\LaTeX$<br>行间公式用不了。</p>
<blockquote id="fn_1">
<sup>1</sup>. 脚注中间有空格。<a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a>
</blockquote>
<h2 id="内部测试部分"><a href="#内部测试部分" class="headerlink" title="内部测试部分"></a>内部测试部分</h2><a href="/2022/%E6%96%B0%E5%B9%B4%E5%A5%BD%EF%BC%81%EF%BC%81%EF%BC%81/" title="引用站内文章">引用站内文章</a>
<p><a href="/">这是一个站内链接</a></p>
<p>引用站内图片。</p>
<p><img src="test.png" alt="引用站内图片" title="引用站内图片"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">用这种方法引用的图片在站长工具中显示缺少alt标签：</span><br><span class="line">&#123;% asset_img test.png 引用站内图片 %&#125;</span><br><span class="line"></span><br><span class="line">改用这种就可以手动添加alt标签：</span><br><span class="line">&lt;img src=&quot;&#123;&#123; &#x27;test.png&#x27; &#125;&#125;&quot; alt=&quot;引用站内图片&quot; title=&quot;引用站内图片&quot;&gt;</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>站务</category>
      </categories>
      <tags>
        <tag>站务</tag>
        <tag>测试</tag>
        <tag>功能</tag>
      </tags>
  </entry>
  <entry>
    <title>组合数学入门笔记</title>
    <url>/2021/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E7%9A%84%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>来学组合数学！</p>
<span id="more"></span>
<h2 id="加法及乘法原理"><a href="#加法及乘法原理" class="headerlink" title="加法及乘法原理"></a>加法及乘法原理</h2><h3 id="加法原理"><a href="#加法原理" class="headerlink" title="加法原理"></a>加法原理</h3><p>完成一件事有 $n$ 类方法，每类方法有 $m$ 个不同的方法，那么完成这件事总共就有 $N=m_{1}+m_{2}+…+m_{n}$ 种方法。</p>
<h3 id="乘法原理"><a href="#乘法原理" class="headerlink" title="乘法原理"></a>乘法原理</h3><p>完成一件事有 $n$ 个步骤，每个步骤有 $m$ 个不同的方法，那么完成这件事总共就有 $N=m_{1} \times m_{2} \times … \times m_{n}$ 种方法。</p>
<h2 id="排列与组合入门"><a href="#排列与组合入门" class="headerlink" title="排列与组合入门"></a>排列与组合入门</h2><h3 id="排列与排列数"><a href="#排列与排列数" class="headerlink" title="排列与排列数"></a>排列与排列数</h3><p>在 $n$ 个元素中任取 $m$ （$m&lt;=n$，$m,n \in N$）个元素，按照一定顺序排列，所有的情况的个数叫做 <strong>从 $n$ 个不同元素中取出 $m$ 个的排列数</strong>。</p>
<p>公式如下：</p>
<p>$ A^{m}_{n}=\left ( n-m+1 \right )…\left ( n-2 \right )\left ( n-1 \right )n=\frac{n!}{\left (n-m\right )!} $</p>
<p>如何理解这个公式：</p>
<p>有 $m$ 个位置，第一个有 $n$ 种选法，第二个有 $n-1$ 种，以此类推，第 $m$ 种有 1 种选法，所以由乘法原理可得总方案数为 $\left ( n-m+1 \right )…\left ( n-2 \right )\left ( n-1 \right )n$。</p>
<h3 id="组合与组合数"><a href="#组合与组合数" class="headerlink" title="组合与组合数"></a>组合与组合数</h3><p>在 $n$ 个元素中任取 $m$ （$m&lt;=n$，$m,n \in N$）个元素，组成一个组合（集合），所有的情况的个数叫做 <strong>从 $n$ 个不同元素中取出 $m$ 个的组合数</strong>。</p>
<p>公式如下：</p>
<p>$C^{m}_{n}=\frac{A^{m}_{n}}{m!}=\frac{n!}{m!\left (n-m\right)!}$</p>
<p>如何理解这个公式：</p>
<p>一个 $m$ 个元素的序列的全排列的序列数为 $m!$，所以将排列数除去全排列的序列数就为组合数。</p>
<p><strong>$C^{m}_{n}$ 还写成 $\begin{pmatrix}n \\m\end{pmatrix}$，组合数也叫二项式系数</strong>。</p>
<p>特别地，当 $m&gt;n$ 时，$A^{m}_{n}=C^{m}_{n}=0$。</p>
<h4 id="C-求组合数代码"><a href="#C-求组合数代码" class="headerlink" title="C++ 求组合数代码"></a>C++ 求组合数代码</h4><p>递归：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100005</span>, MOD = <span class="number">19260817</span>;</span><br><span class="line"><span class="type">int</span> a[N], ans;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">C</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= m; i--) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (m &gt; <span class="number">1</span>) <span class="built_in">C</span>(n - <span class="number">1</span>, m - <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">else</span> ans = (ans + <span class="number">1</span>) % MOD;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>递推：</p>
<p>组合数满足以下递推式：</p>
<p>$\left\{\begin{matrix} C^{m}_{n}=C^{m-1}_{n}+C^{m-1}_{n-1},n&gt;m&gt;0\\C^{m}_{n}=1,m=0 或 n=m\end{matrix}\right.$</p>
<p>所以代码很容易打出来了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1005</span>, MOD = <span class="number">19260817</span>;</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">C</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">0</span> || m == n) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= m; i++) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt;= n; i++) </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (i == <span class="number">0</span>)f[i][j] = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span> f[i][j] = f[i - <span class="number">1</span>][j - <span class="number">1</span>] + f[i - <span class="number">1</span>][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> f[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>求排列数则只要<br>将组合数乘上 $m!$ 就好了。</p>
<h4 id="二项式定理"><a href="#二项式定理" class="headerlink" title="二项式定理"></a>二项式定理</h4><p>公式如下：</p>
<p>$\left ( a+b \right )^{n}= {\textstyle \sum_{n}^{i=0}\begin{pmatrix}n \\i\end{pmatrix}a^{n-i}b^{i}}$</p>
<p>其实很好理解，自己手推一下就出来了。</p>
<h2 id="Catalan（卡特兰）数列"><a href="#Catalan（卡特兰）数列" class="headerlink" title="Catalan（卡特兰）数列"></a>Catalan（卡特兰）数列</h2><p>没什么好说的，记个公式（要推导它的通项公式需要生成函数，反正本蒟蒻不会）。</p>
<p>$Cat_{0}=Cat_{1}=1$</p>
<p>$Cat_{n}=\frac{\begin{pmatrix}2n\\n\end{pmatrix}}{n+1}\left ( n\ge 2,n \in N^{+}\right )$</p>
<p>其他 Catalan 数列常用公式：</p>
<p>$Cat_{n}=\frac{Cat_{n-1}\left ( 4n-2 \right )}{n+1}$</p>
<p>$Cat_{n}=\begin{pmatrix} 2n\\n\end{pmatrix}-\begin{pmatrix} 2n\\n-1\end{pmatrix}$</p>
<p>$Cat_{n}=\left\{\begin{matrix}{\textstyle \sum_{i=1}^{n}Cat_{i-1}Cat_{n-i}},n\ge 2,n\in N^{+} \\1, n=0,1\end{matrix}\right.$</p>
<p>代码可以由 $Cat_{n}=\frac{Cat_{n-1}\left ( 4n-2 \right )}{n+1}$ 很简单的写出来，这里就不放了。</p>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ol>
<li>对角线不相交，将一个凸多边形分成多个三角形的方案数。</li>
<li>一个序列的进栈顺序为 $1,2,3…,n-1,n$，求有几种不同的出栈序列。</li>
<li>$n$ 个节点可以构成多少个不同的二叉树。</li>
<li>等等等等</li>
</ol>
<p>ok，有错误请 D 我。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Dumby的OI生涯</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>数论</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title>线段树合并与分裂略解</title>
    <url>/2022/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%90%88%E5%B9%B6%E4%B8%8E%E5%88%86%E8%A3%82/</url>
    <content><![CDATA[<p>学习一下线段树的合并和分裂（内附代码实现）。</p>
<span id="more"></span>
<h2 id="前置芝士"><a href="#前置芝士" class="headerlink" title="前置芝士"></a>前置芝士</h2><ul>
<li>动态开点线段树</li>
<li>线段树的一般操作（建树、修改、查询等）</li>
</ul>
<p>（线段树分裂与合并通常建立在一棵值域线段树上）</p>
<h2 id="线段树合并"><a href="#线段树合并" class="headerlink" title="线段树合并"></a>线段树合并</h2><p>首先，线段树合并。</p>
<p>假设我们要将 $R$ 树合并到 $L$ 树上。</p>
<p>流程如下：</p>
<ol>
<li>在两棵树上都递归到一个位置，如果 $L$ 树的该位置对应的节点 $u$ 为空，则返回 $R$ 树的 $u$，反之亦然；</li>
<li>如果两棵树都有 $u$ 节点，则将 $R_{u}$ 的信息加到 $L_{u}$ 上，删除 $R_{u}$（也可不删，但在一些毒瘤题里可能会被卡空间），返回。</li>
</ol>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> rt[<span class="number">1000</span>],n;<span class="comment">//rt[]是每棵树的根</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> l=<span class="number">0</span>,r=<span class="number">0</span>,cn=<span class="number">0</span>;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> l(x) tr[x].l</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> r(x) tr[x].r</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> cn(x) tr[x].cn</span></span><br><span class="line">&#125;tr[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> q,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!p)<span class="keyword">return</span> q;</span><br><span class="line">	<span class="keyword">if</span>(!q)<span class="keyword">return</span> p;</span><br><span class="line">	<span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">		<span class="built_in">cn</span>(p)+=<span class="built_in">cn</span>(q);</span><br><span class="line">		<span class="keyword">return</span> p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">l</span>(p)=<span class="built_in">merge</span>(<span class="built_in">l</span>(p),<span class="built_in">l</span>(q),l,mid);</span><br><span class="line">	<span class="built_in">r</span>(p)=<span class="built_in">merge</span>(<span class="built_in">r</span>(p),<span class="built_in">r</span>(q),mid+<span class="number">1</span>,r);</span><br><span class="line">	<span class="built_in">cn</span>(p)=<span class="built_in">cn</span>(<span class="built_in">l</span>(p))+<span class="built_in">cn</span>(<span class="built_in">r</span>(p));</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">merge</span>(rt[L],rt[R],<span class="number">1</span>,n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="线段树分裂"><a href="#线段树分裂" class="headerlink" title="线段树分裂"></a>线段树分裂</h2><p>线段树分裂是线段树合并的逆过程。</p>
<p>我们假设要把 $L$ 树从 $k$ 处分裂成 $L$ 树（和分裂前不一样）和 $R$ 树，即将原来 $L$ 树中小于等于 $k$ 的数放到新 $L$ 树中，大于 $k$ 的数放到 $R$ 树中。</p>
<p>流程如下：</p>
<ol>
<li>到达一个节点 $L_{u}$，判断 $k$ 在 $L_{u}$ 的左子树中还是右子树中；</li>
<li>如果在左子树中，则直接将 $L_{u}$ 的右子树给 $R_{u}$，并将 $L_{u}$ 的右子树删除，递归进入左子树；</li>
<li>如果在右子树中，则左子树不动，递归进入右子树；</li>
<li>如果到达叶子结点，则将 $L$ 的该节点作为 $R$ 的节点。</li>
</ol>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">split</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span>&amp; q,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!p)<span class="keyword">return</span> ;</span><br><span class="line">	q=++tot;</span><br><span class="line">	<span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">		<span class="built_in">swap</span>(<span class="built_in">cn</span>(p),<span class="built_in">cn</span>(q));</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(k&lt;=mid)<span class="built_in">swap</span>(<span class="built_in">r</span>(p),<span class="built_in">r</span>(q)),<span class="built_in">split</span>(<span class="built_in">l</span>(p),<span class="built_in">l</span>(q),l,mid,k);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">split</span>(<span class="built_in">r</span>(p),<span class="built_in">r</span>(q),mid+<span class="number">1</span>,r,k);</span><br><span class="line">	<span class="built_in">cn</span>(p)=<span class="built_in">cn</span>(<span class="built_in">l</span>(p))+<span class="built_in">cn</span>(<span class="built_in">r</span>(p));</span><br><span class="line">	<span class="built_in">cn</span>(q)=<span class="built_in">cn</span>(<span class="built_in">l</span>(q))+<span class="built_in">cn</span>(<span class="built_in">r</span>(q));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">split</span>(rt[L],rt[R],<span class="number">1</span>,n,k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p><a href="https://www.luogu.com.cn/problem/P5494">洛谷P5494</a>。</p>
<p>将线段树的合并与分裂有机结合。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mp(x,y) make_pair(x,y)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb(x) push_back(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PII pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD=<span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">10000002</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">10000001</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;<span class="keyword">register</span> <span class="type">char</span> c=<span class="built_in">getchar</span>();<span class="keyword">register</span> <span class="type">int</span> s=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">for</span>(;!<span class="built_in">isdigit</span>(c);c=<span class="built_in">getchar</span>())<span class="keyword">if</span>(c==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">-1</span>;<span class="keyword">for</span>(;<span class="built_in">isdigit</span>(c);c=<span class="built_in">getchar</span>())s=(s&lt;&lt;<span class="number">3</span>)+(s&lt;&lt;<span class="number">1</span>)+c-<span class="string">&#x27;0&#x27;</span>;<span class="keyword">return</span> s*f;&#125;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> rt[N],tot,cnt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> l=<span class="number">0</span>,r=<span class="number">0</span>,cn=<span class="number">0</span>;</span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> l(x) tr[x].l</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> r(x) tr[x].r</span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> cn(x) tr[x].cn</span></span><br><span class="line">&#125;tr[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">build</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> p=++tot;</span><br><span class="line">	<span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">		<span class="built_in">cn</span>(p)=a[l];</span><br><span class="line">		<span class="keyword">return</span> p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">l</span>(p)=<span class="built_in">build</span>(l,mid);</span><br><span class="line">	<span class="built_in">r</span>(p)=<span class="built_in">build</span>(mid+<span class="number">1</span>,r);</span><br><span class="line">	<span class="built_in">cn</span>(p)=<span class="built_in">cn</span>(<span class="built_in">l</span>(p))+<span class="built_in">cn</span>(<span class="built_in">r</span>(p));</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> &amp;p,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> k,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!p)p=++tot;</span><br><span class="line">	<span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">		<span class="built_in">cn</span>(p)+=x;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(k&lt;=mid)<span class="built_in">add</span>(<span class="built_in">l</span>(p),l,mid,k,x);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">add</span>(<span class="built_in">r</span>(p),mid+<span class="number">1</span>,r,k,x);</span><br><span class="line">	<span class="built_in">cn</span>(p)=<span class="built_in">cn</span>(<span class="built_in">l</span>(p))+<span class="built_in">cn</span>(<span class="built_in">r</span>(p));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qcn</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> L,<span class="type">int</span> R)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(L&lt;=l&amp;&amp;r&lt;=R)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">cn</span>(p);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(L&lt;=mid)ans+=<span class="built_in">qcn</span>(<span class="built_in">l</span>(p),l,mid,L,R);</span><br><span class="line">	<span class="keyword">if</span>(R&gt;mid)ans+=<span class="built_in">qcn</span>(<span class="built_in">r</span>(p),mid+<span class="number">1</span>,r,L,R);</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qk</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(k&gt;<span class="built_in">cn</span>(p))<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span>(l==r)<span class="keyword">return</span> l;</span><br><span class="line">	<span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(k&lt;=<span class="built_in">cn</span>(<span class="built_in">l</span>(p)))<span class="keyword">return</span> <span class="built_in">qk</span>(<span class="built_in">l</span>(p),l,mid,k);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">qk</span>(<span class="built_in">r</span>(p),mid+<span class="number">1</span>,r,k-<span class="built_in">cn</span>(<span class="built_in">l</span>(p)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> q,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!p)<span class="keyword">return</span> q;</span><br><span class="line">	<span class="keyword">if</span>(!q)<span class="keyword">return</span> p;</span><br><span class="line">	<span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">		<span class="built_in">cn</span>(p)+=<span class="built_in">cn</span>(q);</span><br><span class="line">		<span class="keyword">return</span> p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">l</span>(p)=<span class="built_in">merge</span>(<span class="built_in">l</span>(p),<span class="built_in">l</span>(q),l,mid);</span><br><span class="line">	<span class="built_in">r</span>(p)=<span class="built_in">merge</span>(<span class="built_in">r</span>(p),<span class="built_in">r</span>(q),mid+<span class="number">1</span>,r);</span><br><span class="line">	<span class="built_in">cn</span>(p)=<span class="built_in">cn</span>(<span class="built_in">l</span>(p))+<span class="built_in">cn</span>(<span class="built_in">r</span>(p));</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">split</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span>&amp; q,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!p)<span class="keyword">return</span> ;</span><br><span class="line">	q=++tot;</span><br><span class="line">	<span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">		<span class="built_in">swap</span>(<span class="built_in">cn</span>(p),<span class="built_in">cn</span>(q));</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(k&lt;=mid)<span class="built_in">swap</span>(<span class="built_in">r</span>(p),<span class="built_in">r</span>(q)),<span class="built_in">split</span>(<span class="built_in">l</span>(p),<span class="built_in">l</span>(q),l,mid,k);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">split</span>(<span class="built_in">r</span>(p),<span class="built_in">r</span>(q),mid+<span class="number">1</span>,r,k);</span><br><span class="line">	<span class="built_in">cn</span>(p)=<span class="built_in">cn</span>(<span class="built_in">l</span>(p))+<span class="built_in">cn</span>(<span class="built_in">r</span>(p));</span><br><span class="line">	<span class="built_in">cn</span>(q)=<span class="built_in">cn</span>(<span class="built_in">l</span>(q))+<span class="built_in">cn</span>(<span class="built_in">r</span>(q));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	n=<span class="built_in">read</span>(),m=<span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i]=<span class="built_in">read</span>();</span><br><span class="line">	rt[++cnt]=<span class="built_in">build</span>(<span class="number">1</span>,n);</span><br><span class="line">	<span class="keyword">while</span>(m--)&#123;</span><br><span class="line">		<span class="type">int</span> t=<span class="built_in">read</span>(),p=<span class="built_in">read</span>(),x=<span class="built_in">read</span>();</span><br><span class="line">		<span class="keyword">if</span>(t==<span class="number">0</span>)&#123;</span><br><span class="line">			<span class="type">int</span> y=<span class="built_in">read</span>();</span><br><span class="line">			<span class="type">int</span> tmp=<span class="number">0</span>;</span><br><span class="line">			<span class="built_in">split</span>(rt[p],tmp,<span class="number">1</span>,n,y+<span class="number">1</span>);</span><br><span class="line">			<span class="built_in">split</span>(rt[p],rt[++cnt],<span class="number">1</span>,n,x);</span><br><span class="line">			<span class="built_in">merge</span>(rt[p],tmp,<span class="number">1</span>,n);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(t==<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="built_in">merge</span>(rt[p],rt[x],<span class="number">1</span>,n);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(t==<span class="number">2</span>)&#123;</span><br><span class="line">			<span class="type">int</span> y=<span class="built_in">read</span>();</span><br><span class="line">			<span class="built_in">add</span>(rt[p],<span class="number">1</span>,n,y,x);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(t==<span class="number">3</span>)&#123;</span><br><span class="line">			<span class="type">int</span> y=<span class="built_in">read</span>();</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">qcn</span>(rt[p],<span class="number">1</span>,n,x,y));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">qk</span>(rt[p],<span class="number">1</span>,n,x));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Dumby的OI生涯</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>线段树</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>虽然我也很菜，但是🐷B队友</title>
    <url>/2025/%E8%99%BD%E7%84%B6%E6%88%91%E4%B9%9F%E5%BE%88%E8%8F%9C%EF%BC%8C%E4%BD%86%E6%98%AF%F0%9F%90%B7B%E9%98%9F%E5%8F%8B/</url>
    <content><![CDATA[<p>吐槽。</p>
<span id="more"></span>
<p>🐷B吗，有点意思。</p>
<p>发我依托💩🌄叫我看，我硬着头皮看了两天看不懂。</p>
<p>我tm问你才知道原来tm就一段代码是有用的。</p>
<p>不是哥们你tm礼貌吗？</p>
<p>合着我tm两天啥也没干呗？</p>
<p>🤣</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Dumby的sb日常</category>
      </categories>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title>龟速乘学习笔记</title>
    <url>/2021/%E9%BE%9F%E9%80%9F%E4%B9%98%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>快速幂死了该用什么替代呢（嘻嘻），本文介绍龟速乘的原理及使用（内附代码实现）。</p>
<span id="more"></span>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>关于快速幂：<br>它死了。<br>咳咳。<br>以下是快速幂模板：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">q_p</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> k, <span class="type">int</span> p)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (k) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (k &amp; <span class="number">1</span>)ans = ans * a % p;</span><br><span class="line">		k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">		a = a * a % p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>可以看出，快速幂有一个缺点：当模数 p 大于 int 范围（最大值为 $2^{31}-1$）时，快速幂会爆 long long。<br>此时解决 $a^{b} \bmod c$ 的问题时就无法用快速幂了。<br>于是，龟速乘应运而生。</p>
<h2 id="龟速乘"><a href="#龟速乘" class="headerlink" title="龟速乘"></a>龟速乘</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>通过将 <strong>乘法</strong> 转化为 <strong>加法</strong>并<strong>每次取模</strong> 而避免了爆 long long。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//龟速乘</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">q_m</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> k, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (k)</span><br><span class="line">	&#123;<span class="comment">//    区别在这里 ↓</span></span><br><span class="line">		<span class="keyword">if</span>(k &amp; <span class="number">1</span>)ans += a, ans %= p;</span><br><span class="line">		k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">		a = a + a, a %= p;</span><br><span class="line">		<span class="comment">//和这里 ↑</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//快速幂</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">q_p</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> k, <span class="type">int</span> p)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (k) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (k &amp; <span class="number">1</span>)ans = <span class="built_in">q_m</span>(ans, a, p), ans %= p;</span><br><span class="line">		k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">		a = <span class="built_in">q_m</span>(a, a, p), a %= p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="速度"><a href="#速度" class="headerlink" title="速度"></a>速度</h3><p>顾名思义，龟速乘会比系统的乘法慢一些。</p>
<p>OK就这样。<br>本蒟蒻新学 OI ，如有错误请 D 我。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Dumby的OI生涯</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>进化论</title>
    <url>/2022/%E8%BF%9B%E5%8C%96%E8%AE%BA/</url>
    <content><![CDATA[<p>写在前面：</p>
<p><em>最近三天是本校的期中考试，考试期间略读了一些鲁迅先生的文章，觉得有些上头。正巧考完试正在情绪激动之时，就胡写了一通。我本不是什么做文章的人，只是心里憋着难受，便随意地狗叫了一通，文章毫无逻辑，文笔也是十分拙劣，就当是篇粗劣的爽文好了。</em></p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">			   进化论</span><br><span class="line">    量变引起质变，在质变的基础上又有新一轮的量变。古代的猿猴，在一轮</span><br><span class="line">又一轮的量变与质变中，逐渐进化成人类。而如今，量变的积累也足够引起新</span><br><span class="line">的质变了，于是，“出题人”这一新物种便诞生了。</span><br><span class="line">    虽然“出题人”这个物种与人类外形相似，但内在却大不相同。正如原人之</span><br><span class="line">于猿猴，人类之于原人，“出题人”的知识与智慧，自然也是在“人类”这一物种</span><br><span class="line">之上。</span><br><span class="line">    又如人类之戏耍猿猴，“出题人”喜好将人类当做猿猴般戏耍。而其方式，</span><br><span class="line">虽然不是用皮鞭抽，或是关在玻璃笼中观赏，却是通过一种简单而粗暴的方法，</span><br><span class="line">其于人类社会中叫做“考试”。而施行此方法的主要工具在人类社会中叫做“试</span><br><span class="line">卷”。</span><br><span class="line">    又如在人类社会的动物园中的猿猴，被关于笼中一年又一年，一代又一代，</span><br><span class="line">久而久之，便习惯了人类的围观与玩弄，人类一年又一年，一代又一代地考试，</span><br><span class="line">自然也是习惯了的。</span><br><span class="line">    然而人类社会并非所有都会被“出题人”抓去玩耍。好比人类会将一些猿猴</span><br><span class="line">放生，以便其去维持生态平衡，因为生态不平衡，人类是无法存活的。“出题</span><br><span class="line">人”也一样，会将许多人类放生，以便其去维持生态平衡（于人类即人类的社</span><br><span class="line">会），因为生态不平衡，“出题人”同样是无法存活的。</span><br><span class="line">    不知猿猴社会是如何称呼被人类抓去的那部分的，毕竟我并不是猿猴。不</span><br><span class="line">过人类社会也确乎对那些被“出题人”抓取的有个称谓，叫做“考生”。</span><br><span class="line">    这“考生”日日受“出题人”的侮辱挑逗，自然是十分不满，于是他们决定反</span><br><span class="line">抗。</span><br><span class="line">    但猿猴终究是建不起高楼大厦的。“考生”终归也只是人类，其知识、智慧</span><br><span class="line">乃至一切都是于“出题人”之下的。</span><br><span class="line">    哎哎！可怜的人类的考生！他们到头来连“出题人”们随手设下的于他们如</span><br><span class="line">玩具般的“试卷”都破除不了，又怎能用其愚蠢而鄙陋的目光窥测“出题人”智慧</span><br><span class="line">又深邃的心灵呢？更无需谈反抗了！</span><br><span class="line">    ······</span><br><span class="line">    终会有人类的勇士出现在“考生”之中的！其能够破除所谓“试卷”，用自身</span><br><span class="line">的光芒将“出题人”的宇宙般的心灵照得一清二楚。他竟能够反抗！</span><br><span class="line">    ······</span><br><span class="line">    就如石猴子敌不过如来佛一般罢，人类的勇士拼尽了全力，却只能得到一</span><br><span class="line">个“A”或是“100”。</span><br><span class="line">    然后便无了，一切都无了。</span><br><span class="line">    那进化后的人类冷冷一笑，那未进化的人类的勇士，未进化的人类的荣光，</span><br><span class="line">便像烟花一般，闪了一下，然后便落下去，无尽地落下去，消失在“出题人”的</span><br><span class="line">黑暗的罗网中。</span><br><span class="line">    这便是进化与未进化的人类罢。</span><br></pre></td></tr></table></figure>
<p><em>以上纯属个人口嗨，勿喷</em></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>Dumby的sb日常</category>
      </categories>
      <tags>
        <tag>日常</tag>
        <tag>狗P文学</tag>
      </tags>
  </entry>
</search>
